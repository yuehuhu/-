[
    {
        "API": "java.util.function",
        "Code": "\n     // Assignment context\n     Predicate<String> p = String::isEmpty;\n\n     // Method invocation context\n     stream.filter(e -> e.getSize() > 10)...\n\n     // Cast context\n     stream.map((ToIntFunction) e -> e.getSize())...\n ",
        "Description": "functional method The interfaces in this package are general purpose functional interfaces\n used by the JDK, and are available to be used by user code as well.  While\n they do not identify a complete set of function shapes to which lambda\n expressions might be adapted, they provide enough to cover common\n requirements. Other functional interfaces provided for specific purposes,\n such as FileFilter, are defined in the packages where they\n are used.\n\n "
    },
    {
        "API": "java.util.stream",
        "Code": "\n     int sum = widgets.stream()\n                      .filter(b -> b.getColor() == RED)\n                      .mapToInt(b -> b.getWeight())\n                      .sum();\n ",
        "Description": " Here we use widgets, a Collection<Widget>,\n as a source for a stream, and then perform a filter-map-reduce on the stream\n to obtain the sum of the weights of the red widgets.  (Summation is an\n example of a reduction\n operation.)\n\n "
    },
    {
        "API": "java.util.stream",
        "Code": "\n     int sumOfWeights = widgets.parallelStream()\n                               .filter(b -> b.getColor() == RED)\n                               .mapToInt(b -> b.getWeight())\n                               .sum();\n ",
        "Description": "Processing elements with an explicit for-loop is inherently serial.\n Streams facilitate parallel execution by reframing the computation as a pipeline of\n aggregate operations, rather than as imperative operations on each individual\n element.  All streams operations can execute either in serial or in parallel.\n The stream implementations in the JDK create serial streams unless parallelism is\n explicitly requested.  For example, Collection has methods\n Collection.stream() and Collection.parallelStream(),\n which produce sequential and parallel streams respectively; other\n stream-bearing methods such as IntStream.range(int, int)\n produce sequential streams but these streams can be efficiently parallelized by\n invoking their BaseStream.parallel() method.\n To execute the prior \"sum of weights of widgets\" query in parallel, we would\n do:\n\n  The only difference between the serial and parallel versions of this\n example is the creation of the initial stream, using \"parallelStream()\"\n instead of \"stream()\".  When the terminal operation is initiated,\n the stream pipeline is executed sequentially or in parallel depending on the\n orientation of the stream on which it is invoked.  Whether a stream will execute in serial or\n parallel can be determined with the isParallel() method, and the\n orientation of a stream can be modified with the\n BaseStream.sequential() and\n BaseStream.parallel() operations.  When the terminal\n operation is initiated, the stream pipeline is executed sequentially or in\n parallel depending on the mode of the stream on which it is invoked.\n\n "
    },
    {
        "API": "java.util.stream",
        "Code": "\n     List<String> l = new ArrayList(Arrays.asList(\"one\", \"two\"));\n     Stream<String> sl = l.stream();\n     l.add(\"three\");\n     String s = sl.collect(joining(\" \"));\n ",
        "Description": "Accordingly, behavioral parameters in stream pipelines whose source might\n not be concurrent should never modify the stream's data source.\n A behavioral parameter is said to interfere with a non-concurrent\n data source if it modifies, or causes to be\n modified, the stream's data source.  The need for non-interference applies\n to all pipelines, not just parallel ones.  Unless the stream source is\n concurrent, modifying a stream's data source during execution of a stream\n pipeline can cause exceptions, incorrect answers, or nonconformant behavior.\n\n For well-behaved stream sources, the source can be modified before the\n terminal operation commences and those modifications will be reflected in\n the covered elements.  For example, consider the following code:\n\n  collect"
    },
    {
        "API": "java.util.stream",
        "Code": "\n     Set<Integer> seen = Collections.synchronizedSet(new HashSet<>());\n     stream.parallel().map(e -> { if (seen.add(e)) return 0; else return e; })...\n ",
        "Description": "map() Note also that attempting to access mutable state from behavioral parameters\n presents you with a bad choice with respect to safety and performance; if\n you do not synchronize access to that state, you have a data race and\n therefore your code is broken, but if you do synchronize access to that\n state, you risk having contention undermine the parallelism you are seeking\n to benefit from.  The best approach is to avoid stateful behavioral\n parameters to stream operations entirely; there is usually a way to\n restructure the stream pipeline to avoid statefulness.\n\n "
    },
    {
        "API": "java.util.stream",
        "Code": "\n     ArrayList<String> results = new ArrayList<>();\n     stream.filter(s -> pattern.matcher(s).matches())\n           .forEach(s -> results.add(s));  // Unnecessary use of side-effects!\n ",
        "Description": "As an example of how to transform a stream pipeline that inappropriately\n uses side-effects to one that does not, the following code searches a stream\n of strings for those matching a given regular expression, and puts the\n matches in a list.\n\n  ArrayList"
    },
    {
        "API": "java.util.stream",
        "Code": "\n     List<String>results =\n         stream.filter(s -> pattern.matcher(s).matches())\n               .collect(Collectors.toList());  // No side-effects!\n ",
        "Description": "forEach() Ordering"
    },
    {
        "API": "java.util.stream",
        "Code": "\n    int sum = 0;\n    for (int x : numbers) {\n       sum += x;\n    }\n ",
        "Description": "Of course, such operations can be readily implemented as simple sequential\n loops, as in:\n  associative"
    },
    {
        "API": "java.util.stream",
        "Code": "\n    int sum = numbers.stream().reduce(0, (x,y) -> x+y);\n ",
        "Description": "stateless \n    int sum = numbers.stream().reduce(0, Integer::sum);\n "
    },
    {
        "API": "java.util.stream",
        "Code": "\n    int sum = numbers.stream().reduce(0, Integer::sum);\n ",
        "Description": "\n    int sum = numbers.stream().reduce(0, (x,y) -> x+y);\n  These reduction operations can run safely in parallel with almost no\n modification:\n "
    },
    {
        "API": "java.util.stream",
        "Code": "\n    int sum = numbers.parallelStream().reduce(0, Integer::sum);\n ",
        "Description": "These reduction operations can run safely in parallel with almost no\n modification:\n  Reduction parallellizes well because the implementation\n can operate on subsets of the data in parallel, and then combine the\n intermediate results to get the final correct answer.  (Even if the language\n had a \"parallel for-each\" construct, the mutative accumulation approach would\n still required the developer to provide\n thread-safe updates to the shared accumulating variable sum, and\n the required synchronization would then likely eliminate any performance gain from\n parallelism.)  Using reduce() instead removes all of the\n burden of parallelizing the reduction operation, and the library can provide\n an efficient parallel implementation with no additional synchronization\n required.\n\n "
    },
    {
        "API": "java.util.stream",
        "Code": "\n     OptionalInt heaviest = widgets.parallelStream()\n                                   .mapToInt(Widget::getWeight)\n                                   .max();\n ",
        "Description": "The \"widgets\" examples shown earlier shows how reduction combines with\n other operations to replace for loops with bulk operations.  If widgets\n is a collection of Widget objects, which have a getWeight method,\n we can find the heaviest widget with:\n  In its more general form, a reduce operation on elements of type\n <T> yielding a result of type <U> requires three parameters:\n "
    },
    {
        "API": "java.util.stream",
        "Code": "\n <U> U reduce(U identity,\n              BiFunction<U, ? super T, U> accumulator,\n              BinaryOperator<U> combiner);\n ",
        "Description": "In its more general form, a reduce operation on elements of type\n <T> yielding a result of type <U> requires three parameters:\n  identity"
    },
    {
        "API": "java.util.stream",
        "Code": "\n     int sumOfWeights = widgets.stream()\n                               .reduce(0,\n                                       (sum, b) -> sum + b.getWeight())\n                                       Integer::sum);\n ",
        "Description": "The three-argument form is a generalization of the two-argument form,\n incorporating a mapping step into the accumulation step.  We could\n re-cast the simple sum-of-weights example using the more general form as\n follows:\n  Mutable reduction"
    },
    {
        "API": "java.util.stream",
        "Code": "\n     String concatenated = strings.reduce(\"\", String::concat)\n ",
        "Description": "If we wanted to take a stream of strings and concatenate them into a\n single long string, we could achieve this with ordinary reduction:\n  We would get the desired result, and it would even work in parallel.  However,\n we might not be happy about the performance!  Such an implementation would do\n a great deal of string copying, and the run time would be O(n^2) in\n the number of characters.  A more performant approach would be to accumulate\n the results into a StringBuilder, which is a mutable\n container for accumulating strings.  We can use the same technique to\n parallelize mutable reduction as we do with ordinary reduction.\n\n "
    },
    {
        "API": "java.util.stream",
        "Code": "\n <R> R collect(Supplier<R> supplier,\n               BiConsumer<R, ? super T> accumulator,\n               BiConsumer<R, R> combiner);\n ",
        "Description": "The mutable reduction operation is called\n collect(),\n as it collects together the desired results into a result container such\n as a Collection.\n A collect operation requires three functions:\n a supplier function to construct new instances of the result container, an\n accumulator function to incorporate an input element into a result\n container, and a combining function to merge the contents of one result\n container into another.  The form of this is very similar to the general\n form of ordinary reduction:\n  As with reduce(), a benefit of expressing collect in this\n abstract way is that it is directly amenable to parallelization: we can\n accumulate partial results in parallel and then combine them, so long as the\n accumulation and combining functions satisfy the appropriate requirements.\n For example, to collect the String representations of the elements in a\n stream into an ArrayList, we could write the obvious sequential\n for-each form:\n "
    },
    {
        "API": "java.util.stream",
        "Code": "\n     ArrayList<String> strings = new ArrayList<>();\n     for (T element : stream) {\n         strings.add(element.toString());\n     }\n ",
        "Description": "As with reduce(), a benefit of expressing collect in this\n abstract way is that it is directly amenable to parallelization: we can\n accumulate partial results in parallel and then combine them, so long as the\n accumulation and combining functions satisfy the appropriate requirements.\n For example, to collect the String representations of the elements in a\n stream into an ArrayList, we could write the obvious sequential\n for-each form:\n  \n     ArrayList<String> strings = stream.collect(() -> new ArrayList<>(),\n                                                (c, e) -> c.add(e.toString()),\n                                                (c1, c2) -> c1.addAll(c2));\n "
    },
    {
        "API": "java.util.stream",
        "Code": "\n     ArrayList<String> strings = stream.collect(() -> new ArrayList<>(),\n                                                (c, e) -> c.add(e.toString()),\n                                                (c1, c2) -> c1.addAll(c2));\n ",
        "Description": "\n     ArrayList<String> strings = new ArrayList<>();\n     for (T element : stream) {\n         strings.add(element.toString());\n     }\n  \n     List<String> strings = stream.map(Object::toString)\n                                  .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);\n "
    },
    {
        "API": "java.util.stream",
        "Code": "\n     List<String> strings = stream.map(Object::toString)\n                                  .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);\n ",
        "Description": "\n     ArrayList<String> strings = stream.collect(() -> new ArrayList<>(),\n                                                (c, e) -> c.add(e.toString()),\n                                                (c1, c2) -> c1.addAll(c2));\n  ArrayList constructor"
    },
    {
        "API": "java.util.stream",
        "Code": "\n     List<String> strings = stream.map(Object::toString)\n                                  .collect(Collectors.toList());\n ",
        "Description": "The three aspects of collect -- supplier, accumulator, and\n combiner -- are tightly coupled.  We can use the abstraction of a\n Collector to capture all three aspects.  The\n above example for collecting strings into a List can be rewritten\n using a standard Collector as:\n  Packaging mutable reductions into a Collector has another advantage:\n composability.  The class Collectors contains a\n number of predefined factories for collectors, including combinators\n that transform one collector into another.  For example, suppose we have a\n collector that computes the sum of the salaries of a stream of\n employees, as follows:\n\n "
    },
    {
        "API": "java.util.stream",
        "Code": "\n     Collector<Employee, ?, Integer> summingSalaries\n         = Collectors.summingInt(Employee::getSalary);\n ",
        "Description": "Packaging mutable reductions into a Collector has another advantage:\n composability.  The class Collectors contains a\n number of predefined factories for collectors, including combinators\n that transform one collector into another.  For example, suppose we have a\n collector that computes the sum of the salaries of a stream of\n employees, as follows:\n\n  ?"
    },
    {
        "API": "java.util.stream",
        "Code": "\n     Map<Department, Integer> salariesByDept\n         = employees.stream().collect(Collectors.groupingBy(Employee::getDepartment,\n                                                            summingSalaries));\n ",
        "Description": "groupingBy As with the regular reduction operation, collect() operations can\n only be parallelized if appropriate conditions are met.  For any partially\n accumulated result, combining it with an empty result container must\n produce an equivalent result.  That is, for a partially accumulated result\n p that is the result of any series of accumulator and combiner\n invocations, p must be equivalent to\n combiner.apply(p, supplier.get()).\n\n "
    },
    {
        "API": "java.util.stream",
        "Code": "\n     A a1 = supplier.get();\n     accumulator.accept(a1, t1);\n     accumulator.accept(a1, t2);\n     R r1 = finisher.apply(a1);  // result without splitting\n\n     A a2 = supplier.get();\n     accumulator.accept(a2, t1);\n     A a3 = supplier.get();\n     accumulator.accept(a3, t2);\n     R r2 = finisher.apply(combiner.apply(a2, a3));  // result with splitting\n ",
        "Description": "Further, however the computation is split, it must produce an equivalent\n result.  For any input elements t1 and t2, the results\n r1 and r2 in the computation below must be equivalent:\n  Here, equivalence generally means according to Object.equals(Object).\n but in some cases equivalence may be relaxed to account for differences in\n order.\n\n "
    },
    {
        "API": "java.util.stream",
        "Code": "\n     Map<Buyer, List<Transaction>> salesByBuyer\n         = txns.parallelStream()\n               .collect(Collectors.groupingBy(Transaction::getBuyer));\n ",
        "Description": "Map Map"
    },
    {
        "API": "java.util.stream",
        "Code": "\n     Map<Buyer, List<Transaction>> salesByBuyer\n         = txns.parallelStream()\n               .unordered()\n               .collect(groupingByConcurrent(Transaction::getBuyer));\n ",
        "Description": "BaseStream.unordered() Collectors.groupingByConcurrent(java.util.function.Function<? super T, ? extends K>)"
    },
    {
        "API": "java.util.stream",
        "Code": "\n     (a op b) op c == a op (b op c)\n ",
        "Description": "associative \n     a op b op c op d == (a op b) op (c op d)\n "
    },
    {
        "API": "java.util.stream",
        "Code": "\n     a op b op c op d == (a op b) op (c op d)\n ",
        "Description": "\n     (a op b) op c == a op (b op c)\n  (a op b)"
    },
    {
        "API": "org.omg.CORBA",
        "Code": "\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 BAD_CONTEXT\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 BAD_INV_ORDER\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 BAD_OPERATION\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 BAD_PARAM\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 BAD_TYPECODE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 COMM_FAILURE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DATA_CONVERSION\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 FREE_MEM\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 IMP_LIMIT\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 INITIALIZE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 INTERNAL\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 INTF_REPOS\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 INVALID_TRANSACTION\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 INV_FLAG\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 INV_IDENT\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 INV_OBJREF\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 INV_POLICY\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 MARSHAL\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 NO_IMPLEMENT\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 NO_MEMORY\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 NO_PERMISSION\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 NO_RESOURCES\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 NO_RESPONSE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 OBJECT_NOT_EXIST\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 OBJ_ADAPTER\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 PERSIST_STORE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 TRANSACTION_REQUIRED\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 TRANSACTION_ROLLEDBACK\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 TRANSIENT\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 UNKNOWN\n",
        "Description": "The following is a list of the system exceptions (which are unchecked\nexceptions inheriting through \norg.omg.CORBA.SystemException from\njava.lang.RuntimeException) that are defined in the package \norg.omg.CORBA:\n \nThe following is a list of user-defined exceptions defined in the package\norg.omg.CORBA.\n"
    },
    {
        "API": "org.omg.CORBA",
        "Code": "\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Bounds\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 UnknownUserException\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 WrongTransaction\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 PolicyError\n",
        "Description": "\nThe following is a list of user-defined exceptions defined in the package\norg.omg.CORBA.\n Subpackages"
    },
    {
        "API": "org.omg.CORBA",
        "Code": "\npublic final class AccountHolder implements \n    org.omg.CORBA.portable.Streamable\n{\n  // field that holds an Account object\n  public Account value = null;\n\n  // default constructor\n  public AccountHolder ()\n  {\n  }\n  \n  // creates a new AccountHolder from initialValue\n  public AccountHolder (Account initialValue)\n  {\n    value = initialValue;\n  }\n  \n  // reads the contents of i and assigns the contents to value\n  public void _read (org.omg.CORBA.portable.InputStream i)\n  {\n    value = AccountHelper.read (i);\n  }\n\n  // writes value to o\n  public void _write (org.omg.CORBA.portable.OutputStream o)\n  {\n    AccountHelper.write (o, value);\n  }\n \n  // returns the typecode for Account\n  public org.omg.CORBA.TypeCode _type ()\n  {\n    return AccountHelper.type ();\n  }\n\n}\n",
        "Description": "\nAs an example, if the interface Account, defined in OMG IDL,\nwere mapped to the Java programming language, the following holder class\nwould be generated:\n For more information on Holder classes, see Chapter 1.4, Mapping for\nBasic Types in the \nOMG IDL to Java Language Mapping. The Holder classes defined \nin the package org.omg.CORBA are:\n"
    },
    {
        "API": "org.omg.CORBA",
        "Code": "\n\u00a0\u00a0\u00a0\u00a0 AnyHolder\n\u00a0\u00a0\u00a0\u00a0 AnySeqHolder\n\u00a0\u00a0\u00a0\u00a0 BooleanHolder\n\u00a0\u00a0\u00a0\u00a0 BooleanSeqHolder\n\u00a0\u00a0\u00a0\u00a0 ByteHolder\n\u00a0\u00a0\u00a0\u00a0 CharHolder\n\u00a0\u00a0\u00a0\u00a0 CharSeqHolder\n\u00a0\u00a0\u00a0\u00a0 CurrentHolder\n\u00a0\u00a0\u00a0\u00a0 DoubleHolder\n\u00a0\u00a0\u00a0\u00a0 DoubleSeqHolder\n\u00a0\u00a0\u00a0\u00a0 FixedHolder\n\u00a0\u00a0\u00a0\u00a0 FloatHolder\n\u00a0\u00a0\u00a0\u00a0 FloatSeqHolder\n\u00a0\u00a0\u00a0\u00a0 IntHolder\n\u00a0\u00a0\u00a0\u00a0 LongHolder\n\u00a0\u00a0\u00a0\u00a0 LongLongSeqHolder\n\u00a0\u00a0\u00a0\u00a0 LongSeqHolder\n\u00a0\u00a0\u00a0\u00a0 ObjectHolder\n\u00a0\u00a0\u00a0\u00a0 OctetSeqHolder\n\u00a0\u00a0\u00a0\u00a0 ParameterModeHolder\n\u00a0\u00a0\u00a0\u00a0 PolicyErrorHolder\n\u00a0\u00a0\u00a0\u00a0 PolicyListHolder\n\u00a0\u00a0\u00a0\u00a0 PrincipalHolder\n\u00a0\u00a0\u00a0\u00a0 ServiceInformationHolder\n\u00a0\u00a0\u00a0\u00a0 ShortHolder\n\u00a0\u00a0\u00a0\u00a0 ShortSeqHolder\n\u00a0\u00a0\u00a0\u00a0 StringHolder\n\u00a0\u00a0\u00a0\u00a0 StringSeqHolder\n\u00a0\u00a0\u00a0\u00a0 TypeCodeHolder\n\u00a0\u00a0\u00a0\u00a0 ULongLongSeqHolder\n\u00a0\u00a0\u00a0\u00a0 ULongSeqHolder\n\u00a0\u00a0\u00a0\u00a0 UnknownUserExceptionHolder\n\u00a0\u00a0\u00a0\u00a0 UShortSeqHolder\n\u00a0\u00a0\u00a0\u00a0 ValueBaseHolder\n\u00a0\u00a0\u00a0\u00a0 WCharSeqHolder\n\u00a0\u00a0\u00a0\u00a0 WrongTransactionHolder\n\u00a0\u00a0\u00a0\u00a0 WStringSeqHolder\n\n",
        "Description": "For more information on Holder classes, see Chapter 1.4, Mapping for\nBasic Types in the \nOMG IDL to Java Language Mapping. The Holder classes defined \nin the package org.omg.CORBA are:\n Helper Classes "
    },
    {
        "API": "org.omg.CORBA",
        "Code": "\n        // create and initialize the ORB\n        ORB orb = ORB.init(args, null);\n\n        // get the root naming context\n        org.omg.CORBA.Object objRef = \n            orb.resolve_initial_references(\"NameService\");\n        // Use NamingContextExt instead of NamingContext. This is \n        // part of latest Inter-Operable naming Service.  \n        NamingContextExt ncRef = NamingContextExtHelper.narrow(objRef);\n \n        // resolve the Object Reference in Naming\n        String name = \"Hello\";\n        helloImpl = HelloHelper.narrow(ncRef.resolve_str(name));\n",
        "Description": "\n "
    },
    {
        "API": "org.omg.CORBA",
        "Code": "\nabstract public class AccountHelper\n{\n  private static String  _id = \"IDL:Account:1.0\";\n\n  // inserts an Account object into an Any object\n  public static void insert (org.omg.CORBA.Any a, Account that)\n  {\n    org.omg.CORBA.portable.OutputStream out = a.create_output_stream ();\n    a.type (type ());\n    write (out, that);\n    a.read_value (out.create_input_stream (), type ());\n  }\n\n  // extracts an Account object from an Any object\n  public static Account extract (org.omg.CORBA.Any a)\n  {\n    return read (a.create_input_stream ());\n  }\n\n  \n  private static org.omg.CORBA.TypeCode __typeCode = null;\n  // gets the typecode for this type\n  synchronized public static org.omg.CORBA.TypeCode type ()\n  {\n    if (__typeCode == null)\n    {\n      __typeCode = org.omg.CORBA.ORB.init ().create_interface_tc (AccountHelper.id (), \"Account\");\n    }\n    return __typeCode;\n  }\n\n  // gets the repository id for this type\n  public static String id ()\n  {\n    return _id;\n  }\n\n  // reads an Account object from an input stream\n  public static Account read (org.omg.CORBA.portable.InputStream istream)\n  {\n    return narrow (istream.read_Object (_AccountStub.class));\n  }\n\n  // writes an Account object to an outputstream\n  public static void write (org.omg.CORBA.portable.OutputStream ostream, Account value)\n  {\n    ostream.write_Object ((org.omg.CORBA.Object) value);\n  }\n\n  // converts (narrows) an Object to an Account object\n  public static Account narrow (org.omg.CORBA.Object obj)\n  {\n    if (obj == null)\n      return null;\n    else if (obj instanceof Account)\n      return (Account)obj;\n    else if (!obj._is_a (id ()))\n      throw new org.omg.CORBA.BAD_PARAM ();\n    else\n    {\n      org.omg.CORBA.portable.Delegate delegate = ((org.omg.CORBA.portable.ObjectImpl)obj)._get_delegate ();\n      _AccountStub stub = new _AccountStub ();\n      stub._set_delegate(delegate);\n      return stub;\n    }\n  }\n\n}\n",
        "Description": "\nFor example, assuming that the interface Account is not a\nvalue type IDL type and is also not an abstract interface and has no\nabstract base interfaces, its AccountHelper class will look\nlike this:\n \n"
    },
    {
        "API": "org.omg.CORBA",
        "Code": "\nabstract public class AddressHelper\n{\n  private static String  _id = \"IDL:Address:1.0\";\n\n  // same as for non-value type\n  public static void insert (org.omg.CORBA.Any a, Address that)\n  {\n    org.omg.CORBA.portable.OutputStream out = a.create_output_stream ();\n    a.type (type ());\n    write (out, that);\n    a.read_value (out.create_input_stream (), type ());\n  }\n\n  // same as for non-value type\n  public static Address extract (org.omg.CORBA.Any a)\n  {\n    return read (a.create_input_stream ());\n  }\n\n  private static org.omg.CORBA.TypeCode __typeCode = null;\n  private static boolean __active = false;\n  \n  // getting the typecode for the type\n  synchronized public static org.omg.CORBA.TypeCode type ()\n  {\n    if (__typeCode == null)\n    {\n      synchronized (org.omg.CORBA.TypeCode.class)\n      {\n        if (__typeCode == null)\n        {\n          if (__active)\n          {\n            return org.omg.CORBA.ORB.init().create_recursive_tc ( _id );\n          }\n          __active = true;\n          org.omg.CORBA.ValueMember[] _members0 = new org.omg.CORBA.ValueMember[0];\n          org.omg.CORBA.TypeCode _tcOf_members0 = null;\n          __typeCode = org.omg.CORBA.ORB.init ().create_value_tc (_id, \"Address\", org.omg.CORBA.VM_NONE.value, null, _members0);\n          __active = false;\n        }\n      }\n    }\n    return __typeCode;\n  }\n\n  // same as for non-value type\n  public static String id ()\n  {\n    return _id;\n  }\n\n  // reads a serializable instance of Address from the given input stream\n  public static Address read (org.omg.CORBA.portable.InputStream istream)\n  {\n    return (Address)((org.omg.CORBA_2_3.portable.InputStream) istream).read_value (id ());\n  }\n\n  // writes a serializable instance of Address to the given output stream\n  public static void write (org.omg.CORBA.portable.OutputStream ostream, Address value)\n  {\n    ((org.omg.CORBA_2_3.portable.OutputStream) ostream).write_value (value, id ());\n  }\n\n\n}\n",
        "Description": "Assuming that Address is a value type, the\nAddressHelper class will look like this:\n The Helper classes defined in the package org.omg.CORBA are:\n"
    },
    {
        "API": "org.omg.CORBA",
        "Code": "\n\u00a0\u00a0\u00a0\u00a0 AnySeqHelper\n\u00a0\u00a0\u00a0\u00a0 BooleanSeqHelper\n\u00a0\u00a0\u00a0\u00a0 CharSeqHelper\n\u00a0\u00a0\u00a0\u00a0 CompletionStatusHelper\n\u00a0\u00a0\u00a0\u00a0 CurrentHelper\n\u00a0\u00a0\u00a0\u00a0 DefinitionKindHelper\n\u00a0\u00a0\u00a0\u00a0 DoubleSeqHelper\n\u00a0\u00a0\u00a0\u00a0 FieldNameHelper\n\u00a0\u00a0\u00a0\u00a0 FloatSeqHelper\n\u00a0\u00a0\u00a0\u00a0 IdentifierHelper\n\u00a0\u00a0\u00a0\u00a0 IDLTypeHelper\n\u00a0\u00a0\u00a0\u00a0 LongLongSeqHelper\n\u00a0\u00a0\u00a0\u00a0 LongSeqHelper\n\u00a0\u00a0\u00a0\u00a0 NameValuePairHelper\n\u00a0\u00a0\u00a0\u00a0 ObjectHelper\n\u00a0\u00a0\u00a0\u00a0 OctetSeqHelper\n\u00a0\u00a0\u00a0\u00a0 ParameterModeHelper\n\u00a0\u00a0\u00a0\u00a0 PolicyErrorCodeHelper\n\u00a0\u00a0\u00a0\u00a0 PolicyErrorHelper\n\u00a0\u00a0\u00a0\u00a0 PolicyHelper\n\u00a0\u00a0\u00a0\u00a0 PolicyListHelper\n\u00a0\u00a0\u00a0\u00a0 PolicyTypeHelper\n\u00a0\u00a0\u00a0\u00a0 RepositoryIdHelper\n\u00a0\u00a0\u00a0\u00a0 ServiceDetailHelper\n\u00a0\u00a0\u00a0\u00a0 ServiceInformationHelper\n\u00a0\u00a0\u00a0\u00a0 SetOverrideTypeHelper\n\u00a0\u00a0\u00a0\u00a0 ShortSeqHelper\n\u00a0\u00a0\u00a0\u00a0 StringSeqHelper\n\u00a0\u00a0\u00a0\u00a0 StringValueHelper\n\u00a0\u00a0\u00a0\u00a0 StructMemberHelper\n\u00a0\u00a0\u00a0\u00a0 ULongLongSeqHelper\n\u00a0\u00a0\u00a0\u00a0 ULongSeqHelper\n\u00a0\u00a0\u00a0\u00a0 UnionMemberHelper\n\u00a0\u00a0\u00a0\u00a0 UnknownUserExceptionHelper\n\u00a0\u00a0\u00a0\u00a0 UShortSeqHelper\n\u00a0\u00a0\u00a0\u00a0 ValueBaseHelper\n\u00a0\u00a0\u00a0\u00a0 ValueMemberHelper\n\u00a0\u00a0\u00a0\u00a0 VersionSpecHelper\n\u00a0\u00a0\u00a0\u00a0 VisibilityHelper\n\u00a0\u00a0\u00a0\u00a0 WCharSeqHelper\n\u00a0\u00a0\u00a0\u00a0 WrongTransactionHelper\n\u00a0\u00a0\u00a0\u00a0 WStringSeqHelper\n\u00a0\u00a0\u00a0\u00a0 WStringValueHelper\n\n",
        "Description": "The Helper classes defined in the package org.omg.CORBA are:\n "
    },
    {
        "API": "org.omg.CORBA",
        "Code": "\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 BAD_CONTEXT\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 BAD_INV_ORDER\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 BAD_OPERATION\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 BAD_PARAM\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 BAD_TYPECODE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 COMM_FAILURE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DATA_CONVERSION\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 FREE_MEM\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 IMP_LIMIT\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 INITIALIZE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 INTERNAL\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 INTF_REPOS\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 INVALID_TRANSACTION\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 INV_FLAG\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 INV_IDENT\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 INV_OBJREF\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 INV_POLICY\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 MARSHAL\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 NO_IMPLEMENT\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 NO_MEMORY\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 NO_PERMISSION\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 NO_RESOURCES\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 NO_RESPONSE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 OBJECT_NOT_EXIST\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 OBJ_ADAPTER\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 PERSIST_STORE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 TRANSACTION_REQUIRED\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 TRANSACTION_ROLLEDBACK\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 TRANSIENT\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 UNKNOWN\n",
        "Description": "The following is a list of the system exceptions (which are unchecked\nexceptions inheriting through \norg.omg.CORBA.SystemException from\njava.lang.RuntimeException) that are defined in the package \norg.omg.CORBA:\n \nThe following is a list of user-defined exceptions defined in the package\norg.omg.CORBA.\n"
    },
    {
        "API": "org.omg.CORBA",
        "Code": "\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Bounds\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 UnknownUserException\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 WrongTransaction\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 PolicyError\n",
        "Description": "\nThe following is a list of user-defined exceptions defined in the package\norg.omg.CORBA.\n Subpackages"
    },
    {
        "API": "org.omg.CORBA",
        "Code": "\npublic final class AccountHolder implements \n    org.omg.CORBA.portable.Streamable\n{\n  // field that holds an Account object\n  public Account value = null;\n\n  // default constructor\n  public AccountHolder ()\n  {\n  }\n  \n  // creates a new AccountHolder from initialValue\n  public AccountHolder (Account initialValue)\n  {\n    value = initialValue;\n  }\n  \n  // reads the contents of i and assigns the contents to value\n  public void _read (org.omg.CORBA.portable.InputStream i)\n  {\n    value = AccountHelper.read (i);\n  }\n\n  // writes value to o\n  public void _write (org.omg.CORBA.portable.OutputStream o)\n  {\n    AccountHelper.write (o, value);\n  }\n \n  // returns the typecode for Account\n  public org.omg.CORBA.TypeCode _type ()\n  {\n    return AccountHelper.type ();\n  }\n\n}\n",
        "Description": "\nAs an example, if the interface Account, defined in OMG IDL,\nwere mapped to the Java programming language, the following holder class\nwould be generated:\n For more information on Holder classes, see Chapter 1.4, Mapping for\nBasic Types in the \nOMG IDL to Java Language Mapping. The Holder classes defined \nin the package org.omg.CORBA are:\n"
    },
    {
        "API": "org.omg.CORBA",
        "Code": "\n\u00a0\u00a0\u00a0\u00a0 AnyHolder\n\u00a0\u00a0\u00a0\u00a0 AnySeqHolder\n\u00a0\u00a0\u00a0\u00a0 BooleanHolder\n\u00a0\u00a0\u00a0\u00a0 BooleanSeqHolder\n\u00a0\u00a0\u00a0\u00a0 ByteHolder\n\u00a0\u00a0\u00a0\u00a0 CharHolder\n\u00a0\u00a0\u00a0\u00a0 CharSeqHolder\n\u00a0\u00a0\u00a0\u00a0 CurrentHolder\n\u00a0\u00a0\u00a0\u00a0 DoubleHolder\n\u00a0\u00a0\u00a0\u00a0 DoubleSeqHolder\n\u00a0\u00a0\u00a0\u00a0 FixedHolder\n\u00a0\u00a0\u00a0\u00a0 FloatHolder\n\u00a0\u00a0\u00a0\u00a0 FloatSeqHolder\n\u00a0\u00a0\u00a0\u00a0 IntHolder\n\u00a0\u00a0\u00a0\u00a0 LongHolder\n\u00a0\u00a0\u00a0\u00a0 LongLongSeqHolder\n\u00a0\u00a0\u00a0\u00a0 LongSeqHolder\n\u00a0\u00a0\u00a0\u00a0 ObjectHolder\n\u00a0\u00a0\u00a0\u00a0 OctetSeqHolder\n\u00a0\u00a0\u00a0\u00a0 ParameterModeHolder\n\u00a0\u00a0\u00a0\u00a0 PolicyErrorHolder\n\u00a0\u00a0\u00a0\u00a0 PolicyListHolder\n\u00a0\u00a0\u00a0\u00a0 PrincipalHolder\n\u00a0\u00a0\u00a0\u00a0 ServiceInformationHolder\n\u00a0\u00a0\u00a0\u00a0 ShortHolder\n\u00a0\u00a0\u00a0\u00a0 ShortSeqHolder\n\u00a0\u00a0\u00a0\u00a0 StringHolder\n\u00a0\u00a0\u00a0\u00a0 StringSeqHolder\n\u00a0\u00a0\u00a0\u00a0 TypeCodeHolder\n\u00a0\u00a0\u00a0\u00a0 ULongLongSeqHolder\n\u00a0\u00a0\u00a0\u00a0 ULongSeqHolder\n\u00a0\u00a0\u00a0\u00a0 UnknownUserExceptionHolder\n\u00a0\u00a0\u00a0\u00a0 UShortSeqHolder\n\u00a0\u00a0\u00a0\u00a0 ValueBaseHolder\n\u00a0\u00a0\u00a0\u00a0 WCharSeqHolder\n\u00a0\u00a0\u00a0\u00a0 WrongTransactionHolder\n\u00a0\u00a0\u00a0\u00a0 WStringSeqHolder\n\n",
        "Description": "For more information on Holder classes, see Chapter 1.4, Mapping for\nBasic Types in the \nOMG IDL to Java Language Mapping. The Holder classes defined \nin the package org.omg.CORBA are:\n Helper Classes "
    },
    {
        "API": "org.omg.CORBA",
        "Code": "\n        // create and initialize the ORB\n        ORB orb = ORB.init(args, null);\n\n        // get the root naming context\n        org.omg.CORBA.Object objRef = \n            orb.resolve_initial_references(\"NameService\");\n        // Use NamingContextExt instead of NamingContext. This is \n        // part of latest Inter-Operable naming Service.  \n        NamingContextExt ncRef = NamingContextExtHelper.narrow(objRef);\n \n        // resolve the Object Reference in Naming\n        String name = \"Hello\";\n        helloImpl = HelloHelper.narrow(ncRef.resolve_str(name));\n",
        "Description": "\n "
    },
    {
        "API": "org.omg.CORBA",
        "Code": "\nabstract public class AccountHelper\n{\n  private static String  _id = \"IDL:Account:1.0\";\n\n  // inserts an Account object into an Any object\n  public static void insert (org.omg.CORBA.Any a, Account that)\n  {\n    org.omg.CORBA.portable.OutputStream out = a.create_output_stream ();\n    a.type (type ());\n    write (out, that);\n    a.read_value (out.create_input_stream (), type ());\n  }\n\n  // extracts an Account object from an Any object\n  public static Account extract (org.omg.CORBA.Any a)\n  {\n    return read (a.create_input_stream ());\n  }\n\n  \n  private static org.omg.CORBA.TypeCode __typeCode = null;\n  // gets the typecode for this type\n  synchronized public static org.omg.CORBA.TypeCode type ()\n  {\n    if (__typeCode == null)\n    {\n      __typeCode = org.omg.CORBA.ORB.init ().create_interface_tc (AccountHelper.id (), \"Account\");\n    }\n    return __typeCode;\n  }\n\n  // gets the repository id for this type\n  public static String id ()\n  {\n    return _id;\n  }\n\n  // reads an Account object from an input stream\n  public static Account read (org.omg.CORBA.portable.InputStream istream)\n  {\n    return narrow (istream.read_Object (_AccountStub.class));\n  }\n\n  // writes an Account object to an outputstream\n  public static void write (org.omg.CORBA.portable.OutputStream ostream, Account value)\n  {\n    ostream.write_Object ((org.omg.CORBA.Object) value);\n  }\n\n  // converts (narrows) an Object to an Account object\n  public static Account narrow (org.omg.CORBA.Object obj)\n  {\n    if (obj == null)\n      return null;\n    else if (obj instanceof Account)\n      return (Account)obj;\n    else if (!obj._is_a (id ()))\n      throw new org.omg.CORBA.BAD_PARAM ();\n    else\n    {\n      org.omg.CORBA.portable.Delegate delegate = ((org.omg.CORBA.portable.ObjectImpl)obj)._get_delegate ();\n      _AccountStub stub = new _AccountStub ();\n      stub._set_delegate(delegate);\n      return stub;\n    }\n  }\n\n}\n",
        "Description": "\nFor example, assuming that the interface Account is not a\nvalue type IDL type and is also not an abstract interface and has no\nabstract base interfaces, its AccountHelper class will look\nlike this:\n \n"
    },
    {
        "API": "org.omg.CORBA",
        "Code": "\nabstract public class AddressHelper\n{\n  private static String  _id = \"IDL:Address:1.0\";\n\n  // same as for non-value type\n  public static void insert (org.omg.CORBA.Any a, Address that)\n  {\n    org.omg.CORBA.portable.OutputStream out = a.create_output_stream ();\n    a.type (type ());\n    write (out, that);\n    a.read_value (out.create_input_stream (), type ());\n  }\n\n  // same as for non-value type\n  public static Address extract (org.omg.CORBA.Any a)\n  {\n    return read (a.create_input_stream ());\n  }\n\n  private static org.omg.CORBA.TypeCode __typeCode = null;\n  private static boolean __active = false;\n  \n  // getting the typecode for the type\n  synchronized public static org.omg.CORBA.TypeCode type ()\n  {\n    if (__typeCode == null)\n    {\n      synchronized (org.omg.CORBA.TypeCode.class)\n      {\n        if (__typeCode == null)\n        {\n          if (__active)\n          {\n            return org.omg.CORBA.ORB.init().create_recursive_tc ( _id );\n          }\n          __active = true;\n          org.omg.CORBA.ValueMember[] _members0 = new org.omg.CORBA.ValueMember[0];\n          org.omg.CORBA.TypeCode _tcOf_members0 = null;\n          __typeCode = org.omg.CORBA.ORB.init ().create_value_tc (_id, \"Address\", org.omg.CORBA.VM_NONE.value, null, _members0);\n          __active = false;\n        }\n      }\n    }\n    return __typeCode;\n  }\n\n  // same as for non-value type\n  public static String id ()\n  {\n    return _id;\n  }\n\n  // reads a serializable instance of Address from the given input stream\n  public static Address read (org.omg.CORBA.portable.InputStream istream)\n  {\n    return (Address)((org.omg.CORBA_2_3.portable.InputStream) istream).read_value (id ());\n  }\n\n  // writes a serializable instance of Address to the given output stream\n  public static void write (org.omg.CORBA.portable.OutputStream ostream, Address value)\n  {\n    ((org.omg.CORBA_2_3.portable.OutputStream) ostream).write_value (value, id ());\n  }\n\n\n}\n",
        "Description": "Assuming that Address is a value type, the\nAddressHelper class will look like this:\n The Helper classes defined in the package org.omg.CORBA are:\n"
    },
    {
        "API": "org.omg.CORBA",
        "Code": "\n\u00a0\u00a0\u00a0\u00a0 AnySeqHelper\n\u00a0\u00a0\u00a0\u00a0 BooleanSeqHelper\n\u00a0\u00a0\u00a0\u00a0 CharSeqHelper\n\u00a0\u00a0\u00a0\u00a0 CompletionStatusHelper\n\u00a0\u00a0\u00a0\u00a0 CurrentHelper\n\u00a0\u00a0\u00a0\u00a0 DefinitionKindHelper\n\u00a0\u00a0\u00a0\u00a0 DoubleSeqHelper\n\u00a0\u00a0\u00a0\u00a0 FieldNameHelper\n\u00a0\u00a0\u00a0\u00a0 FloatSeqHelper\n\u00a0\u00a0\u00a0\u00a0 IdentifierHelper\n\u00a0\u00a0\u00a0\u00a0 IDLTypeHelper\n\u00a0\u00a0\u00a0\u00a0 LongLongSeqHelper\n\u00a0\u00a0\u00a0\u00a0 LongSeqHelper\n\u00a0\u00a0\u00a0\u00a0 NameValuePairHelper\n\u00a0\u00a0\u00a0\u00a0 ObjectHelper\n\u00a0\u00a0\u00a0\u00a0 OctetSeqHelper\n\u00a0\u00a0\u00a0\u00a0 ParameterModeHelper\n\u00a0\u00a0\u00a0\u00a0 PolicyErrorCodeHelper\n\u00a0\u00a0\u00a0\u00a0 PolicyErrorHelper\n\u00a0\u00a0\u00a0\u00a0 PolicyHelper\n\u00a0\u00a0\u00a0\u00a0 PolicyListHelper\n\u00a0\u00a0\u00a0\u00a0 PolicyTypeHelper\n\u00a0\u00a0\u00a0\u00a0 RepositoryIdHelper\n\u00a0\u00a0\u00a0\u00a0 ServiceDetailHelper\n\u00a0\u00a0\u00a0\u00a0 ServiceInformationHelper\n\u00a0\u00a0\u00a0\u00a0 SetOverrideTypeHelper\n\u00a0\u00a0\u00a0\u00a0 ShortSeqHelper\n\u00a0\u00a0\u00a0\u00a0 StringSeqHelper\n\u00a0\u00a0\u00a0\u00a0 StringValueHelper\n\u00a0\u00a0\u00a0\u00a0 StructMemberHelper\n\u00a0\u00a0\u00a0\u00a0 ULongLongSeqHelper\n\u00a0\u00a0\u00a0\u00a0 ULongSeqHelper\n\u00a0\u00a0\u00a0\u00a0 UnionMemberHelper\n\u00a0\u00a0\u00a0\u00a0 UnknownUserExceptionHelper\n\u00a0\u00a0\u00a0\u00a0 UShortSeqHelper\n\u00a0\u00a0\u00a0\u00a0 ValueBaseHelper\n\u00a0\u00a0\u00a0\u00a0 ValueMemberHelper\n\u00a0\u00a0\u00a0\u00a0 VersionSpecHelper\n\u00a0\u00a0\u00a0\u00a0 VisibilityHelper\n\u00a0\u00a0\u00a0\u00a0 WCharSeqHelper\n\u00a0\u00a0\u00a0\u00a0 WrongTransactionHelper\n\u00a0\u00a0\u00a0\u00a0 WStringSeqHelper\n\u00a0\u00a0\u00a0\u00a0 WStringValueHelper\n\n",
        "Description": "The Helper classes defined in the package org.omg.CORBA are:\n "
    },
    {
        "API": "java.awt.AWTEventMulticaster",
        "Code": "\n public myComponent extends Component {\n     ActionListener actionListener = null;\n\n     public synchronized void addActionListener(ActionListener l) {\n         actionListener = AWTEventMulticaster.add(actionListener, l);\n     }\n     public synchronized void removeActionListener(ActionListener l) {\n         actionListener = AWTEventMulticaster.remove(actionListener, l);\n     }\n     public void processEvent(AWTEvent e) {\n         // when event occurs which causes \"action\" semantic\n         ActionListener listener = actionListener;\n         if (listener != null) {\n             listener.actionPerformed(new ActionEvent());\n         }\n     }\n }\n ",
        "Description": "\n The following example illustrates how to use this class:\n\n  add"
    },
    {
        "API": "java.awt.GraphicsConfiguration",
        "Code": "\n      Frame f = new Frame(gc);  // where gc is a GraphicsConfiguration\n      Rectangle bounds = gc.getBounds();\n      f.setLocation(10 + bounds.x, 10 + bounds.y); ",
        "Description": "\n In a virtual device multi-screen environment in which the desktop\n area could span multiple physical screen devices, the bounds of the\n GraphicsConfiguration objects are relative to the\n virtual coordinate system.  When setting the location of a\n component, use getBounds to get the bounds of\n the desired GraphicsConfiguration and offset the location\n with the coordinates of the GraphicsConfiguration,\n as the following code sample illustrates:\n  \n To determine if your environment is a virtual device\n environment, call getBounds on all of the\n GraphicsConfiguration objects in your system.  If\n any of the origins of the returned bounds is not (0,\u00a00),\n your environment is a virtual device environment.\n\n "
    },
    {
        "API": "java.awt.GraphicsConfiguration",
        "Code": "\n      Rectangle virtualBounds = new Rectangle();\n      GraphicsEnvironment ge = GraphicsEnvironment.\n              getLocalGraphicsEnvironment();\n      GraphicsDevice[] gs =\n              ge.getScreenDevices();\n      for (int j = 0; j < gs.length; j++) {\n          GraphicsDevice gd = gs[j];\n          GraphicsConfiguration[] gc =\n              gd.getConfigurations();\n          for (int i=0; i < gc.length; i++) {\n              virtualBounds =\n                  virtualBounds.union(gc[i].getBounds());\n          }\n      } ",
        "Description": "\n You can also use getBounds to determine the bounds\n of the virtual device.  To do this, first call getBounds on all\n of the GraphicsConfiguration objects in your\n system.  Then calculate the union of all of the bounds returned\n from the calls to getBounds.  The union is the\n bounds of the virtual device.  The following code sample\n calculates the bounds of the virtual device.\n\n  "
    },
    {
        "API": "java.awt.GraphicsDevice",
        "Code": "\n   GraphicsEnvironment ge = GraphicsEnvironment.\n   getLocalGraphicsEnvironment();\n   GraphicsDevice[] gs = ge.getScreenDevices();\n   for (int j = 0; j < gs.length; j++) {\n      GraphicsDevice gd = gs[j];\n      GraphicsConfiguration[] gc =\n      gd.getConfigurations();\n      for (int i=0; i < gc.length; i++) {\n         JFrame f = new\n         JFrame(gs[j].getDefaultConfiguration());\n         Canvas c = new Canvas(gc[i]);\n         Rectangle gcBounds = gc[i].getBounds();\n         int xoffs = gcBounds.x;\n         int yoffs = gcBounds.y;\n         f.getContentPane().add(c);\n         f.setLocation((i*50)+xoffs, (i*60)+yoffs);\n         f.show();\n      }\n   }\n ",
        "Description": "\n In a multi-screen environment, the GraphicsConfiguration\n objects can be used to render components on multiple screens.  The\n following code sample demonstrates how to create a JFrame\n object for each GraphicsConfiguration on each screen\n device in the GraphicsEnvironment:\n  \n For more information on full-screen exclusive mode API, see the\n \n Full-Screen Exclusive Mode API Tutorial."
    },
    {
        "API": "java.awt.MediaTracker",
        "Code": "\n import java.applet.Applet;\n import java.awt.Color;\n import java.awt.Image;\n import java.awt.Graphics;\n import java.awt.MediaTracker;\n\n public class ImageBlaster extends Applet implements Runnable {\n      MediaTracker tracker;\n      Image bg;\n      Image anim[] = new Image[5];\n      int index;\n      Thread animator;\n\n      // Get the images for the background (id == 0)\n      // and the animation frames (id == 1)\n      // and add them to the MediaTracker\n      public void init() {\n          tracker = new MediaTracker(this);\n          bg = getImage(getDocumentBase(),\n                  \"images/background.gif\");\n          tracker.addImage(bg, 0);\n          for (int i = 0; i < 5; i++) {\n              anim[i] = getImage(getDocumentBase(),\n                      \"images/anim\"+i+\".gif\");\n              tracker.addImage(anim[i], 1);\n          }\n      }\n\n      // Start the animation thread.\n      public void start() {\n          animator = new Thread(this);\n          animator.start();\n      }\n\n      // Stop the animation thread.\n      public void stop() {\n          animator = null;\n      }\n\n      // Run the animation thread.\n      // First wait for the background image to fully load\n      // and paint.  Then wait for all of the animation\n      // frames to finish loading. Finally, loop and\n      // increment the animation frame index.\n      public void run() {\n          try {\n              tracker.waitForID(0);\n              tracker.waitForID(1);\n          } catch (InterruptedException e) {\n              return;\n          }\n          Thread me = Thread.currentThread();\n          while (animator == me) {\n              try {\n                  Thread.sleep(100);\n              } catch (InterruptedException e) {\n                  break;\n              }\n              synchronized (this) {\n                  index++;\n                  if (index >= anim.length) {\n                      index = 0;\n                  }\n              }\n              repaint();\n          }\n      }\n\n      // The background image fills the frame so we\n      // don't need to clear the applet on repaints.\n      // Just call the paint method.\n      public void update(Graphics g) {\n          paint(g);\n      }\n\n      // Paint a large red rectangle if there are any errors\n      // loading the images.  Otherwise always paint the\n      // background so that it appears incrementally as it\n      // is loading.  Finally, only paint the current animation\n      // frame if all of the frames (id == 1) are done loading,\n      // so that we don't get partial animations.\n      public void paint(Graphics g) {\n          if ((tracker.statusAll(false) & MediaTracker.ERRORED) != 0) {\n              g.setColor(Color.red);\n              g.fillRect(0, 0, size().width, size().height);\n              return;\n          }\n          g.drawImage(bg, 0, 0, this);\n          if (tracker.statusID(1, false) == MediaTracker.COMPLETE) {\n              g.drawImage(anim[index], 10, 10, this);\n          }\n      }\n }\n  ",
        "Description": " "
    },
    {
        "API": "java.awt.Rectangle",
        "Code": "\n     Rectangle bounds = new Rectangle(0, 0, -1, -1);\n     for (int i = 0; i < points.length; i++) {\n         bounds.add(points[i]);\n     }\n ",
        "Description": "\n Note that a Rectangle constructed with the default no-argument\n constructor will have dimensions of 0x0 and therefore be empty.\n That Rectangle will still have a location of (0,0) and\n will contribute that location to the union and add operations.\n Code attempting to accumulate the bounds of a set of points should\n therefore initially construct the Rectangle with a specifically\n negative width and height or it should use the first point in the set\n to construct the Rectangle.\n For example:\n  \n     Rectangle bounds = new Rectangle(points[0]);\n     for (int i = 1; i < points.length; i++) {\n         bounds.add(points[i]);\n     }\n "
    },
    {
        "API": "java.awt.Rectangle",
        "Code": "\n     Rectangle bounds = new Rectangle(points[0]);\n     for (int i = 1; i < points.length; i++) {\n         bounds.add(points[i]);\n     }\n ",
        "Description": "\n     Rectangle bounds = new Rectangle(0, 0, -1, -1);\n     for (int i = 0; i < points.length; i++) {\n         bounds.add(points[i]);\n     }\n  \n This class uses 32-bit integers to store its location and dimensions.\n Frequently operations may produce a result that exceeds the range of\n a 32-bit integer.\n The methods will calculate their results in a way that avoids any\n 32-bit overflow for intermediate results and then choose the best\n representation to store the final results back into the 32-bit fields\n which hold the location and dimensions.\n The location of the result will be stored into the x and\n y fields by clipping the true result to the nearest 32-bit value.\n The values stored into the width and height dimension\n fields will be chosen as the 32-bit values that encompass the largest\n part of the true result as possible.\n Generally this means that the dimension will be clipped independently\n to the range of 32-bit integers except that if the location had to be\n moved to store it into its pair of 32-bit fields then the dimensions\n will be adjusted relative to the \"best representation\" of the location.\n If the true result had a negative dimension and was therefore\n non-existant along one or both axes, the stored dimensions will be\n negative numbers in those axes.\n If the true result had a location that could be represented within\n the range of 32-bit integers, but zero dimension along one or both\n axes, then the stored dimensions will be zero in those axes."
    },
    {
        "API": "java.awt.font.LineBreakMeasurer",
        "Code": "\n public void paint(Graphics graphics) {\n\n     Point2D pen = new Point2D(10, 20);\n     Graphics2D g2d = (Graphics2D)graphics;\n     FontRenderContext frc = g2d.getFontRenderContext();\n\n     // let styledText be an AttributedCharacterIterator containing at least\n     // one character\n\n     LineBreakMeasurer measurer = new LineBreakMeasurer(styledText, frc);\n     float wrappingWidth = getSize().width - 15;\n\n     while (measurer.getPosition() < fStyledText.length()) {\n\n         TextLayout layout = measurer.nextLayout(wrappingWidth);\n\n         pen.y += (layout.getAscent());\n         float dx = layout.isLeftToRight() ?\n             0 : (wrappingWidth - layout.getAdvance());\n\n         layout.draw(graphics, pen.x + dx, pen.y);\n         pen.y += layout.getDescent() + layout.getLeading();\n     }\n }\n ",
        "Description": " "
    },
    {
        "API": "java.awt.font.LineBreakMeasurer",
        "Code": "\n public void paint(Graphics graphics) {\n\n     float leftMargin = 10, rightMargin = 310;\n     float[] tabStops = { 100, 250 };\n\n     // assume styledText is an AttributedCharacterIterator, and the number\n     // of tabs in styledText is tabCount\n\n     int[] tabLocations = new int[tabCount+1];\n\n     int i = 0;\n     for (char c = styledText.first(); c != styledText.DONE; c = styledText.next()) {\n         if (c == '\\t') {\n             tabLocations[i++] = styledText.getIndex();\n         }\n     }\n     tabLocations[tabCount] = styledText.getEndIndex() - 1;\n\n     // Now tabLocations has an entry for every tab's offset in\n     // the text.  For convenience, the last entry is tabLocations\n     // is the offset of the last character in the text.\n\n     LineBreakMeasurer measurer = new LineBreakMeasurer(styledText);\n     int currentTab = 0;\n     float verticalPos = 20;\n\n     while (measurer.getPosition() < styledText.getEndIndex()) {\n\n         // Lay out and draw each line.  All segments on a line\n         // must be computed before any drawing can occur, since\n         // we must know the largest ascent on the line.\n         // TextLayouts are computed and stored in a Vector;\n         // their horizontal positions are stored in a parallel\n         // Vector.\n\n         // lineContainsText is true after first segment is drawn\n         boolean lineContainsText = false;\n         boolean lineComplete = false;\n         float maxAscent = 0, maxDescent = 0;\n         float horizontalPos = leftMargin;\n         Vector layouts = new Vector(1);\n         Vector penPositions = new Vector(1);\n\n         while (!lineComplete) {\n             float wrappingWidth = rightMargin - horizontalPos;\n             TextLayout layout =\n                     measurer.nextLayout(wrappingWidth,\n                                         tabLocations[currentTab]+1,\n                                         lineContainsText);\n\n             // layout can be null if lineContainsText is true\n             if (layout != null) {\n                 layouts.addElement(layout);\n                 penPositions.addElement(new Float(horizontalPos));\n                 horizontalPos += layout.getAdvance();\n                 maxAscent = Math.max(maxAscent, layout.getAscent());\n                 maxDescent = Math.max(maxDescent,\n                     layout.getDescent() + layout.getLeading());\n             } else {\n                 lineComplete = true;\n             }\n\n             lineContainsText = true;\n\n             if (measurer.getPosition() == tabLocations[currentTab]+1) {\n                 currentTab++;\n             }\n\n             if (measurer.getPosition() == styledText.getEndIndex())\n                 lineComplete = true;\n             else if (horizontalPos >= tabStops[tabStops.length-1])\n                 lineComplete = true;\n\n             if (!lineComplete) {\n                 // move to next tab stop\n                 int j;\n                 for (j=0; horizontalPos >= tabStops[j]; j++) {}\n                 horizontalPos = tabStops[j];\n             }\n         }\n\n         verticalPos += maxAscent;\n\n         Enumeration layoutEnum = layouts.elements();\n         Enumeration positionEnum = penPositions.elements();\n\n         // now iterate through layouts and draw them\n         while (layoutEnum.hasMoreElements()) {\n             TextLayout nextLayout = (TextLayout) layoutEnum.nextElement();\n             Float nextPosition = (Float) positionEnum.nextElement();\n             nextLayout.draw(graphics, nextPosition.floatValue(), verticalPos);\n         }\n\n         verticalPos += maxDescent;\n     }\n }\n ",
        "Description": " "
    },
    {
        "API": "java.awt.image.BufferStrategy",
        "Code": "\n Double buffering:\n\n                    ***********         ***********\n                    *         * ------> *         *\n [To display] <---- * Front B *   Show  * Back B. * <---- Rendering\n                    *         * <------ *         *\n                    ***********         ***********\n\n Triple buffering:\n\n [To      ***********         ***********        ***********\n display] *         * --------+---------+------> *         *\n    <---- * Front B *   Show  * Mid. B. *        * Back B. * <---- Rendering\n          *         * <------ *         * <----- *         *\n          ***********         ***********        ***********\n\n ",
        "Description": "\n Alternatively, the contents of the back buffer can be copied, or\n blitted forward in a chain instead of moving the video pointer.\n  \n Here is an example of how buffer strategies can be created and used:\n "
    },
    {
        "API": "java.awt.image.BufferStrategy",
        "Code": "\n\n // Check the capabilities of the GraphicsConfiguration\n ...\n\n // Create our component\n Window w = new Window(gc);\n\n // Show our window\n w.setVisible(true);\n\n // Create a general double-buffering strategy\n w.createBufferStrategy(2);\n BufferStrategy strategy = w.getBufferStrategy();\n\n // Main loop\n while (!done) {\n     // Prepare for rendering the next frame\n     // ...\n\n     // Render single frame\n     do {\n         // The following loop ensures that the contents of the drawing buffer\n         // are consistent in case the underlying surface was recreated\n         do {\n             // Get a new graphics context every time through the loop\n             // to make sure the strategy is validated\n             Graphics graphics = strategy.getDrawGraphics();\n\n             // Render to graphics\n             // ...\n\n             // Dispose the graphics\n             graphics.dispose();\n\n             // Repeat the rendering if the drawing buffer contents\n             // were restored\n         } while (strategy.contentsRestored());\n\n         // Display the buffer\n         strategy.show();\n\n         // Repeat the rendering if the drawing buffer was lost\n     } while (strategy.contentsLost());\n }\n\n // Dispose the window\n w.setVisible(false);\n w.dispose();\n ",
        "Description": "\n Here is an example of how buffer strategies can be created and used:\n  "
    },
    {
        "API": "java.awt.image.MemoryImageSource",
        "Code": "\n\n      int w = 100;\n      int h = 100;\n      int pix[] = new int[w * h];\n      int index = 0;\n      for (int y = 0; y < h; y++) {\n          int red = (y * 255) / (h - 1);\n          for (int x = 0; x < w; x++) {\n              int blue = (x * 255) / (w - 1);\n              pix[index++] = (255 << 24) | (red << 16) | blue;\n          }\n      }\n      Image img = createImage(new MemoryImageSource(w, h, pix, 0, w));\n\n ",
        "Description": " \n\n      int pixels[];\n      MemoryImageSource source;\n\n      public void init() {\n          int width = 50;\n          int height = 50;\n          int size = width * height;\n          pixels = new int[size];\n\n          int value = getBackground().getRGB();\n          for (int i = 0; i < size; i++) {\n              pixels[i] = value;\n          }\n\n          source = new MemoryImageSource(width, height, pixels, 0, width);\n          source.setAnimated(true);\n          image = createImage(source);\n      }\n\n      public void run() {\n          Thread me = Thread.currentThread( );\n          me.setPriority(Thread.MIN_PRIORITY);\n\n          while (true) {\n              try {\n                  Thread.sleep(10);\n              } catch( InterruptedException e ) {\n                  return;\n              }\n\n              // Modify the values in the pixels array at (x, y, w, h)\n\n              // Send the new data to the interested ImageConsumers\n              source.newPixels(x, y, w, h);\n          }\n      }\n\n "
    },
    {
        "API": "java.awt.image.MemoryImageSource",
        "Code": "\n\n      int pixels[];\n      MemoryImageSource source;\n\n      public void init() {\n          int width = 50;\n          int height = 50;\n          int size = width * height;\n          pixels = new int[size];\n\n          int value = getBackground().getRGB();\n          for (int i = 0; i < size; i++) {\n              pixels[i] = value;\n          }\n\n          source = new MemoryImageSource(width, height, pixels, 0, width);\n          source.setAnimated(true);\n          image = createImage(source);\n      }\n\n      public void run() {\n          Thread me = Thread.currentThread( );\n          me.setPriority(Thread.MIN_PRIORITY);\n\n          while (true) {\n              try {\n                  Thread.sleep(10);\n              } catch( InterruptedException e ) {\n                  return;\n              }\n\n              // Modify the values in the pixels array at (x, y, w, h)\n\n              // Send the new data to the interested ImageConsumers\n              source.newPixels(x, y, w, h);\n          }\n      }\n\n ",
        "Description": "\n\n      int w = 100;\n      int h = 100;\n      int pix[] = new int[w * h];\n      int index = 0;\n      for (int y = 0; y < h; y++) {\n          int red = (y * 255) / (h - 1);\n          for (int x = 0; x < w; x++) {\n              int blue = (x * 255) / (w - 1);\n              pix[index++] = (255 << 24) | (red << 16) | blue;\n          }\n      }\n      Image img = createImage(new MemoryImageSource(w, h, pix, 0, w));\n\n  "
    },
    {
        "API": "java.awt.image.MultiPixelPackedSampleModel",
        "Code": "\n      int dataElementSize = DataBuffer.getDataTypeSize(dataType);\n      int bitnum = dataBitOffset + x*pixelBitStride;\n      int element = data.getElem(y*scanlineStride + bitnum/dataElementSize);\n      int shift = dataElementSize - (bitnum & (dataElementSize-1))\n                  - pixelBitStride;\n      int pixel = (element >> shift) & ((1 << pixelBitStride) - 1);\n ",
        "Description": "\n The following code illustrates extracting the bits for pixel\n x,\u00a0y from DataBuffer data\n and storing the pixel data in data elements of type\n dataType:\n  "
    },
    {
        "API": "java.awt.image.PixelGrabber",
        "Code": "\n\n public void handlesinglepixel(int x, int y, int pixel) {\n      int alpha = (pixel >> 24) & 0xff;\n      int red   = (pixel >> 16) & 0xff;\n      int green = (pixel >>  8) & 0xff;\n      int blue  = (pixel      ) & 0xff;\n      // Deal with the pixel as necessary...\n }\n\n public void handlepixels(Image img, int x, int y, int w, int h) {\n      int[] pixels = new int[w * h];\n      PixelGrabber pg = new PixelGrabber(img, x, y, w, h, pixels, 0, w);\n      try {\n          pg.grabPixels();\n      } catch (InterruptedException e) {\n          System.err.println(\"interrupted waiting for pixels!\");\n          return;\n      }\n      if ((pg.getStatus() & ImageObserver.ABORT) != 0) {\n          System.err.println(\"image fetch aborted or errored\");\n          return;\n      }\n      for (int j = 0; j < h; j++) {\n          for (int i = 0; i < w; i++) {\n              handlesinglepixel(x+i, y+j, pixels[j * w + i]);\n          }\n      }\n }\n\n ",
        "Description": " "
    },
    {
        "API": "java.awt.image.RGBImageFilter",
        "Code": "\n\n      class RedBlueSwapFilter extends RGBImageFilter {\n          public RedBlueSwapFilter() {\n              // The filter's operation does not depend on the\n              // pixel's location, so IndexColorModels can be\n              // filtered directly.\n              canFilterIndexColorModel = true;\n          }\n\n          public int filterRGB(int x, int y, int rgb) {\n              return ((rgb & 0xff00ff00)\n                      | ((rgb & 0xff0000) >> 16)\n                      | ((rgb & 0xff) << 16));\n          }\n      }\n\n ",
        "Description": " "
    },
    {
        "API": "java.awt.image.SinglePixelPackedSampleModel",
        "Code": "\n      int sample = data.getElem(y * scanlineStride + x);\n      sample = (sample & bitMasks[b]) >>> bitOffsets[b];\n ",
        "Description": "\n The following code illustrates extracting the bits of the sample\n representing band b for pixel x,y\n from DataBuffer data:\n  "
    },
    {
        "API": "java.beans.VetoableChangeSupport",
        "Code": "\n public class MyBean {\n     private final VetoableChangeSupport vcs = new VetoableChangeSupport(this);\n\n     public void addVetoableChangeListener(VetoableChangeListener listener) {\n         this.vcs.addVetoableChangeListener(listener);\n     }\n\n     public void removeVetoableChangeListener(VetoableChangeListener listener) {\n         this.vcs.removeVetoableChangeListener(listener);\n     }\n\n     private String value;\n\n     public String getValue() {\n         return this.value;\n     }\n\n     public void setValue(String newValue) throws PropertyVetoException {\n         String oldValue = this.value;\n         this.vcs.fireVetoableChange(\"value\", oldValue, newValue);\n         this.value = newValue;\n     }\n\n     [...]\n }\n ",
        "Description": "\n Here is an example of VetoableChangeSupport usage that follows\n the rules and recommendations laid out in the JavaBeans\u2122 specification:\n  \n A VetoableChangeSupport instance is thread-safe.\n "
    },
    {
        "API": "java.io.Console",
        "Code": "\n Console cons;\n char[] passwd;\n if ((cons = System.console()) != null &&\n     (passwd = cons.readPassword(\"[%s]\", \"Password:\")) != null) {\n     ...\n     java.util.Arrays.fill(passwd, ' ');\n }\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.CallSite",
        "Code": "\nstatic void test() throws Throwable {\n    // THE FOLLOWING LINE IS PSEUDOCODE FOR A JVM INSTRUCTION\n    InvokeDynamic[#bootstrapDynamic].baz(\"baz arg\", 2, 3.14);\n}\nprivate static void printArgs(Object... args) {\n  System.out.println(java.util.Arrays.deepToString(args));\n}\nprivate static final MethodHandle printArgs;\nstatic {\n  MethodHandles.Lookup lookup = MethodHandles.lookup();\n  Class thisClass = lookup.lookupClass();  // (who am I?)\n  printArgs = lookup.findStatic(thisClass,\n      \"printArgs\", MethodType.methodType(void.class, Object[].class));\n}\nprivate static CallSite bootstrapDynamic(MethodHandles.Lookup caller, String name, MethodType type) {\n  // ignore caller and name, but match the type:\n  return new ConstantCallSite(printArgs.asType(type));\n}\n",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandle",
        "Code": "\nObject x, y; String s; int i;\nMethodType mt; MethodHandle mh;\nMethodHandles.Lookup lookup = MethodHandles.lookup();\n// mt is (char,char)String\nmt = MethodType.methodType(String.class, char.class, char.class);\nmh = lookup.findVirtual(String.class, \"replace\", mt);\ns = (String) mh.invokeExact(\"daddy\",'d','n');\n// invokeExact(Ljava/lang/String;CC)Ljava/lang/String;\nassertEquals(s, \"nanny\");\n// weakly typed invocation (using MHs.invoke)\ns = (String) mh.invokeWithArguments(\"sappy\", 'p', 'v');\nassertEquals(s, \"savvy\");\n// mt is (Object[])List\nmt = MethodType.methodType(java.util.List.class, Object[].class);\nmh = lookup.findStatic(java.util.Arrays.class, \"asList\", mt);\nassert(mh.isVarargsCollector());\nx = mh.invoke(\"one\", \"two\");\n// invoke(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;\nassertEquals(x, java.util.Arrays.asList(\"one\",\"two\"));\n// mt is (Object,Object,Object)Object\nmt = MethodType.genericMethodType(3);\nmh = mh.asType(mt);\nx = mh.invokeExact((Object)1, (Object)2, (Object)3);\n// invokeExact(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\nassertEquals(x, java.util.Arrays.asList(1,2,3));\n// mt is ()int\nmt = MethodType.methodType(int.class);\nmh = lookup.findVirtual(java.util.List.class, \"size\", mt);\ni = (int) mh.invokeExact(java.util.Arrays.asList(1,2,3));\n// invokeExact(Ljava/util/List;)I\nassert(i == 3);\nmt = MethodType.methodType(void.class, String.class);\nmh = lookup.findVirtual(java.io.PrintStream.class, \"println\", mt);\nmh.invokeExact(System.out, \"Hello, world.\");\n// invokeExact(Ljava/io/PrintStream;Ljava/lang/String;)V\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MutableCallSite",
        "Code": "\nMutableCallSite name = new MutableCallSite(MethodType.methodType(String.class));\nMethodHandle MH_name = name.dynamicInvoker();\nMethodType MT_str1 = MethodType.methodType(String.class);\nMethodHandle MH_upcase = MethodHandles.lookup()\n    .findVirtual(String.class, \"toUpperCase\", MT_str1);\nMethodHandle worker1 = MethodHandles.filterReturnValue(MH_name, MH_upcase);\nname.setTarget(MethodHandles.constant(String.class, \"Rocky\"));\nassertEquals(\"ROCKY\", (String) worker1.invokeExact());\nname.setTarget(MethodHandles.constant(String.class, \"Fred\"));\nassertEquals(\"FRED\", (String) worker1.invokeExact());\n// (mutation can be continued indefinitely)\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MutableCallSite",
        "Code": "\nMethodType MT_str2 = MethodType.methodType(String.class, String.class);\nMethodHandle MH_cat = lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nMethodHandle MH_dear = MethodHandles.insertArguments(MH_cat, 1, \", dear?\");\nMethodHandle worker2 = MethodHandles.filterReturnValue(MH_name, MH_dear);\nassertEquals(\"Fred, dear?\", (String) worker2.invokeExact());\nname.setTarget(MethodHandles.constant(String.class, \"Wilma\"));\nassertEquals(\"WILMA\", (String) worker1.invokeExact());\nassertEquals(\"Wilma, dear?\", (String) worker2.invokeExact());\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.SwitchPoint",
        "Code": "\nMethodHandle MH_strcat = MethodHandles.lookup()\n    .findVirtual(String.class, \"concat\", MethodType.methodType(String.class, String.class));\nSwitchPoint spt = new SwitchPoint();\nassert(!spt.hasBeenInvalidated());\n// the following steps may be repeated to re-use the same switch point:\nMethodHandle worker1 = MH_strcat;\nMethodHandle worker2 = MethodHandles.permuteArguments(MH_strcat, MH_strcat.type(), 1, 0);\nMethodHandle worker = spt.guardWithTest(worker1, worker2);\nassertEquals(\"method\", (String) worker.invokeExact(\"met\", \"hod\"));\nSwitchPoint.invalidateAll(new SwitchPoint[]{ spt });\nassert(spt.hasBeenInvalidated());\nassertEquals(\"hodmet\", (String) worker.invokeExact(\"met\", \"hod\"));\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.SwitchPoint",
        "Code": "\npublic class SwitchPoint {\n  private static final MethodHandle\n    K_true  = MethodHandles.constant(boolean.class, true),\n    K_false = MethodHandles.constant(boolean.class, false);\n  private final MutableCallSite mcs;\n  private final MethodHandle mcsInvoker;\n  public SwitchPoint() {\n    this.mcs = new MutableCallSite(K_true);\n    this.mcsInvoker = mcs.dynamicInvoker();\n  }\n  public MethodHandle guardWithTest(\n                MethodHandle target, MethodHandle fallback) {\n    // Note:  mcsInvoker is of type ()boolean.\n    // Target and fallback may take any arguments, but must have the same type.\n    return MethodHandles.guardWithTest(this.mcsInvoker, target, fallback);\n  }\n  public static void invalidateAll(SwitchPoint[] spts) {\n    List&lt;MutableCallSite&gt; mcss = new ArrayList&lt;&gt;();\n    for (SwitchPoint spt : spts)  mcss.add(spt.mcs);\n    for (MutableCallSite mcs : mcss)  mcs.setTarget(K_false);\n    MutableCallSite.syncAll(mcss.toArray(new MutableCallSite[0]));\n  }\n}\n ",
        "Description": " "
    },
    {
        "API": "java.net.CookieManager",
        "Code": "\n                  use\n CookieHandler <------- HttpURLConnection\n       ^\n       | impl\n       |         use\n CookieManager -------> CookiePolicy\n             |   use\n             |--------> HttpCookie\n             |              ^\n             |              | use\n             |   use        |\n             |--------> CookieStore\n                            ^\n                            | impl\n                            |\n                  Internal in-memory implementation\n ",
        "Description": " \n\n     CookieHandler is at the core of cookie management. User can call\n     CookieHandler.setDefault to set a concrete CookieHanlder implementation\n     to be used.\n   \n\n     CookiePolicy.shouldAccept will be called by CookieManager.put to see whether\n     or not one cookie should be accepted and put into cookie store. User can use\n     any of three pre-defined CookiePolicy, namely ACCEPT_ALL, ACCEPT_NONE and\n     ACCEPT_ORIGINAL_SERVER, or user can define his own CookiePolicy implementation\n     and tell CookieManager to use it.\n   \n\n     CookieStore is the place where any accepted HTTP cookie is stored in.\n     If not specified when created, a CookieManager instance will use an internal\n     in-memory implementation. Or user can implements one and tell CookieManager\n     to use it.\n   \n\n     Currently, only CookieStore.add(URI, HttpCookie) and CookieStore.get(URI)\n     are used by CookieManager. Others are for completeness and might be needed\n     by a more sophisticated CookieStore implementation, e.g. a NetscapeCookieSotre.\n   \n"
    },
    {
        "API": "java.net.CookieManager",
        "Code": "\n       // this should be done at the beginning of an HTTP session\n       CookieHandler.setDefault(new CookieManager(new MyCookieStore(), new MyCookiePolicy()));\n     ",
        "Description": " "
    },
    {
        "API": "java.net.CookieManager",
        "Code": "\n       // this should be done at the beginning of an HTTP session\n       CookieHandler.setDefault(new CookieManager());\n       // this can be done at any point of an HTTP session\n       ((CookieManager)CookieHandler.getDefault()).setCookiePolicy(new MyCookiePolicy());\n     ",
        "Description": " "
    },
    {
        "API": "java.security.DomainLoadStoreParameter",
        "Code": "\n     domain <domainName> [<property> ...] {\n         keystore <keystoreName> [<property> ...] ;\n         ...\n     };\n     ...\n ",
        "Description": "\n The following syntax is supported for configuration data:\n  domainName"
    },
    {
        "API": "java.security.DomainLoadStoreParameter",
        "Code": "\n\n domain app1 {\n     keystore app1-truststore\n         keystoreURI=\"file:///app1/etc/truststore.jks\";\n\n     keystore system-truststore\n         keystoreURI=\"${java.home}/lib/security/cacerts\";\n\n     keystore app1-keystore\n         keystoreType=\"PKCS12\"\n         keystoreURI=\"file:///app1/etc/keystore.p12\";\n };\n\n ",
        "Description": "\n For example, configuration data for a simple keystore domain\n comprising three keystores is shown below:\n  "
    },
    {
        "API": "java.security.MessageDigest",
        "Code": "\n MessageDigest md = MessageDigest.getInstance(\"SHA\");\n\n try {\n     md.update(toChapter1);\n     MessageDigest tc1 = md.clone();\n     byte[] toChapter1Digest = tc1.digest();\n     md.update(toChapter2);\n     ...etc.\n } catch (CloneNotSupportedException cnse) {\n     throw new DigestException(\"couldn't make digest of partial content\");\n }\n ",
        "Description": "Implementations are free to implement the Cloneable interface.\n Client applications can test cloneability by attempting cloning\n and catching the CloneNotSupportedException:\n\n  Note that if a given implementation is not cloneable, it is\n still possible to compute intermediate digests by instantiating\n several instances, if the number of digests is known in advance.\n\n "
    },
    {
        "API": "java.security.SignedObject",
        "Code": "\n Signature signingEngine = Signature.getInstance(algorithm,\n                                                 provider);\n SignedObject so = new SignedObject(myobject, signingKey,\n                                    signingEngine);\n ",
        "Description": " The underlying signing algorithm is designated by the Signature\n object passed to the constructor and the verify method.\n A typical usage for signing is the following:\n\n   A typical usage for verification is the following (having\n received SignedObject so):\n\n "
    },
    {
        "API": "java.security.SignedObject",
        "Code": "\n Signature verificationEngine =\n     Signature.getInstance(algorithm, provider);\n if (so.verify(publickey, verificationEngine))\n     try {\n         Object myobj = so.getObject();\n     } catch (java.lang.ClassNotFoundException e) {};\n ",
        "Description": " A typical usage for verification is the following (having\n received SignedObject so):\n\n   Several points are worth noting.  First, there is no need to\n initialize the signing or verification engine, as it will be\n re-initialized inside the constructor and the verify\n method. Secondly, for verification to succeed, the specified\n public key must be the public key corresponding to the private key\n used to generate the SignedObject.\n\n "
    },
    {
        "API": "java.security.cert.CertificateFactory",
        "Code": "\n FileInputStream fis = new FileInputStream(filename);\n BufferedInputStream bis = new BufferedInputStream(fis);\n\n CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n\n while (bis.available() > 0) {\n    Certificate cert = cf.generateCertificate(bis);\n    System.out.println(cert.toString());\n }\n ",
        "Description": "The following example reads a file with Base64 encoded certificates,\n which are each bounded at the beginning by -----BEGIN CERTIFICATE-----, and\n bounded at the end by -----END CERTIFICATE-----. We convert the\n FileInputStream (which does not support mark\n and reset) to a BufferedInputStream (which\n supports those methods), so that each call to\n generateCertificate consumes only one certificate, and the\n read position of the input stream is positioned to the next certificate in\n the file:\n\n  The following example parses a PKCS#7-formatted certificate reply stored\n in a file and extracts all the certificates from it:\n\n "
    },
    {
        "API": "java.security.cert.CertificateFactory",
        "Code": "\n FileInputStream fis = new FileInputStream(filename);\n CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n Collection c = cf.generateCertificates(fis);\n Iterator i = c.iterator();\n while (i.hasNext()) {\n    Certificate cert = (Certificate)i.next();\n    System.out.println(cert);\n }\n ",
        "Description": "The following example parses a PKCS#7-formatted certificate reply stored\n in a file and extracts all the certificates from it:\n\n   Every implementation of the Java platform is required to support the\n following standard CertificateFactory type:\n "
    },
    {
        "API": "java.security.cert.X509CRL",
        "Code": "\n CertificateList  ::=  SEQUENCE  {\n     tbsCertList          TBSCertList,\n     signatureAlgorithm   AlgorithmIdentifier,\n     signature            BIT STRING  }\n ",
        "Description": "\n The X.509 v2 CRL format is described below in ASN.1:\n  \n More information can be found in\n RFC 3280: Internet X.509\n Public Key Infrastructure Certificate and CRL Profile.\n "
    },
    {
        "API": "java.security.cert.X509CRL",
        "Code": "\n TBSCertList  ::=  SEQUENCE  {\n     version                 Version OPTIONAL,\n                             -- if present, must be v2\n     signature               AlgorithmIdentifier,\n     issuer                  Name,\n     thisUpdate              ChoiceOfTime,\n     nextUpdate              ChoiceOfTime OPTIONAL,\n     revokedCertificates     SEQUENCE OF SEQUENCE  {\n         userCertificate         CertificateSerialNumber,\n         revocationDate          ChoiceOfTime,\n         crlEntryExtensions      Extensions OPTIONAL\n                                 -- if present, must be v2\n         }  OPTIONAL,\n     crlExtensions           [0]  EXPLICIT Extensions OPTIONAL\n                                  -- if present, must be v2\n     }\n ",
        "Description": "\n The ASN.1 definition of tbsCertList is:\n  \n CRLs are instantiated using a certificate factory. The following is an\n example of how to instantiate an X.509 CRL:\n "
    },
    {
        "API": "java.security.cert.X509CRL",
        "Code": "\n try (InputStream inStream = new FileInputStream(\"fileName-of-crl\")) {\n     CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n     X509CRL crl = (X509CRL)cf.generateCRL(inStream);\n }\n ",
        "Description": "\n CRLs are instantiated using a certificate factory. The following is an\n example of how to instantiate an X.509 CRL:\n  "
    },
    {
        "API": "java.text.CharacterIterator",
        "Code": "\n public void traverseForward(CharacterIterator iter) {\n     for(char c = iter.first(); c != CharacterIterator.DONE; c = iter.next()) {\n         processChar(c);\n     }\n }\n ",
        "Description": "\n\n Traverse the text from start to finish\n  \n public void traverseBackward(CharacterIterator iter) {\n     for(char c = iter.last(); c != CharacterIterator.DONE; c = iter.previous()) {\n         processChar(c);\n     }\n }\n "
    },
    {
        "API": "java.text.CharacterIterator",
        "Code": "\n public void traverseBackward(CharacterIterator iter) {\n     for(char c = iter.last(); c != CharacterIterator.DONE; c = iter.previous()) {\n         processChar(c);\n     }\n }\n ",
        "Description": "\n public void traverseForward(CharacterIterator iter) {\n     for(char c = iter.first(); c != CharacterIterator.DONE; c = iter.next()) {\n         processChar(c);\n     }\n }\n  \n public void traverseOut(CharacterIterator iter, int pos) {\n     for (char c = iter.setIndex(pos);\n              c != CharacterIterator.DONE && notBoundary(c);\n              c = iter.next()) {\n     }\n     int end = iter.getIndex();\n     for (char c = iter.setIndex(pos);\n             c != CharacterIterator.DONE && notBoundary(c);\n             c = iter.previous()) {\n     }\n     int start = iter.getIndex();\n     processSection(start, end);\n }\n "
    },
    {
        "API": "java.text.CharacterIterator",
        "Code": "\n public void traverseOut(CharacterIterator iter, int pos) {\n     for (char c = iter.setIndex(pos);\n              c != CharacterIterator.DONE && notBoundary(c);\n              c = iter.next()) {\n     }\n     int end = iter.getIndex();\n     for (char c = iter.setIndex(pos);\n             c != CharacterIterator.DONE && notBoundary(c);\n             c = iter.previous()) {\n     }\n     int start = iter.getIndex();\n     processSection(start, end);\n }\n ",
        "Description": "\n public void traverseBackward(CharacterIterator iter) {\n     for(char c = iter.last(); c != CharacterIterator.DONE; c = iter.previous()) {\n         processChar(c);\n     }\n }\n  "
    },
    {
        "API": "java.text.BreakIterator",
        "Code": "\n public static void main(String args[]) {\n      if (args.length == 1) {\n          String stringToExamine = args[0];\n          //print each word in order\n          BreakIterator boundary = BreakIterator.getWordInstance();\n          boundary.setText(stringToExamine);\n          printEachForward(boundary, stringToExamine);\n          //print each sentence in reverse order\n          boundary = BreakIterator.getSentenceInstance(Locale.US);\n          boundary.setText(stringToExamine);\n          printEachBackward(boundary, stringToExamine);\n          printFirst(boundary, stringToExamine);\n          printLast(boundary, stringToExamine);\n      }\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.BreakIterator",
        "Code": "\n public static void printEachForward(BreakIterator boundary, String source) {\n     int start = boundary.first();\n     for (int end = boundary.next();\n          end != BreakIterator.DONE;\n          start = end, end = boundary.next()) {\n          System.out.println(source.substring(start,end));\n     }\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.BreakIterator",
        "Code": "\n public static void printEachBackward(BreakIterator boundary, String source) {\n     int end = boundary.last();\n     for (int start = boundary.previous();\n          start != BreakIterator.DONE;\n          end = start, start = boundary.previous()) {\n         System.out.println(source.substring(start,end));\n     }\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.BreakIterator",
        "Code": "\n public static void printFirst(BreakIterator boundary, String source) {\n     int start = boundary.first();\n     int end = boundary.next();\n     System.out.println(source.substring(start,end));\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.BreakIterator",
        "Code": "\n public static void printLast(BreakIterator boundary, String source) {\n     int end = boundary.last();\n     int start = boundary.previous();\n     System.out.println(source.substring(start,end));\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.BreakIterator",
        "Code": "\n public static void printAt(BreakIterator boundary, int pos, String source) {\n     int end = boundary.following(pos);\n     int start = boundary.previous();\n     System.out.println(source.substring(start,end));\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.BreakIterator",
        "Code": "\n public static int nextWordStartAfter(int pos, String text) {\n     BreakIterator wb = BreakIterator.getWordInstance();\n     wb.setText(text);\n     int last = wb.following(pos);\n     int current = wb.next();\n     while (current != BreakIterator.DONE) {\n         for (int p = last; p < current; p++) {\n             if (Character.isLetter(text.codePointAt(p)))\n                 return last;\n         }\n         last = current;\n         current = wb.next();\n     }\n     return BreakIterator.DONE;\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.ChoiceFormat",
        "Code": "\n X matches j if and only if limit[j] \u2264 X < limit[j+1]\n ",
        "Description": " "
    },
    {
        "API": "java.text.ChoiceFormat",
        "Code": "\n double[] limits = {1,2,3,4,5,6,7};\n String[] dayOfWeekNames = {\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thur\",\"Fri\",\"Sat\"};\n ChoiceFormat form = new ChoiceFormat(limits, dayOfWeekNames);\n ParsePosition status = new ParsePosition(0);\n for (double i = 0.0; i <= 8.0; ++i) {\n     status.setIndex(0);\n     System.out.println(i + \" -> \" + form.format(i) + \" -> \"\n                              + form.parse(form.format(i),status));\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.ChoiceFormat",
        "Code": "\n double[] filelimits = {0,1,2};\n String[] filepart = {\"are no files\",\"is one file\",\"are {2} files\"};\n ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);\n Format[] testFormats = {fileform, null, NumberFormat.getInstance()};\n MessageFormat pattform = new MessageFormat(\"There {0} on {1}\");\n pattform.setFormats(testFormats);\n Object[] testArgs = {null, \"ADisk\", null};\n for (int i = 0; i < 4; ++i) {\n     testArgs[0] = new Integer(i);\n     testArgs[2] = testArgs[0];\n     System.out.println(pattform.format(testArgs));\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.ChoiceFormat",
        "Code": "\n ChoiceFormat fmt = new ChoiceFormat(\n      \"-1#is negative| 0#is zero or fraction | 1#is one |1.0<is 1+ |2#is two |2<is more than 2.\");\n System.out.println(\"Formatter Pattern : \" + fmt.toPattern());\n\n System.out.println(\"Format with -INF : \" + fmt.format(Double.NEGATIVE_INFINITY));\n System.out.println(\"Format with -1.0 : \" + fmt.format(-1.0));\n System.out.println(\"Format with 0 : \" + fmt.format(0));\n System.out.println(\"Format with 0.9 : \" + fmt.format(0.9));\n System.out.println(\"Format with 1.0 : \" + fmt.format(1));\n System.out.println(\"Format with 1.5 : \" + fmt.format(1.5));\n System.out.println(\"Format with 2 : \" + fmt.format(2));\n System.out.println(\"Format with 2.1 : \" + fmt.format(2.1));\n System.out.println(\"Format with NaN : \" + fmt.format(Double.NaN));\n System.out.println(\"Format with +INF : \" + fmt.format(Double.POSITIVE_INFINITY));\n ",
        "Description": " "
    },
    {
        "API": "java.text.ChoiceFormat",
        "Code": "\n Format with -INF : is negative\n Format with -1.0 : is negative\n Format with 0 : is zero or fraction\n Format with 0.9 : is zero or fraction\n Format with 1.0 : is one\n Format with 1.5 : is 1+\n Format with 2 : is two\n Format with 2.1 : is more than 2.\n Format with NaN : is negative\n Format with +INF : is more than 2.\n ",
        "Description": " "
    },
    {
        "API": "java.text.CollationKey",
        "Code": "\n // Create an array of CollationKeys for the Strings to be sorted.\n Collator myCollator = Collator.getInstance();\n CollationKey[] keys = new CollationKey[3];\n keys[0] = myCollator.getCollationKey(\"Tom\");\n keys[1] = myCollator.getCollationKey(\"Dick\");\n keys[2] = myCollator.getCollationKey(\"Harry\");\n sort(keys);\n\n //...\n\n // Inside body of sort routine, compare keys this way\n if (keys[i].compareTo(keys[j]) > 0)\n    // swap keys[i] and keys[j]\n\n //...\n\n // Finally, when we've returned from sort.\n System.out.println(keys[0].getSourceString());\n System.out.println(keys[1].getSourceString());\n System.out.println(keys[2].getSourceString());\n ",
        "Description": " "
    },
    {
        "API": "java.text.Collator",
        "Code": "\n // Compare two strings in the default locale\n Collator myCollator = Collator.getInstance();\n if( myCollator.compare(\"abc\", \"ABC\") < 0 )\n     System.out.println(\"abc is less than ABC\");\n else\n     System.out.println(\"abc is greater than or equal to ABC\");\n ",
        "Description": " "
    },
    {
        "API": "java.text.Collator",
        "Code": "\n //Get the Collator for US English and set its strength to PRIMARY\n Collator usCollator = Collator.getInstance(Locale.US);\n usCollator.setStrength(Collator.PRIMARY);\n if( usCollator.compare(\"abc\", \"ABC\") == 0 ) {\n     System.out.println(\"Strings are equivalent\");\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.DateFormat",
        "Code": "\n myString = DateFormat.getDateInstance().format(myDate);\n ",
        "Description": " "
    },
    {
        "API": "java.text.DateFormat",
        "Code": "\n DateFormat df = DateFormat.getDateInstance();\n for (int i = 0; i < myDate.length; ++i) {\n     output.println(df.format(myDate[i]) + \"; \");\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.DateFormat",
        "Code": "\n DateFormat df = DateFormat.getDateInstance(DateFormat.LONG, Locale.FRANCE);\n ",
        "Description": " "
    },
    {
        "API": "java.text.DateFormat",
        "Code": "\n myDate = df.parse(myString);\n ",
        "Description": " "
    },
    {
        "API": "java.text.DecimalFormat",
        "Code": "\n NumberFormat f = NumberFormat.getInstance(loc);\n if (f instanceof DecimalFormat) {\n     ((DecimalFormat) f).setDecimalSeparatorAlwaysShown(true);\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.DecimalFormat",
        "Code": "\n Pattern:\n         PositivePattern\n         PositivePattern ; NegativePattern\n PositivePattern:\n         Prefixopt Number Suffixopt\n NegativePattern:\n         Prefixopt Number Suffixopt\n Prefix:\n         any Unicode characters except \\uFFFE, \\uFFFF, and special characters\n Suffix:\n         any Unicode characters except \\uFFFE, \\uFFFF, and special characters\n Number:\n         Integer Exponentopt\n         Integer . Fraction Exponentopt\n Integer:\n         MinimumInteger\n         #\n         # Integer\n         # , Integer\n MinimumInteger:\n         0\n         0 MinimumInteger\n         0 , MinimumInteger\n Fraction:\n         MinimumFractionopt OptionalFractionopt\n MinimumFraction:\n         0 MinimumFractionopt\n OptionalFraction:\n         # OptionalFractionopt\n Exponent:\n         E MinimumExponent\n MinimumExponent:\n         0 MinimumExponentopt\n ",
        "Description": " "
    },
    {
        "API": "java.text.DecimalFormat",
        "Code": "\n <strong>// Print out a number using the localized number, integer, currency,\n // and percent format for each locale</strong>\n Locale[] locales = NumberFormat.getAvailableLocales();\n double myNumber = -1234.56;\n NumberFormat form;\n for (int j = 0; j < 4; ++j) {\n     System.out.println(\"FORMAT\");\n     for (int i = 0; i < locales.length; ++i) {\n         if (locales[i].getCountry().length() == 0) {\n            continue; // Skip language-only locales\n         }\n         System.out.print(locales[i].getDisplayName());\n         switch (j) {\n         case 0:\n             form = NumberFormat.getInstance(locales[i]); break;\n         case 1:\n             form = NumberFormat.getIntegerInstance(locales[i]); break;\n         case 2:\n             form = NumberFormat.getCurrencyInstance(locales[i]); break;\n         default:\n             form = NumberFormat.getPercentInstance(locales[i]); break;\n         }\n         if (form instanceof DecimalFormat) {\n             System.out.print(\": \" + ((DecimalFormat) form).toPattern());\n         }\n         System.out.print(\" -> \" + form.format(myNumber));\n         try {\n             System.out.println(\" -> \" + form.parse(form.format(myNumber)));\n         } catch (ParseException e) {}\n     }\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "\n MessageFormatPattern:\n         String\n         MessageFormatPattern FormatElement String\n\n FormatElement:\n         { ArgumentIndex }\n         { ArgumentIndex , FormatType }\n         { ArgumentIndex , FormatType , FormatStyle }\n\n FormatType: one of \n         number date time choice\n\n FormatStyle:\n         short\n         medium\n         long\n         full\n         integer\n         currency\n         percent\n         SubformatPattern\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "\n int planet = 7;\n String event = \"a disturbance in the Force\";\n\n String result = MessageFormat.format(\n     \"At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.\",\n     planet, new Date(), event);\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "\n At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "\n int fileCount = 1273;\n String diskName = \"MyDisk\";\n Object[] testArgs = {new Long(fileCount), diskName};\n\n MessageFormat form = new MessageFormat(\n     \"The disk \\\"{1}\\\" contains {0} file(s).\");\n\n System.out.println(form.format(testArgs));\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "\n The disk \"MyDisk\" contains 0 file(s).\n The disk \"MyDisk\" contains 1 file(s).\n The disk \"MyDisk\" contains 1,273 file(s).\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "\n MessageFormat form = new MessageFormat(\"The disk \\\"{1}\\\" contains {0}.\");\n double[] filelimits = {0,1,2};\n String[] filepart = {\"no files\",\"one file\",\"{0,number} files\"};\n ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);\n form.setFormatByArgumentIndex(0, fileform);\n\n int fileCount = 1273;\n String diskName = \"MyDisk\";\n Object[] testArgs = {new Long(fileCount), diskName};\n\n System.out.println(form.format(testArgs));\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "\n The disk \"MyDisk\" contains no files.\n The disk \"MyDisk\" contains one file.\n The disk \"MyDisk\" contains 1,273 files.\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "\n form.applyPattern(\n    \"There {0,choice,0#are no files|1#is one file|1<are {0,number,integer} files}.\");\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "\n MessageFormat mf = new MessageFormat(\"{0,number,#.##}, {0,number,#.#}\");\n Object[] objs = {new Double(3.1415)};\n String result = mf.format( objs );\n // result now equals \"3.14, 3.1\"\n objs = null;\n objs = mf.parse(result, new ParsePosition(0));\n // objs now equals {new Double(3.1)}\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "\n MessageFormat mf = new MessageFormat(\"{0}, {0}, {0}\");\n String forParsing = \"x, y, z\";\n Object[] objs = mf.parse(forParsing, new ParsePosition(0));\n // result now equals {new String(\"z\")}\n ",
        "Description": " "
    },
    {
        "API": "java.text.NumberFormat",
        "Code": "\n myString = NumberFormat.getInstance().format(myNumber);\n ",
        "Description": " "
    },
    {
        "API": "java.text.NumberFormat",
        "Code": "\n NumberFormat nf = NumberFormat.getInstance();\n for (int i = 0; i < myNumber.length; ++i) {\n     output.println(nf.format(myNumber[i]) + \"; \");\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.NumberFormat",
        "Code": "\n NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);\n ",
        "Description": " "
    },
    {
        "API": "java.text.NumberFormat",
        "Code": "\n myNumber = nf.parse(myString);\n ",
        "Description": " "
    },
    {
        "API": "java.util.Scanner",
        "Code": "\n     Scanner sc = new Scanner(System.in);\n     int i = sc.nextInt();\n ",
        "Description": " "
    },
    {
        "API": "java.util.Scanner",
        "Code": "\n      Scanner sc = new Scanner(new File(\"myNumbers\"));\n      while (sc.hasNextLong()) {\n          long aLong = sc.nextLong();\n      }\n ",
        "Description": " "
    },
    {
        "API": "java.util.Scanner",
        "Code": "\n     String input = \"1 fish 2 fish red fish blue fish\";\n     Scanner s = new Scanner(input).useDelimiter(\"\\\\s*fish\\\\s*\");\n     System.out.println(s.nextInt());\n     System.out.println(s.nextInt());\n     System.out.println(s.next());\n     System.out.println(s.next());\n     s.close();\n ",
        "Description": " "
    },
    {
        "API": "java.util.Scanner",
        "Code": "\n     1\n     2\n     red\n     blue\n ",
        "Description": " "
    },
    {
        "API": "java.util.Scanner",
        "Code": "\n     String input = \"1 fish 2 fish red fish blue fish\";\n     Scanner s = new Scanner(input);\n     s.findInLine(\"(\\\\d+) fish (\\\\d+) fish (\\\\w+) fish (\\\\w+)\");\n     MatchResult result = s.match();\n     for (int i=1; i<=result.groupCount(); i++)\n         System.out.println(result.group(i));\n     s.close();\n ",
        "Description": " "
    },
    {
        "API": "java.util.SimpleTimeZone",
        "Code": "\n      // Base GMT offset: -8:00\n      // DST starts:      at 2:00am in standard time\n      //                  on the first Sunday in April\n      // DST ends:        at 2:00am in daylight time\n      //                  on the last Sunday in October\n      // Save:            1 hour\n      SimpleTimeZone(-28800000,\n                     \"America/Los_Angeles\",\n                     Calendar.APRIL, 1, -Calendar.SUNDAY,\n                     7200000,\n                     Calendar.OCTOBER, -1, Calendar.SUNDAY,\n                     7200000,\n                     3600000)\n\n      // Base GMT offset: +1:00\n      // DST starts:      at 1:00am in UTC time\n      //                  on the last Sunday in March\n      // DST ends:        at 1:00am in UTC time\n      //                  on the last Sunday in October\n      // Save:            1 hour\n      SimpleTimeZone(3600000,\n                     \"Europe/Paris\",\n                     Calendar.MARCH, -1, Calendar.SUNDAY,\n                     3600000, SimpleTimeZone.UTC_TIME,\n                     Calendar.OCTOBER, -1, Calendar.SUNDAY,\n                     3600000, SimpleTimeZone.UTC_TIME,\n                     3600000)\n ",
        "Description": "\n The following are examples of parameters for constructing time zone objects.\n  setStartRule"
    },
    {
        "API": "java.util.concurrent.locks.StampedLock",
        "Code": "\n class Point {\n   private double x, y;\n   private final StampedLock sl = new StampedLock();\n\n   void move(double deltaX, double deltaY) { // an exclusively locked method\n     long stamp = sl.writeLock();\n     try {\n       x += deltaX;\n       y += deltaY;\n     } finally {\n       sl.unlockWrite(stamp);\n     }\n   }\n\n   double distanceFromOrigin() { // A read-only method\n     long stamp = sl.tryOptimisticRead();\n     double currentX = x, currentY = y;\n     if (!sl.validate(stamp)) {\n        stamp = sl.readLock();\n        try {\n          currentX = x;\n          currentY = y;\n        } finally {\n           sl.unlockRead(stamp);\n        }\n     }\n     return Math.sqrt(currentX * currentX + currentY * currentY);\n   }\n\n   void moveIfAtOrigin(double newX, double newY) { // upgrade\n     // Could instead start with optimistic, not read mode\n     long stamp = sl.readLock();\n     try {\n       while (x == 0.0 && y == 0.0) {\n         long ws = sl.tryConvertToWriteLock(stamp);\n         if (ws != 0L) {\n           stamp = ws;\n           x = newX;\n           y = newY;\n           break;\n         }\n         else {\n           sl.unlockRead(stamp);\n           stamp = sl.writeLock();\n         }\n       }\n     } finally {\n       sl.unlock(stamp);\n     }\n   }\n }",
        "Description": "Sample Usage. The following illustrates some usage idioms\n in a class that maintains simple two-dimensional points. The sample\n code illustrates some try/catch conventions even though they are\n not strictly needed here because no exceptions can occur in their\n bodies.\n "
    },
    {
        "API": "java.util.jar.Pack200",
        "Code": "\n    import java.util.jar.Pack200;\n    import java.util.jar.Pack200.*;\n    ...\n    // Create the Packer object\n    Packer packer = Pack200.newPacker();\n\n    // Initialize the state by setting the desired properties\n    Map p = packer.properties();\n    // take more time choosing codings for better compression\n    p.put(Packer.EFFORT, \"7\");  // default is \"5\"\n    // use largest-possible archive segments (>10% better compression).\n    p.put(Packer.SEGMENT_LIMIT, \"-1\");\n    // reorder files for better compression.\n    p.put(Packer.KEEP_FILE_ORDER, Packer.FALSE);\n    // smear modification times to a single value.\n    p.put(Packer.MODIFICATION_TIME, Packer.LATEST);\n    // ignore all JAR deflation requests,\n    // transmitting a single request to use \"store\" mode.\n    p.put(Packer.DEFLATE_HINT, Packer.FALSE);\n    // discard debug attributes\n    p.put(Packer.CODE_ATTRIBUTE_PFX+\"LineNumberTable\", Packer.STRIP);\n    // throw an error if an attribute is unrecognized\n    p.put(Packer.UNKNOWN_ATTRIBUTE, Packer.ERROR);\n    // pass one class file uncompressed:\n    p.put(Packer.PASS_FILE_PFX+0, \"mutants/Rogue.class\");\n    try {\n        JarFile jarFile = new JarFile(\"/tmp/testref.jar\");\n        FileOutputStream fos = new FileOutputStream(\"/tmp/test.pack\");\n        // Call the packer\n        packer.pack(jarFile, fos);\n        jarFile.close();\n        fos.close();\n\n        File f = new File(\"/tmp/test.pack\");\n        FileOutputStream fostream = new FileOutputStream(\"/tmp/test.jar\");\n        JarOutputStream jostream = new JarOutputStream(fostream);\n        Unpacker unpacker = Pack200.newUnpacker();\n        // Call the unpacker\n        unpacker.unpack(f, jostream);\n        // Must explicitly close the output.\n        jostream.close();\n    } catch (IOException ioe) {\n        ioe.printStackTrace();\n    }\n ",
        "Description": "\n Here is an example using  packer and unpacker:\n  \n A Pack200 file compressed with gzip can be hosted on HTTP/1.1 web servers.\n The deployment applications can use \"Accept-Encoding=pack200-gzip\". This\n indicates to the server that the client application desires a version of\n the file encoded with Pack200 and further compressed with gzip. Please\n refer to  Java Deployment Guide for more details and\n techniques.\n "
    },
    {
        "API": "java.util.logging.Logger",
        "Code": "\n\n   class DiagnosisMessages {\n     static String systemHealthStatus() {\n       // collect system health information\n       ...\n     }\n   }\n   ...\n   logger.log(Level.FINER, DiagnosisMessages.systemHealthStatus());\n",
        "Description": "\n A set of methods alternatively take a \"msgSupplier\" instead of a \"msg\"\n argument.  These methods take a Supplier<String> function\n which is invoked to construct the desired log message only when the message\n actually is to be logged based on the effective log level thus eliminating\n unnecessary message construction. For example, if the developer wants to\n log system health status for diagnosis, with the String-accepting version,\n the code would look like:\n  \n\n   logger.log(Level.FINER, DiagnosisMessages::systemHealthStatus);\n"
    },
    {
        "API": "java.util.logging.Logger",
        "Code": "\n\n   logger.log(Level.FINER, DiagnosisMessages::systemHealthStatus);\n",
        "Description": "\n\n   class DiagnosisMessages {\n     static String systemHealthStatus() {\n       // collect system health information\n       ...\n     }\n   }\n   ...\n   logger.log(Level.FINER, DiagnosisMessages.systemHealthStatus());\n \n When looking for a ResourceBundle, the logger will first look at\n whether a bundle was specified using setResourceBundle, and then\n only whether a resource bundle name was specified through the getLogger factory method.\n If no ResourceBundle or no resource bundle name is found,\n then it will use the nearest ResourceBundle or resource bundle\n name inherited from its parent tree.\n When a ResourceBundle was inherited or specified through the\n setResourceBundle method, then\n that ResourceBundle will be used. Otherwise if the logger only\n has or inherited a resource bundle name, then that resource bundle name\n will be mapped to a ResourceBundle object, using the default Locale\n at the time of logging.\n When mapping resource bundle names to\n ResourceBundle objects, the logger will first try to use the\n Thread's context class\n loader to map the given resource bundle name to a ResourceBundle.\n If the thread context class loader is null, it will try the\n system class loader\n instead.  If the ResourceBundle is still not found, it will use the\n class loader of the first caller of the getLogger factory method.\n "
    },
    {
        "API": "java.util.prefs.Preferences",
        "Code": "\n <!DOCTYPE preferences SYSTEM \"http://java.sun.com/dtd/preferences.dtd\">\n ",
        "Description": "The XML document has the following DOCTYPE declaration:\n  not"
    },
    {
        "API": "java.util.prefs.Preferences",
        "Code": "\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n    <!-- DTD for a Preferences tree. -->\n\n    <!-- The preferences element is at the root of an XML document\n         representing a Preferences tree. -->\n    <!ELEMENT preferences (root)>\n\n    <!-- The preferences element contains an optional version attribute,\n          which specifies version of DTD. -->\n    <!ATTLIST preferences EXTERNAL_XML_VERSION CDATA \"0.0\" >\n\n    <!-- The root element has a map representing the root's preferences\n         (if any), and one node for each child of the root (if any). -->\n    <!ELEMENT root (map, node*) >\n\n    <!-- Additionally, the root contains a type attribute, which\n         specifies whether it's the system or user root. -->\n    <!ATTLIST root\n              type (system|user) #REQUIRED >\n\n    <!-- Each node has a map representing its preferences (if any),\n         and one node for each child (if any). -->\n    <!ELEMENT node (map, node*) >\n\n    <!-- Additionally, each node has a name attribute -->\n    <!ATTLIST node\n              name CDATA #REQUIRED >\n\n    <!-- A map represents the preferences stored at a node (if any). -->\n    <!ELEMENT map (entry*) >\n\n    <!-- An entry represents a single preference, which is simply\n          a key-value pair. -->\n    <!ELEMENT entry EMPTY >\n    <!ATTLIST entry\n              key   CDATA #REQUIRED\n              value CDATA #REQUIRED >\n ",
        "Description": "not Preferences"
    },
    {
        "API": "java.util.stream.BaseStream",
        "Code": "\n     int sum = widgets.stream()\n                      .filter(w -> w.getColor() == RED)\n                      .mapToInt(w -> w.getWeight())\n                      .sum();\n ",
        "Description": "IntStream Stream"
    },
    {
        "API": "java.util.stream.Collector",
        "Code": "\n     A a1 = supplier.get();\n     accumulator.accept(a1, t1);\n     accumulator.accept(a1, t2);\n     R r1 = finisher.apply(a1);  // result without splitting\n\n     A a2 = supplier.get();\n     accumulator.accept(a2, t1);\n     A a3 = supplier.get();\n     accumulator.accept(a3, t2);\n     R r2 = finisher.apply(combiner.apply(a2, a3));  // result with splitting\n  ",
        "Description": "The associativity constraint says that splitting the computation must\n produce an equivalent result.  That is, for any input elements t1\n and t2, the results r1 and r2 in the computation\n below must be equivalent:\n  For collectors that do not have the UNORDERED characteristic,\n two accumulated results a1 and a2 are equivalent if\n finisher.apply(a1).equals(finisher.apply(a2)).  For unordered\n collectors, equivalence is relaxed to allow for non-equality related to\n differences in order.  (For example, an unordered collector that accumulated\n elements to a List would consider two lists equivalent if they\n contained the same elements, ignoring order.)\n\n "
    },
    {
        "API": "java.util.stream.Collector",
        "Code": "\n     Collector<Widget, ?, TreeSet<Widget>> intoSet =\n         Collector.of(TreeSet::new, TreeSet::add,\n                      (left, right) -> { left.addAll(right); return left; });\n ",
        "Description": "In addition to the predefined implementations in Collectors, the\n static factory methods of(Supplier, BiConsumer, BinaryOperator, Characteristics...)\n can be used to construct collectors.  For example, you could create a collector\n that accumulates widgets into a TreeSet with:\n\n  Collectors.toCollection(Supplier)"
    },
    {
        "API": "java.util.stream.DoubleStream",
        "Code": "\n     double sum = widgets.stream()\n                         .filter(w -> w.getColor() == RED)\n                         .mapToDouble(w -> w.getWeight())\n                         .sum();\n ",
        "Description": "The following example illustrates an aggregate operation using\n Stream and DoubleStream, computing the sum of the weights of the\n red widgets:\n\n  Stream"
    },
    {
        "API": "java.util.stream.IntStream",
        "Code": "\n     int sum = widgets.stream()\n                      .filter(w -> w.getColor() == RED)\n                      .mapToInt(w -> w.getWeight())\n                      .sum();\n ",
        "Description": "The following example illustrates an aggregate operation using\n Stream and IntStream, computing the sum of the weights of the\n red widgets:\n\n  Stream"
    },
    {
        "API": "java.util.stream.LongStream",
        "Code": "\n     long sum = widgets.stream()\n                       .filter(w -> w.getColor() == RED)\n                       .mapToLong(w -> w.getWeight())\n                       .sum();\n ",
        "Description": "The following example illustrates an aggregate operation using\n Stream and LongStream, computing the sum of the weights of the\n red widgets:\n\n  Stream"
    },
    {
        "API": "java.util.stream.Stream",
        "Code": "\n     int sum = widgets.stream()\n                      .filter(w -> w.getColor() == RED)\n                      .mapToInt(w -> w.getWeight())\n                      .sum();\n ",
        "Description": "IntStream widgets"
    },
    {
        "API": "java.util.stream.Collectors",
        "Code": "\n     // Accumulate names into a List\n     List<String> list = people.stream().map(Person::getName).collect(Collectors.toList());\n\n     // Accumulate names into a TreeSet\n     Set<String> set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::new));\n\n     // Convert elements to strings and concatenate them, separated by commas\n     String joined = things.stream()\n                           .map(Object::toString)\n                           .collect(Collectors.joining(\", \"));\n\n     // Compute sum of salaries of employee\n     int total = employees.stream()\n                          .collect(Collectors.summingInt(Employee::getSalary)));\n\n     // Group employees by department\n     Map<Department, List<Employee>> byDept\n         = employees.stream()\n                    .collect(Collectors.groupingBy(Employee::getDepartment));\n\n     // Compute sum of salaries by department\n     Map<Department, Integer> totalByDept\n         = employees.stream()\n                    .collect(Collectors.groupingBy(Employee::getDepartment,\n                                                   Collectors.summingInt(Employee::getSalary)));\n\n     // Partition students into passing and failing\n     Map<Boolean, List<Student>> passingFailing =\n         students.stream()\n                 .collect(Collectors.partitioningBy(s -> s.getGrade() >= PASS_THRESHOLD));\n\n ",
        "Description": "The following are examples of using the predefined collectors to perform\n common mutable reduction tasks:\n\n  "
    },
    {
        "API": "javax.management.openmbean.ArrayType",
        "Code": "\n // 2-dimension array of java.lang.String\n ArrayType<String[][]> a1 = new ArrayType<String[][]>(2, SimpleType.STRING);\n\n // 1-dimension array of int\n ArrayType<int[]> a2 = new ArrayType<int[]>(SimpleType.INTEGER, true);\n\n // 1-dimension array of java.lang.Integer\n ArrayType<Integer[]> a3 = new ArrayType<Integer[]>(SimpleType.INTEGER, false);\n\n // 4-dimension array of int\n ArrayType<int[][][][]> a4 = new ArrayType<int[][][][]>(3, a2);\n\n // 4-dimension array of java.lang.Integer\n ArrayType<Integer[][][][]> a5 = new ArrayType<Integer[][][][]>(3, a3);\n\n // 1-dimension array of java.lang.String\n ArrayType<String[]> a6 = new ArrayType<String[]>(SimpleType.STRING, false);\n\n // 1-dimension array of long\n ArrayType<long[]> a7 = new ArrayType<long[]>(SimpleType.LONG, true);\n\n // 1-dimension array of java.lang.Integer\n ArrayType<Integer[]> a8 = ArrayType.getArrayType(SimpleType.INTEGER);\n\n // 2-dimension array of java.lang.Integer\n ArrayType<Integer[][]> a9 = ArrayType.getArrayType(a8);\n\n // 2-dimension array of int\n ArrayType<int[][]> a10 = ArrayType.getPrimitiveArrayType(int[][].class);\n\n // 3-dimension array of int\n ArrayType<int[][][]> a11 = ArrayType.getArrayType(a10);\n\n // 1-dimension array of float\n ArrayType<float[]> a12 = ArrayType.getPrimitiveArrayType(float[].class);\n\n // 2-dimension array of float\n ArrayType<float[][]> a13 = ArrayType.getArrayType(a12);\n\n // 1-dimension array of javax.management.ObjectName\n ArrayType<ObjectName[]> a14 = ArrayType.getArrayType(SimpleType.OBJECTNAME);\n\n // 2-dimension array of javax.management.ObjectName\n ArrayType<ObjectName[][]> a15 = ArrayType.getArrayType(a14);\n\n // 3-dimension array of java.lang.String\n ArrayType<String[][][]> a16 = new ArrayType<String[][][]>(3, SimpleType.STRING);\n\n // 1-dimension array of java.lang.String\n ArrayType<String[]> a17 = new ArrayType<String[]>(1, SimpleType.STRING);\n\n // 2-dimension array of java.lang.String\n ArrayType<String[][]> a18 = new ArrayType<String[][]>(1, a17);\n\n // 3-dimension array of java.lang.String\n ArrayType<String[][][]> a19 = new ArrayType<String[][][]>(1, a18);\n ",
        "Description": "\n Examples of valid ArrayType instances are:\n  "
    },
    {
        "API": "javax.naming.ldap.PagedResultsControl",
        "Code": "\n\n     // Open an LDAP association\n     LdapContext ctx = new InitialLdapContext();\n\n     // Activate paged results\n     int pageSize = 20; // 20 entries per page\n     byte[] cookie = null;\n     int total;\n     ctx.setRequestControls(new Control[]{\n         new PagedResultsControl(pageSize, Control.CRITICAL) });\n\n     do {\n         // Perform the search\n         NamingEnumeration results =\n             ctx.search(\"\", \"(objectclass=*)\", new SearchControls());\n\n         // Iterate over a batch of search results\n         while (results != null && results.hasMore()) {\n             // Display an entry\n             SearchResult entry = (SearchResult)results.next();\n             System.out.println(entry.getName());\n             System.out.println(entry.getAttributes());\n\n             // Handle the entry's response controls (if any)\n             if (entry instanceof HasControls) {\n                 // ((HasControls)entry).getControls();\n             }\n         }\n         // Examine the paged results control response\n         Control[] controls = ctx.getResponseControls();\n         if (controls != null) {\n             for (int i = 0; i < controls.length; i++) {\n                 if (controls[i] instanceof PagedResultsResponseControl) {\n                     PagedResultsResponseControl prrc =\n                         (PagedResultsResponseControl)controls[i];\n                     total = prrc.getResultSize();\n                     cookie = prrc.getCookie();\n                 } else {\n                     // Handle other response controls (if any)\n                 }\n             }\n         }\n\n         // Re-activate paged results\n         ctx.setRequestControls(new Control[]{\n             new PagedResultsControl(pageSize, cookie, Control.CRITICAL) });\n     } while (cookie != null);\n\n     // Close the LDAP association\n     ctx.close();\n     ...\n\n  ",
        "Description": "\n The following code sample shows how the class may be used:\n  \n This class implements the LDAPv3 Control for paged-results as defined in\n RFC 2696.\n\n The control's value has the following ASN.1 definition:\n "
    },
    {
        "API": "javax.naming.ldap.PagedResultsControl",
        "Code": "\n\n     realSearchControlValue ::= SEQUENCE {\n         size      INTEGER (0..maxInt),\n                           -- requested page size from client\n                           -- result set size estimate from server\n         cookie    OCTET STRING\n     }\n\n ",
        "Description": "\n This class implements the LDAPv3 Control for paged-results as defined in\n RFC 2696.\n\n The control's value has the following ASN.1 definition:\n  "
    },
    {
        "API": "javax.naming.ldap.SortControl",
        "Code": "\n\n     // Open an LDAP association\n     LdapContext ctx = new InitialLdapContext();\n\n     // Activate sorting\n     String sortKey = \"cn\";\n     ctx.setRequestControls(new Control[]{\n         new SortControl(sortKey, Control.CRITICAL) });\n\n     // Perform a search\n     NamingEnumeration results =\n         ctx.search(\"\", \"(objectclass=*)\", new SearchControls());\n\n     // Iterate over search results\n     while (results != null && results.hasMore()) {\n         // Display an entry\n         SearchResult entry = (SearchResult)results.next();\n         System.out.println(entry.getName());\n         System.out.println(entry.getAttributes());\n\n         // Handle the entry's response controls (if any)\n         if (entry instanceof HasControls) {\n             // ((HasControls)entry).getControls();\n         }\n     }\n     // Examine the sort control response\n     Control[] controls = ctx.getResponseControls();\n     if (controls != null) {\n         for (int i = 0; i < controls.length; i++) {\n             if (controls[i] instanceof SortResponseControl) {\n                 SortResponseControl src = (SortResponseControl)controls[i];\n                 if (! src.isSorted()) {\n                     throw src.getException();\n                 }\n             } else {\n                 // Handle other response controls (if any)\n             }\n         }\n     }\n\n     // Close the LDAP association\n     ctx.close();\n     ...\n\n ",
        "Description": "\n The following code sample shows how the class may be used:\n  \n This class implements the LDAPv3 Request Control for server-side sorting\n as defined in\n RFC 2891.\n\n The control's value has the following ASN.1 definition:\n "
    },
    {
        "API": "javax.naming.ldap.SortControl",
        "Code": "\n\n     SortKeyList ::= SEQUENCE OF SEQUENCE {\n         attributeType     AttributeDescription,\n         orderingRule  [0] MatchingRuleId OPTIONAL,\n         reverseOrder  [1] BOOLEAN DEFAULT FALSE }\n\n ",
        "Description": "\n This class implements the LDAPv3 Request Control for server-side sorting\n as defined in\n RFC 2891.\n\n The control's value has the following ASN.1 definition:\n  "
    },
    {
        "API": "javax.net.ssl.SSLEngine",
        "Code": "\n                   app data\n\n                |           ^\n                |     |     |\n                v     |     |\n           +----+-----|-----+----+\n           |          |          |\n           |       SSL|Engine    |\n   wrap()  |          |          |  unwrap()\n           | OUTBOUND | INBOUND  |\n           |          |          |\n           +----+-----|-----+----+\n                |     |     ^\n                |     |     |\n                v           |\n\n                   net data\n ",
        "Description": "\n At a high level, the SSLEngine appears thus:\n\n  \n (In the context of an SSLEngine, the term \"handshake\n data\" is taken to mean any data exchanged to establish and control a\n secure connection.  Handshake data includes the SSL/TLS messages\n \"alert\", \"change_cipher_spec,\" and \"handshake.\")\n "
    },
    {
        "API": "javax.net.ssl.SSLEngine",
        "Code": "\n   SSLEngineResult r = engine.unwrap(src, dst);\n   switch (r.getStatus()) {\n   BUFFER_OVERFLOW:\n       // Could attempt to drain the dst buffer of any already obtained\n       // data, but we'll just increase it to the size needed.\n       int appSize = engine.getSession().getApplicationBufferSize();\n       ByteBuffer b = ByteBuffer.allocate(appSize + dst.position());\n       dst.flip();\n       b.put(dst);\n       dst = b;\n       // retry the operation.\n       break;\n   BUFFER_UNDERFLOW:\n       int netSize = engine.getSession().getPacketBufferSize();\n       // Resize buffer if needed.\n       if (netSize > dst.capacity()) {\n           ByteBuffer b = ByteBuffer.allocate(netSize);\n           src.flip();\n           b.put(src);\n           src = b;\n       }\n       // Obtain more inbound network data for src,\n       // then retry the operation.\n       break;\n   // other cases: CLOSED, OK.\n   }\n ",
        "Description": "\n For example, unwrap() will return a SSLEngineResult.Status.BUFFER_OVERFLOW result if the engine\n determines that there is not enough destination buffer space available.\n Applications should call SSLSession.getApplicationBufferSize()\n and compare that value with the space available in the destination buffer,\n enlarging the buffer if necessary.  Similarly, if unwrap()\n were to return a SSLEngineResult.Status.BUFFER_UNDERFLOW, the\n application should call SSLSession.getPacketBufferSize() to ensure\n that the source buffer has enough room to hold a record (enlarging if\n necessary), and then obtain more inbound data.\n\n  \n Unlike SSLSocket, all methods of SSLEngine are\n non-blocking.  SSLEngine implementations may\n require the results of tasks that may take an extended period of\n time to complete, or may even block.  For example, a TrustManager\n may need to connect to a remote certificate validation service,\n or a KeyManager might need to prompt a user to determine which\n certificate to use as part of client authentication.  Additionally,\n creating cryptographic signatures and verifying them can be slow,\n seemingly blocking.\n "
    },
    {
        "API": "javax.net.ssl.SSLEngine",
        "Code": "\n              synchronized (outboundLock) {\n                  sslEngine.wrap(src, dst);\n                  outboundQueue.put(dst);\n              }\n      ",
        "Description": "\n      For example:\n\n       wrap()"
    },
    {
        "API": "javax.print.PrintService",
        "Code": "\n   DocFlavor flavor = DocFlavor.INPUT_STREAM.POSTSCRIPT;\n   PrintRequestAttributeSet aset = new HashPrintRequestAttributeSet();\n   aset.add(MediaSizeName.ISO_A4);\n   PrintService[] pservices =\n                 PrintServiceLookup.lookupPrintServices(flavor, aset);\n   if (pservices.length > 0) {\n       DocPrintJob pj = pservices[0].createPrintJob();\n       try {\n           FileInputStream fis = new FileInputStream(\"test.ps\");\n           Doc doc = new SimpleDoc(fis, flavor, null);\n           pj.print(doc, aset);\n        } catch (FileNotFoundException fe) {\n        } catch (PrintException e) {\n        }\n   }\n   ",
        "Description": "\n Example:\n    "
    },
    {
        "API": "javax.security.sasl.SaslClient",
        "Code": "\n SaslClient sc = Sasl.createSaslClient(mechanisms,\n     authorizationId, protocol, serverName, props, callbackHandler);\n",
        "Description": " "
    },
    {
        "API": "javax.security.sasl.SaslClient",
        "Code": "\n // Get initial response and send to server\n byte[] response = (sc.hasInitialResponse() ? sc.evaluateChallenge(new byte[0]) :\n     null);\n LdapResult res = ldap.sendBindRequest(dn, sc.getName(), response);\n while (!sc.isComplete() &&\n     (res.status == SASL_BIND_IN_PROGRESS || res.status == SUCCESS)) {\n     response = sc.evaluateChallenge(res.getBytes());\n     if (res.status == SUCCESS) {\n         // we're done; don't expect to send another BIND\n         if (response != null) {\n             throw new SaslException(\n                 \"Protocol error: attempting to send response after completion\");\n         }\n         break;\n     }\n     res = ldap.sendBindRequest(dn, sc.getName(), response);\n }\n if (sc.isComplete() && res.status == SUCCESS) {\n    String qop = (String) sc.getNegotiatedProperty(Sasl.QOP);\n    if (qop != null\n        && (qop.equalsIgnoreCase(\"auth-int\")\n            || qop.equalsIgnoreCase(\"auth-conf\"))) {\n\n      // Use SaslClient.wrap() and SaslClient.unwrap() for future\n      // communication with server\n      ldap.in = new SecureInputStream(sc, ldap.in);\n      ldap.out = new SecureOutputStream(sc, ldap.out);\n    }\n }\n",
        "Description": " "
    },
    {
        "API": "javax.security.sasl.SaslServer",
        "Code": "\n SaslServer ss = Sasl.createSaslServer(mechanism,\n     \"ldap\", myFQDN, props, callbackHandler);\n",
        "Description": " "
    },
    {
        "API": "javax.security.sasl.SaslServer",
        "Code": "\n while (!ss.isComplete()) {\n     try {\n         byte[] challenge = ss.evaluateResponse(response);\n         if (ss.isComplete()) {\n             status = ldap.sendBindResponse(mechanism, challenge, SUCCESS);\n         } else {\n             status = ldap.sendBindResponse(mechanism, challenge,\n                   SASL_BIND_IN_PROGRESS);\n             response = ldap.readBindRequest();\n         }\n     } catch (SaslException e) {\n          status = ldap.sendErrorResponse(e);\n          break;\n     }\n }\n if (ss.isComplete() && status == SUCCESS) {\n    String qop = (String) sc.getNegotiatedProperty(Sasl.QOP);\n    if (qop != null\n        && (qop.equalsIgnoreCase(\"auth-int\")\n            || qop.equalsIgnoreCase(\"auth-conf\"))) {\n\n      // Use SaslServer.wrap() and SaslServer.unwrap() for future\n      // communication with client\n      ldap.in = new SecureInputStream(ss, ldap.in);\n      ldap.out = new SecureOutputStream(ss, ldap.out);\n    }\n }\n",
        "Description": " "
    },
    {
        "API": "javax.sound.midi.MidiDevice",
        "Code": "\n MidiDevice device = ...;\n if ( ! (device instanceof Sequencer) && ! (device instanceof Synthesizer)) {\n   // we're now sure that device represents a MIDI port\n   // ...\n }\n ",
        "Description": "\nAfter an explicit open (either before or after implicit\n opens), the device will not be closed by implicit closing. The only\n way to close an explicitly opened device is an explicit close.\nAn explicit close always closes the device, even if it also has\n been opened implicitly. A subsequent implicit close has no further\n effect.\n \n A MidiDevice includes a MidiDevice.Info object\n to provide manufacturer information and so on."
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n     CachedRowSetImpl crs = new CachedRowSetImpl();\n ",
        "Description": "CachedRowSet CachedRowSet"
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n      java.util.Enumeration providers = SyncFactory.getRegisteredProviders();\n ",
        "Description": "\n A CachedRowSet object may use any\n SyncProvider implementation that has been registered\n with the SyncFactory singleton. An application\n can find out which SyncProvider implementations have been\n registered by calling the following line of code.\n  \n There are two ways for a CachedRowSet object to specify which\n SyncProvider object it will use.\n "
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n          CachedRowSetImpl crs2 = new CachedRowSetImpl(\n                                 \"com.fred.providers.HighAvailabilityProvider\");\n     ",
        "Description": "SyncProvider "
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n           crs.setSyncProvider(\"com.fred.providers.HighAvailabilityProvider\");\n      ",
        "Description": "CachedRowSet "
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n    while (crs.next()) {\n        String name = crs.getString(1);\n        int id = crs.getInt(2);\n        Clob comment = crs.getClob(3);\n        short dept = crs.getShort(4);\n        System.out.println(name + \"  \" + id + \"  \" + comment + \"  \" + dept);\n    }\n ",
        "Description": "SELECT * FROM TABLENAME \n    while (crs.next()) {\n        String name = crs.getString(\"NAME\");\n        int id = crs.getInt(\"ID\");\n        Clob comment = crs.getClob(\"COM\");\n        short dept = crs.getShort(\"DEPT\");\n        System.out.println(name + \"  \" + id + \"  \" + comment + \"  \" + dept);\n    }\n "
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n    while (crs.next()) {\n        String name = crs.getString(\"NAME\");\n        int id = crs.getInt(\"ID\");\n        Clob comment = crs.getClob(\"COM\");\n        short dept = crs.getShort(\"DEPT\");\n        System.out.println(name + \"  \" + id + \"  \" + comment + \"  \" + dept);\n    }\n ",
        "Description": "\n    while (crs.next()) {\n        String name = crs.getString(1);\n        int id = crs.getInt(2);\n        Clob comment = crs.getClob(3);\n        short dept = crs.getShort(4);\n        System.out.println(name + \"  \" + id + \"  \" + comment + \"  \" + dept);\n    }\n  2.1 Retrieving RowSetMetaData"
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n     RowSetMetaData rsmd = (RowSetMetaData)crs.getMetaData();\n     int count = rsmd.getColumnCount();\n     int type = rsmd.getColumnType(2);\n ",
        "Description": "jrs RowSetMetaData"
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n     crs.updateShort(3, 58);\n     crs.updateInt(4, 150000);\n     crs.updateRow();\n     crs.acceptChanges();\n ",
        "Description": "RowSet \n The next example demonstrates moving to the insert row, building a new\n row on the insert row, inserting it into the rowset, and then calling the\n method acceptChanges to add the new row to the underlying data\n source.  Note that as with the getter methods, the  updater methods may take\n either a column index or a column name to designate the column being acted upon.\n "
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n     crs.moveToInsertRow();\n     crs.updateString(\"Name\", \"Shakespeare\");\n     crs.updateInt(\"ID\", 10098347);\n     crs.updateShort(\"Age\", 58);\n     crs.updateInt(\"Sal\", 150000);\n     crs.insertRow();\n     crs.moveToCurrentRow();\n     crs.acceptChanges();\n ",
        "Description": "\n The next example demonstrates moving to the insert row, building a new\n row on the insert row, inserting it into the rowset, and then calling the\n method acceptChanges to add the new row to the underlying data\n source.  Note that as with the getter methods, the  updater methods may take\n either a column index or a column name to designate the column being acted upon.\n  \n NOTE: Where the insertRow() method inserts the contents of a\n CachedRowSet object's insert row is implementation-defined.\n The reference implementation for the CachedRowSet interface\n inserts a new row immediately following the current row, but it could be\n implemented to insert new rows in any number of other places.\n "
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n    crs.addRowSetListener(table);\n    crs.addRowSetListener(barGraph);\n ",
        "Description": "CachedRowSet CachedRowSet"
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n    ResultSet rs = stmt.executeQuery(\"SELECT * FROM EMPLOYEES\");\n    CachedRowSetImpl crs = new CachedRowSetImpl();\n    crs.populate(rs);\n ",
        "Description": "Statement \n The object crs now contains the data from the table\n EMPLOYEES, just as the object rs does.\n The difference is that the cursor for crs can be moved\n forward, backward, or to a particular row even if the cursor for\n rs can move only forward.  In addition, crs is\n updatable even if rs is not because by default, a\n CachedRowSet object is both scrollable and updatable.\n "
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n    crs.setCommand(\"SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS \" +\n                   \"WHERE CREDIT_LIMIT > ? AND REGION = ?\");\n  ",
        "Description": "\n The following code fragment illustrates how the CachedRowSet\n object crs might have its command property set.  Note that if a\n tool is used to set properties, this is the code that the tool would use.\n  \n The values that will be used to set the command's placeholder parameters are\n contained in the RowSet object's params field, which is a\n Vector object.\n The CachedRowSet class provides a set of setter\n methods for setting the elements in its params field.  The\n following code fragment demonstrates setting the two parameters in the\n query from the previous example.\n "
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n    crs.setInt(1, 5000);\n    crs.setString(2, \"West\");\n ",
        "Description": "\n The values that will be used to set the command's placeholder parameters are\n contained in the RowSet object's params field, which is a\n Vector object.\n The CachedRowSet class provides a set of setter\n methods for setting the elements in its params field.  The\n following code fragment demonstrates setting the two parameters in the\n query from the previous example.\n  \n The params field now contains two elements, each of which is\n an array two elements long.  The first element is the parameter number;\n the second is the value to be set.\n In this case, the first element of params is\n 1, 5000, and the second element is 2,\n \"West\".  When an application calls the method\n execute, it will in turn call on this RowSet object's reader,\n which will in turn invoke its readData method. As part of\n its implementation, readData will get the values in\n params and use them to set the command's placeholder\n parameters.\n The following code fragment gives an idea of how the reader\n does this, after obtaining the Connection object\n con.\n "
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n    PreparedStatement pstmt = con.prepareStatement(crs.getCommand());\n    reader.decodeParams();\n    // decodeParams figures out which setter methods to use and does something\n    // like the following:\n    //    for (i = 0; i < params.length; i++) {\n    //        pstmt.setObject(i + 1, params[i]);\n    //    }\n ",
        "Description": "\n The params field now contains two elements, each of which is\n an array two elements long.  The first element is the parameter number;\n the second is the value to be set.\n In this case, the first element of params is\n 1, 5000, and the second element is 2,\n \"West\".  When an application calls the method\n execute, it will in turn call on this RowSet object's reader,\n which will in turn invoke its readData method. As part of\n its implementation, readData will get the values in\n params and use them to set the command's placeholder\n parameters.\n The following code fragment gives an idea of how the reader\n does this, after obtaining the Connection object\n con.\n  \n At this point, the command for crs is the query \"SELECT\n FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS WHERE CREDIT_LIMIT > 5000\n AND REGION = \"West\".  After the readData method executes\n this command with the following line of code, it will have the data from\n rs with which to populate crs.\n "
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n     ResultSet rs = pstmt.executeQuery();\n ",
        "Description": "\n At this point, the command for crs is the query \"SELECT\n FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS WHERE CREDIT_LIMIT > 5000\n AND REGION = \"West\".  After the readData method executes\n this command with the following line of code, it will have the data from\n rs with which to populate crs.\n  \n The preceding code fragments give an idea of what goes on behind the\n scenes; they would not appear in an application, which would not invoke\n methods like readData and decodeParams.\n In contrast, the following code fragment shows what an application might do.\n It sets the rowset's command, sets the command's parameters, and executes\n the command. Simply by calling the execute method,\n crs populates itself with the requested data from the\n table CUSTOMERS.\n "
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n    crs.setCommand(\"SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS\" +\n                   \"WHERE CREDIT_LIMIT > ? AND REGION = ?\");\n    crs.setInt(1, 5000);\n    crs.setString(2, \"West\");\n    crs.execute();\n ",
        "Description": "\n The preceding code fragments give an idea of what goes on behind the\n scenes; they would not appear in an application, which would not invoke\n methods like readData and decodeParams.\n In contrast, the following code fragment shows what an application might do.\n It sets the rowset's command, sets the command's parameters, and executes\n the command. Simply by calling the execute method,\n crs populates itself with the requested data from the\n table CUSTOMERS.\n  10.0 Paging Data"
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n     CachedRowSet crs = new CachedRowSetImpl();\n     crs.setMaxRows(20);\n     crs.setPageSize(4);\n     crs.populate(rsHandle, 10);\n ",
        "Description": "\n After properties have been set,\n the CachedRowSet object must be populated with data\n using either the method populate or the method execute.\n The following lines of code demonstrate using the method populate.\n Note that this version of the method takes two parameters, a ResultSet\n handle and the row in the ResultSet object from which to start\n retrieving rows.\n  crs"
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n     CachedRowSet crs = new CachedRowSetImpl();\n     crs.setPageSize(5);\n     crs.execute(conHandle);\n ",
        "Description": "\n Note that there are two differences between the following code\n fragment and the previous one. First, the method setMaxRows is not\n called, so there is no limit set for the number of rows that crs may contain.\n (Remember that crs always has the overriding limit of how much data it can\n store in memory.) The second difference is that the you cannot pass the method\n execute the number of the row in the ResultSet object\n from which to start retrieving rows. This method always starts with the first row.\n  crs"
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n     CachedRowSet crs = CachedRowSetImpl();\n     crs.setPageSize(100);\n     crs.execute(conHandle);\n\n     while(crs.nextPage()) {\n         while(crs.next()) {\n             . . . // operate on chunks (of 100 rows each) in crs,\n                   // row by row\n         }\n     }\n ",
        "Description": "\n The method nextPage returns true as long as the current\n page is not the last page of rows and false when there are no more pages.\n It can therefore be used in a while loop to retrieve all of the pages,\n as is demonstrated in the following lines of code.\n  \n The CachedRowSet interface also defines the method previousPage.\n Just as the method nextPage is analogous to the ResultSet\n method next, the method previousPage is analogous to\n the ResultSet method previous.  Similar to the method\n nextPage, previousPage creates a CachedRowSet\n object containing the number of rows set as the page size.  So, for instance, the\n method previousPage could be used in a while loop at\n the end of the preceding code fragment to navigate back through the pages from the last\n page to the first page.\n The method previousPage is also similar to nextPage\n in that it can be used in a while\n loop, except that it returns true as long as there is another page\n preceding it and false when there are no more pages ahead of it.\n "
    },
    {
        "API": "javax.sql.rowset.CachedRowSet",
        "Code": "\n     crs.afterLast();\n     while(crs.previous())  {\n         . . . // navigate through the rows, last to first\n     {\n     while(crs.previousPage())  {\n         crs.afterLast();\n         while(crs.previous())  {\n             . . . // go from the last row to the first row of each page\n         }\n     }\n ",
        "Description": "\n The following code fragment assumes a continuation from the previous code fragment,\n meaning that the cursor for the tenth CachedRowSet object is on the\n last row.  The code moves the cursor to after the last row so that the first\n call to the method previous will put the cursor back on the last row.\n After going through all of the rows in the last page (the CachedRowSet\n object crs), the code then enters\n the while loop to get to the ninth page, go through the rows backwards,\n go to the eighth page, go through the rows backwards, and so on to the first row\n of the first page.\n\n  "
    },
    {
        "API": "javax.sql.rowset.Predicate",
        "Code": "\n    public class Range implements Predicate {\n\n       private int[] lo;\n       private int[] hi;\n       private int[] idx;\n\n       public Range(int[] lo, int[] hi, int[] idx) {\n          this.lo = lo;\n          this.hi = hi;\n          this.idx = idx;\n       }\n\n      public boolean evaluate(RowSet rs) {\n\n          // Check the present row determine if it lies\n          // within the filtering criteria.\n\n          for (int i = 0; i < idx.length; i++) {\n             int value;\n             try {\n                 value = (Integer) rs.getObject(idx[i]);\n             } catch (SQLException ex) {\n                 Logger.getLogger(Range.class.getName()).log(Level.SEVERE, null, ex);\n                 return false;\n             }\n\n             if (value < lo[i] && value > hi[i]) {\n                 // outside of filter constraints\n                 return false;\n             }\n         }\n         // Within filter constraints\n        return true;\n      }\n   }\n ",
        "Description": "\n A sample implementation would look something like this:\n  \n The example above implements a simple range predicate. Note, that\n implementations should but are not required to provide String\n and integer index based constructors to provide for JDBC RowSet Implementation\n applications that use both column identification conventions."
    },
    {
        "API": "javax.sql.rowset.BaseRowSet",
        "Code": "\n    crs.setCommand(\"SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS\" +\n                   \"WHERE CREDIT_LIMIT > ? AND REGION = ?\");\n ",
        "Description": "\n The following code fragment illustrates how the\n CachedRowSet\u2122\n object crs might have its command property set.  Note that if a\n tool is used to set properties, this is the code that the tool would use.\n  \n In this example, the values for CREDIT_LIMIT and\n REGION are placeholder parameters, which are indicated with a\n question mark (?).  The first question mark is placeholder parameter number\n 1, the second question mark is placeholder parameter number\n 2, and so on.  Any placeholder parameters must be set with\n values before the query can be executed. To set these\n placeholder parameters, the BaseRowSet class provides a set of setter\n methods, similar to those provided by the PreparedStatement\n interface, for setting values of each data type.  A RowSet object stores the\n parameter values internally, and its execute method uses them internally\n to set values for the placeholder parameters\n before it sends the command to the DBMS to be executed.\n "
    },
    {
        "API": "javax.sql.rowset.BaseRowSet",
        "Code": "\n    crs.setInt(1, 5000);\n    crs.setString(2, \"West\");\n ",
        "Description": "\n The following code fragment demonstrates\n setting the two parameters in the query from the previous example.\n  execute"
    },
    {
        "API": "javax.sql.rowset.BaseRowSet",
        "Code": "\n    \"SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS\" +\n                   \"WHERE CREDIT_LIMIT > 5000 AND REGION = 'West'\"\n ",
        "Description": "execute Array"
    },
    {
        "API": "javax.sql.rowset.BaseRowSet",
        "Code": "\n    crs.setMaxRows(500);\n ",
        "Description": "\n If other values are desired, an application must set the property values\n explicitly. For example, the following line of code sets the maximum number\n of rows for the CachedRowSet object crs to 500.\n  BaseRowSet"
    },
    {
        "API": "javax.swing.JTextField",
        "Code": "\n \u00a0   DocumentListener myListener = ??;\n \u00a0   JTextField myArea = ??;\n \u00a0   myArea.getDocument().addDocumentListener(myListener);\n ",
        "Description": "\n The java.awt.TextField could be monitored for changes by adding\n a TextListener for TextEvent's.\n In the JTextComponent based\n components, changes are broadcasted from the model via a\n DocumentEvent to DocumentListeners.\n The DocumentEvent gives\n the location of the change and the kind of change if desired.\n The code fragment might look something like:\n  \n The horizontal alignment of JTextField can be set to be left\n justified, leading justified, centered, right justified or trailing justified.\n Right/trailing justification is useful if the required size\n of the field text is smaller than the size allocated to it.\n This is determined by the setHorizontalAlignment\n and getHorizontalAlignment methods.  The default\n is to be leading justified.\n "
    },
    {
        "API": "javax.swing.JTextField",
        "Code": "\n\n\u00a0public class UpperCaseField extends JTextField {\n\u00a0\n\u00a0    public UpperCaseField(int cols) {\n\u00a0        super(cols);\n\u00a0    }\n\u00a0\n\u00a0    protected Document createDefaultModel() {\n\u00a0        return new UpperCaseDocument();\n\u00a0    }\n\u00a0\n\u00a0    static class UpperCaseDocument extends PlainDocument {\n\u00a0\n\u00a0        public void insertString(int offs, String str, AttributeSet a)\n\u00a0            throws BadLocationException {\n\u00a0\n\u00a0            if (str == null) {\n\u00a0                return;\n\u00a0            }\n\u00a0            char[] upper = str.toCharArray();\n\u00a0            for (int i = 0; i < upper.length; i++) {\n\u00a0                upper[i] = Character.toUpperCase(upper[i]);\n\u00a0            }\n\u00a0            super.insertString(offs, new String(upper), a);\n\u00a0        }\n\u00a0    }\n\u00a0}\n\n ",
        "Description": "\n Customized fields can easily be created by extending the model and\n changing the default model provided.  For example, the following piece\n of code will create a field that holds only upper case characters.  It\n will work even if text is pasted into from the clipboard or it is altered via\n programmatic changes.\n  \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n "
    },
    {
        "API": "javax.swing.plaf.nimbus.NimbusStyle",
        "Code": "\n     JButton.States = Enabled, Disabled, Toolbar\n     JButton[Enabled].backgroundPainter = somePainter\n     JButton[Disabled].background = BLUE\n     JButton[Toolbar].backgroundPainter = someOtherPaint\n ",
        "Description": "Sometimes, however, you need to have a custom state. For example, you\n want JButton to render differently if it's parent is a JToolbar. In Nimbus,\n you specify these custom states by including a special key in UIDefaults.\n The following UIDefaults entries define three states for this button: As you can see, the JButton.States entry lists the states\n that the JButton style will support. You then specify the settings for\n each state. If you do not specify the JButton.States entry,\n then the standard Synth states will be assumed. If you specify the entry\n but the list of states is empty or null, then the standard synth states\n will be assumed."
    },
    {
        "API": "javax.swing.plaf.nimbus.State",
        "Code": "\n     public final class IndeterminateState extends State<JProgressBar> {\n         public IndeterminateState() {\n             super(\"Indeterminate\");\n         }\n\n         @Override\n         protected boolean isInState(JProgressBar c) {\n             return c.isIndeterminate();\n         }\n     }\n ",
        "Description": "For example, the following might be an implementation of a custom\n \"Indeterminate\" state for JProgressBars: "
    },
    {
        "API": "javax.swing.text.html.StyleSheet",
        "Code": "\n \u00a0\n \u00a0 import java.util.*;\n \u00a0 import javax.swing.text.*;\n \u00a0 import javax.swing.text.html.*;\n \u00a0\n \u00a0 public class ShowStyles {\n \u00a0\n \u00a0     public static void main(String[] args) {\n \u00a0       HTMLEditorKit kit = new HTMLEditorKit();\n \u00a0       HTMLDocument doc = (HTMLDocument) kit.createDefaultDocument();\n \u00a0       StyleSheet styles = doc.getStyleSheet();\n \u00a0\n \u00a0       Enumeration rules = styles.getStyleNames();\n \u00a0       while (rules.hasMoreElements()) {\n \u00a0           String name = (String) rules.nextElement();\n \u00a0           Style rule = styles.getStyle(name);\n \u00a0           System.out.println(rule.toString());\n \u00a0       }\n \u00a0       System.exit(0);\n \u00a0     }\n \u00a0 }\n \u00a0\n ",
        "Description": "\n The rules are stored as named styles, and other information\n is stored to translate the context of an element to a\n rule quickly.  The following code fragment will display\n the named styles, and therefore the CSS rules contained.\n  \n The semantics for when a CSS style should overide visual attributes\n defined by an element are not well defined. For example, the html\n <body bgcolor=red> makes the body have a red\n background. But if the html file also contains the CSS rule\n body { background: blue } it becomes less clear as to\n what color the background of the body should be. The current\n implementation gives visual attributes defined in the element the\n highest precedence, that is they are always checked before any styles.\n Therefore, in the previous example the background would have a\n red color as the body element defines the background color to be red.\n "
    },
    {
        "API": "javax.xml.crypto.dsig.Manifest",
        "Code": "\n <element name=\"Manifest\" type=\"ds:ManifestType\"/>\n   <complexType name=\"ManifestType\">\n     <sequence>\n       <element ref=\"ds:Reference\" maxOccurs=\"unbounded\"/>\n     </sequence>\n     <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n   </complexType>\n ",
        "Description": "\n W3C Recommendation for XML-Signature Syntax and Processing Manifest"
    },
    {
        "API": "javax.xml.crypto.dsig.Manifest",
        "Code": "\n   XMLSignatureFactory factory = XMLSignatureFactory.getInstance(\"DOM\");\n   List references = Collections.singletonList(factory.newReference\n       (\"#reference-1\", DigestMethod.SHA1));\n   Manifest manifest = factory.newManifest(references, \"manifest-1\");\n ",
        "Description": "XMLSignatureFactory "
    },
    {
        "API": "javax.xml.crypto.dsig.SignatureProperties",
        "Code": "\n<element name=\"SignatureProperties\" type=\"ds:SignaturePropertiesType\"/>\n   <complexType name=\"SignaturePropertiesType\">\n     <sequence>\n       <element ref=\"ds:SignatureProperty\" maxOccurs=\"unbounded\"/>\n     </sequence>\n     <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n   </complexType>\n ",
        "Description": "\n W3C Recommendation for XML-Signature Syntax and Processing SignatureProperties"
    },
    {
        "API": "javax.xml.crypto.dsig.SignatureProperties",
        "Code": "\n   XMLSignatureFactory factory = XMLSignatureFactory.getInstance(\"DOM\");\n   SignatureProperties properties =\n      factory.newSignatureProperties(props, \"signature-properties-1\");\n ",
        "Description": "XMLSignatureFactory "
    },
    {
        "API": "javax.xml.crypto.dsig.SignatureProperty",
        "Code": "\n<element name=\"SignatureProperty\" type=\"ds:SignaturePropertyType\"/>\n   <complexType name=\"SignaturePropertyType\" mixed=\"true\">\n     <choice maxOccurs=\"unbounded\">\n       <any namespace=\"##other\" processContents=\"lax\"/>\n       <!-- (1,1) elements from (1, unbounded) namespaces -->\n     </choice>\n     <attribute name=\"Target\" type=\"anyURI\" use=\"required\"/>\n     <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n   </complexType>\n ",
        "Description": "\n W3C Recommendation for XML-Signature Syntax and Processing SignatureProperty"
    },
    {
        "API": "javax.xml.crypto.dsig.SignatureProperty",
        "Code": "\n   XMLSignatureFactory factory = XMLSignatureFactory.getInstance(\"DOM\");\n   SignatureProperty property = factory.newSignatureProperty\n      (Collections.singletonList(content), \"#Signature-1\", \"TimeStamp\");\n ",
        "Description": "XMLSignatureFactory "
    },
    {
        "API": "javax.xml.crypto.dsig.SignedInfo",
        "Code": "\n <element name=\"SignedInfo\" type=\"ds:SignedInfoType\"/>\n <complexType name=\"SignedInfoType\">\n   <sequence>\n     <element ref=\"ds:CanonicalizationMethod\"/>\n     <element ref=\"ds:SignatureMethod\"/>\n     <element ref=\"ds:Reference\" maxOccurs=\"unbounded\"/>\n   </sequence>\n   <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n </complexType>\n ",
        "Description": "\n W3C Recommendation for XML-Signature Syntax and Processing SignedInfo"
    },
    {
        "API": "javax.xml.crypto.dsig.XMLObject",
        "Code": "\n <element name=\"Object\" type=\"ds:ObjectType\"/>\n <complexType name=\"ObjectType\" mixed=\"true\">\n   <sequence minOccurs=\"0\" maxOccurs=\"unbounded\">\n     <any namespace=\"##any\" processContents=\"lax\"/>\n   </sequence>\n   <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n   <attribute name=\"MimeType\" type=\"string\" use=\"optional\"/>\n   <attribute name=\"Encoding\" type=\"anyURI\" use=\"optional\"/>\n </complexType>\n ",
        "Description": "XMLObject XMLObject"
    },
    {
        "API": "javax.xml.crypto.dsig.XMLObject",
        "Code": "\n   XMLSignatureFactory fac = XMLSignatureFactory.getInstance(\"DOM\");\n   List content = Collections.singletonList(fac.newManifest(references)));\n   XMLObject object = factory.newXMLObject(content, \"object-1\", null, null);\n ",
        "Description": "XMLSignatureFactory Note that this class is named XMLObject rather than\n Object to avoid naming clashes with the existing\n java.lang.Object class."
    },
    {
        "API": "javax.xml.crypto.dsig.XMLSignature",
        "Code": "\n <element name=\"Signature\" type=\"ds:SignatureType\"/>\n <complexType name=\"SignatureType\">\n    <sequence>\n      <element ref=\"ds:SignedInfo\"/>\n      <element ref=\"ds:SignatureValue\"/>\n      <element ref=\"ds:KeyInfo\" minOccurs=\"0\"/>\n      <element ref=\"ds:Object\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n    </sequence>\n    <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n </complexType>\n ",
        "Description": "\n W3C Recommendation for XML-Signature Syntax and Processing \n An XMLSignature instance may be created by invoking one of the\n newXMLSignature methods of the\n XMLSignatureFactory class.\n\n "
    },
    {
        "API": "javax.xml.crypto.dsig.spec.ExcC14NParameterSpec",
        "Code": "\n <schema xmlns=\"http://www.w3.org/2001/XMLSchema\"\n         xmlns:ec=\"http://www.w3.org/2001/10/xml-exc-c14n#\"\n         targetNamespace=\"http://www.w3.org/2001/10/xml-exc-c14n#\"\n         version=\"0.1\" elementFormDefault=\"qualified\">\n\n <element name=\"InclusiveNamespaces\" type=\"ec:InclusiveNamespaces\"/>\n <complexType name=\"InclusiveNamespaces\">\n   <attribute name=\"PrefixList\" type=\"xsd:string\"/>\n </complexType>\n </schema>\n ",
        "Description": "\n Exclusive XML Canonicalization (C14N) algorithm "
    },
    {
        "API": "javax.xml.crypto.dsig.spec.HMACParameterSpec",
        "Code": "\n <element name=\"HMACOutputLength\" minOccurs=\"0\" type=\"ds:HMACOutputLengthType\"/>\n <simpleType name=\"HMACOutputLengthType\">\n   <restriction base=\"integer\"/>\n </simpleType>\n ",
        "Description": "HMACOutputLength "
    },
    {
        "API": "javax.xml.crypto.dsig.spec.XPathFilterParameterSpec",
        "Code": "\n <element name=\"XPath\" type=\"string\"/>\n ",
        "Description": "Map "
    },
    {
        "API": "javax.xml.crypto.dsig.spec.XPathType",
        "Code": "\n <schema xmlns=\"http://www.w3.org/2001/XMLSchema\"\n         xmlns:xf=\"http://www.w3.org/2002/06/xmldsig-filter2\"\n         targetNamespace=\"http://www.w3.org/2002/06/xmldsig-filter2\"\n         version=\"0.1\" elementFormDefault=\"qualified\">\n\n <element name=\"XPath\"\n          type=\"xf:XPathType\"/>\n\n <complexType name=\"XPathType\">\n   <simpleContent>\n     <extension base=\"string\">\n       <attribute name=\"Filter\">\n         <simpleType>\n           <restriction base=\"string\">\n             <enumeration value=\"intersect\"/>\n             <enumeration value=\"subtract\"/>\n             <enumeration value=\"union\"/>\n           </restriction>\n         </simpleType>\n       </attribute>\n     </extension>\n   </simpleContent>\n </complexType>\n ",
        "Description": "\n W3C Recommendation for XML-Signature XPath Filter 2.0 "
    },
    {
        "API": "javax.xml.ws.WebServiceRef",
        "Code": "\n    public class MyClient {\n       @Addressing\n       @WebServiceRef(StockQuoteService.class)\n       private StockQuoteProvider stockQuoteProvider;\n       ...\n    }\n ",
        "Description": "\n For example, in the code below, the injected\n StockQuoteProvider proxy MUST\n have WS-Addressing enabled as specifed by the\n Addressing\n annotation.\n\n  \n If a JAX-WS implementation encounters an unsupported or unrecognized\n annotation annotated with the WebServiceFeatureAnnotation\n that is specified with WebServiceRef, an ERROR MUST be given."
    },
    {
        "API": "javax.xml.ws.WebServiceRefs",
        "Code": "\n    @WebServiceRefs({@WebServiceRef(name=\"service/stockquoteservice\", value=StockQuoteService.class),\n                     @WebServiceRef(name=\"service/stockquoteprovider\", type=StockQuoteProvider.class, value=StockQuoteService.class})\n    public class MyClient {\n        void init() {\n            Context ic = new InitialContext();\n            StockQuoteService service = (StockQuoteService) ic.lookup(\"java:comp/env/service/stockquoteservice\");\n            StockQuoteProvider port = (StockQuoteProvider) ic.lookup(\"java:comp/env/service/stockquoteprovider\");\n            ...\n       }\n       ...\n    }\n ",
        "Description": "\nExample: The StockQuoteProvider\n proxy instance, and the StockQuoteService service\n instance are injected using @WebServiceRefs.\n\n  "
    },
    {
        "API": "java.awt.AWTEventMulticaster",
        "Code": "\n public myComponent extends Component {\n     ActionListener actionListener = null;\n\n     public synchronized void addActionListener(ActionListener l) {\n         actionListener = AWTEventMulticaster.add(actionListener, l);\n     }\n     public synchronized void removeActionListener(ActionListener l) {\n         actionListener = AWTEventMulticaster.remove(actionListener, l);\n     }\n     public void processEvent(AWTEvent e) {\n         // when event occurs which causes \"action\" semantic\n         ActionListener listener = actionListener;\n         if (listener != null) {\n             listener.actionPerformed(new ActionEvent());\n         }\n     }\n }\n ",
        "Description": "\n The following example illustrates how to use this class:\n\n  add"
    },
    {
        "API": "java.awt.image.BufferStrategy",
        "Code": "\n Double buffering:\n\n                    ***********         ***********\n                    *         * ------> *         *\n [To display]  *         *\n    \n \n Here is an example of how buffer strategies can be created and used:\n \n\n // Check the capabilities of the GraphicsConfiguration\n ...\n\n // Create our component\n Window w = new Window(gc);\n\n // Show our window\n w.setVisible(true);\n\n // Create a general double-buffering strategy\n w.createBufferStrategy(2);\n BufferStrategy strategy = w.getBufferStrategy();\n\n // Main loop\n while (!done) {\n     // Prepare for rendering the next frame\n     // ...\n\n     // Render single frame\n     do {\n         // The following loop ensures that the contents of the drawing buffer\n         // are consistent in case the underlying surface was recreated\n         do {\n             // Get a new graphics context every time through the loop\n             // to make sure the strategy is validated\n             Graphics graphics = strategy.getDrawGraphics();\n\n             // Render to graphics\n             // ...\n\n             // Dispose the graphics\n             graphics.dispose();\n\n             // Repeat the rendering if the drawing buffer contents\n             // were restored\n         } while (strategy.contentsRestored());\n\n         // Display the buffer\n         strategy.show();\n\n         // Repeat the rendering if the drawing buffer was lost\n     } while (strategy.contentsLost());\n }\n\n // Dispose the window\n w.setVisible(false);\n w.dispose();\n ",
        "Description": "\n "
    },
    {
        "API": "java.awt.image.BufferStrategy",
        "Code": "\n\n // Check the capabilities of the GraphicsConfiguration\n ...\n\n // Create our component\n Window w = new Window(gc);\n\n // Show our window\n w.setVisible(true);\n\n // Create a general double-buffering strategy\n w.createBufferStrategy(2);\n BufferStrategy strategy = w.getBufferStrategy();\n\n // Main loop\n while (!done) {\n     // Prepare for rendering the next frame\n     // ...\n\n     // Render single frame\n     do {\n         // The following loop ensures that the contents of the drawing buffer\n         // are consistent in case the underlying surface was recreated\n         do {\n             // Get a new graphics context every time through the loop\n             // to make sure the strategy is validated\n             Graphics graphics = strategy.getDrawGraphics();\n\n             // Render to graphics\n             // ...\n\n             // Dispose the graphics\n             graphics.dispose();\n\n             // Repeat the rendering if the drawing buffer contents\n             // were restored\n         } while (strategy.contentsRestored());\n\n         // Display the buffer\n         strategy.show();\n\n         // Repeat the rendering if the drawing buffer was lost\n     } while (strategy.contentsLost());\n }\n\n // Dispose the window\n w.setVisible(false);\n w.dispose();\n ",
        "Description": "\n Here is an example of how buffer strategies can be created and used:\n  "
    },
    {
        "API": "java.security.cert.X509CRL",
        "Code": "\n CertificateList  ::=  SEQUENCE  {\n     tbsCertList          TBSCertList,\n     signatureAlgorithm   AlgorithmIdentifier,\n     signature            BIT STRING  }\n ",
        "Description": "\n The X.509 v2 CRL format is described below in ASN.1:\n  \n More information can be found in\n RFC 3280: Internet X.509\n Public Key Infrastructure Certificate and CRL Profile.\n "
    },
    {
        "API": "java.security.cert.X509CRL",
        "Code": "\n TBSCertList  ::=  SEQUENCE  {\n     version                 Version OPTIONAL,\n                             -- if present, must be v2\n     signature               AlgorithmIdentifier,\n     issuer                  Name,\n     thisUpdate              ChoiceOfTime,\n     nextUpdate              ChoiceOfTime OPTIONAL,\n     revokedCertificates     SEQUENCE OF SEQUENCE  {\n         userCertificate         CertificateSerialNumber,\n         revocationDate          ChoiceOfTime,\n         crlEntryExtensions      Extensions OPTIONAL\n                                 -- if present, must be v2\n         }  OPTIONAL,\n     crlExtensions           [0]  EXPLICIT Extensions OPTIONAL\n                                  -- if present, must be v2\n     }\n ",
        "Description": "\n The ASN.1 definition of tbsCertList is:\n  \n CRLs are instantiated using a certificate factory. The following is an\n example of how to instantiate an X.509 CRL:\n "
    },
    {
        "API": "java.security.cert.X509CRL",
        "Code": "\n InputStream inStream = null;\n try {\n     inStream = new FileInputStream(\"fileName-of-crl\");\n     CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n     X509CRL crl = (X509CRL)cf.generateCRL(inStream);\n } finally {\n     if (inStream != null) {\n         inStream.close();\n     }\n }\n ",
        "Description": "\n CRLs are instantiated using a certificate factory. The following is an\n example of how to instantiate an X.509 CRL:\n  "
    },
    {
        "API": "java.util.SimpleTimeZone",
        "Code": "\n      // Base GMT offset: -8:00\n      // DST starts:      at 2:00am in standard time\n      //                  on the first Sunday in April\n      // DST ends:        at 2:00am in daylight time\n      //                  on the last Sunday in October\n      // Save:            1 hour\n      SimpleTimeZone(-28800000,\n                     \"America/Los_Angeles\",\n                     Calendar.APRIL, 1, -Calendar.SUNDAY,\n                     7200000,\n                     Calendar.OCTOBER, -1, Calendar.SUNDAY,\n                     7200000,\n                     3600000)\n\n      // Base GMT offset: +1:00\n      // DST starts:      at 1:00am in UTC time\n      //                  on the last Sunday in March\n      // DST ends:        at 1:00am in UTC time\n      //                  on the last Sunday in October\n      // Save:            1 hour\n      SimpleTimeZone(3600000,\n                     \"Europe/Paris\",\n                     Calendar.MARCH, -1, Calendar.SUNDAY,\n                     3600000, SimpleTimeZone.UTC_TIME,\n                     Calendar.OCTOBER, -1, Calendar.SUNDAY,\n                     3600000, SimpleTimeZone.UTC_TIME,\n                     3600000)\n ",
        "Description": "\n The following are examples of parameters for constructing time zone objects.\n  setStartRule"
    },
    {
        "API": "java.util.concurrent.Exchanger",
        "Code": "class FillAndEmpty {\n   Exchanger<DataBuffer> exchanger = new Exchanger<DataBuffer>();\n   DataBuffer initialEmptyBuffer = ... a made-up type\n   DataBuffer initialFullBuffer = ...\n\n   class FillingLoop implements Runnable {\n     public void run() {\n       DataBuffer currentBuffer = initialEmptyBuffer;\n       try {\n         while (currentBuffer != null) {\n           addToBuffer(currentBuffer);\n           if (currentBuffer.isFull())\n             currentBuffer = exchanger.exchange(currentBuffer);\n         }\n       } catch (InterruptedException ex) { ... handle ... }\n     }\n   }\n\n   class EmptyingLoop implements Runnable {\n     public void run() {\n       DataBuffer currentBuffer = initialFullBuffer;\n       try {\n         while (currentBuffer != null) {\n           takeFromBuffer(currentBuffer);\n           if (currentBuffer.isEmpty())\n             currentBuffer = exchanger.exchange(currentBuffer);\n         }\n       } catch (InterruptedException ex) { ... handle ...}\n     }\n   }\n\n   void start() {\n     new Thread(new FillingLoop()).start();\n     new Thread(new EmptyingLoop()).start();\n   }\n }\n ",
        "Description": "Sample Usage:\n Here are the highlights of a class that uses an Exchanger\n to swap buffers between threads so that the thread filling the\n buffer gets a freshly emptied one when it needs it, handing off the\n filled one to the thread emptying the buffer.\n  Memory consistency effects: For each pair of threads that\n successfully exchange objects via an Exchanger, actions\n prior to the exchange() in each thread\n happen-before\n those subsequent to a return from the corresponding exchange()\n in the other thread."
    },
    {
        "API": "java.util.concurrent.locks.LockSupport",
        "Code": "while (!canProceed()) { ... LockSupport.park(this); }",
        "Description": "These methods are designed to be used as tools for creating\n higher-level synchronization utilities, and are not in themselves\n useful for most concurrency control applications.  The park\n method is designed for use only in constructions of the form:\n  canProceed"
    },
    {
        "API": "java.util.concurrent.locks.LockSupport",
        "Code": "class FIFOMutex {\n   private final AtomicBoolean locked = new AtomicBoolean(false);\n   private final Queue<Thread> waiters\n     = new ConcurrentLinkedQueue<Thread>();\n\n   public void lock() {\n     boolean wasInterrupted = false;\n     Thread current = Thread.currentThread();\n     waiters.add(current);\n\n     // Block while not first in queue or cannot acquire lock\n     while (waiters.peek() != current ||\n            !locked.compareAndSet(false, true)) {\n        LockSupport.park(this);\n        if (Thread.interrupted()) // ignore interrupts while waiting\n          wasInterrupted = true;\n     }\n\n     waiters.remove();\n     if (wasInterrupted)          // reassert interrupt status on exit\n        current.interrupt();\n   }\n\n   public void unlock() {\n     locked.set(false);\n     LockSupport.unpark(waiters.peek());\n   }\n }",
        "Description": "Sample Usage. Here is a sketch of a first-in-first-out\n non-reentrant lock class:\n  "
    },
    {
        "API": "java.util.concurrent.locks.ReentrantReadWriteLock",
        "Code": " class CachedData {\n   Object data;\n   volatile boolean cacheValid;\n   final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n\n   void processCachedData() {\n     rwl.readLock().lock();\n     if (!cacheValid) {\n        // Must release read lock before acquiring write lock\n        rwl.readLock().unlock();\n        rwl.writeLock().lock();\n        try {\n          // Recheck state because another thread might have\n          // acquired write lock and changed state before we did.\n          if (!cacheValid) {\n            data = ...\n            cacheValid = true;\n          }\n          // Downgrade by acquiring read lock before releasing write lock\n          rwl.readLock().lock();\n        } finally {\n          rwl.writeLock().unlock(); // Unlock write, still hold read\n        }\n     }\n\n     try {\n       use(data);\n     } finally {\n       rwl.readLock().unlock();\n     }\n   }\n }",
        "Description": "Sample usages. Here is a code sketch showing how to perform\n lock downgrading after updating a cache (exception handling is\n particularly tricky when handling multiple locks in a non-nested\n fashion):\n\n  class RWDictionary {\n    private final Map<String, Data> m = new TreeMap<String, Data>();\n    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n    private final Lock r = rwl.readLock();\n    private final Lock w = rwl.writeLock();\n\n    public Data get(String key) {\n        r.lock();\n        try { return m.get(key); }\n        finally { r.unlock(); }\n    }\n    public String[] allKeys() {\n        r.lock();\n        try { return m.keySet().toArray(); }\n        finally { r.unlock(); }\n    }\n    public Data put(String key, Data value) {\n        w.lock();\n        try { return m.put(key, value); }\n        finally { w.unlock(); }\n    }\n    public void clear() {\n        w.lock();\n        try { m.clear(); }\n        finally { w.unlock(); }\n    }\n }"
    },
    {
        "API": "java.util.concurrent.locks.ReentrantReadWriteLock",
        "Code": "class RWDictionary {\n    private final Map<String, Data> m = new TreeMap<String, Data>();\n    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n    private final Lock r = rwl.readLock();\n    private final Lock w = rwl.writeLock();\n\n    public Data get(String key) {\n        r.lock();\n        try { return m.get(key); }\n        finally { r.unlock(); }\n    }\n    public String[] allKeys() {\n        r.lock();\n        try { return m.keySet().toArray(); }\n        finally { r.unlock(); }\n    }\n    public Data put(String key, Data value) {\n        w.lock();\n        try { return m.put(key, value); }\n        finally { w.unlock(); }\n    }\n    public void clear() {\n        w.lock();\n        try { m.clear(); }\n        finally { w.unlock(); }\n    }\n }",
        "Description": " class CachedData {\n   Object data;\n   volatile boolean cacheValid;\n   final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n\n   void processCachedData() {\n     rwl.readLock().lock();\n     if (!cacheValid) {\n        // Must release read lock before acquiring write lock\n        rwl.readLock().unlock();\n        rwl.writeLock().lock();\n        try {\n          // Recheck state because another thread might have\n          // acquired write lock and changed state before we did.\n          if (!cacheValid) {\n            data = ...\n            cacheValid = true;\n          }\n          // Downgrade by acquiring read lock before releasing write lock\n          rwl.readLock().lock();\n        } finally {\n          rwl.writeLock().unlock(); // Unlock write, still hold read\n        }\n     }\n\n     try {\n       use(data);\n     } finally {\n       rwl.readLock().unlock();\n     }\n   }\n } Implementation Notes"
    },
    {
        "API": "javax.swing.JTextField",
        "Code": "\n \u00a0   DocumentListener myListener = ??;\n \u00a0   JTextField myArea = ??;\n \u00a0   myArea.getDocument().addDocumentListener(myListener);\n ",
        "Description": "\n The java.awt.TextField could be monitored for changes by adding\n a TextListener for TextEvent's.\n In the JTextComponent based\n components, changes are broadcasted from the model via a\n DocumentEvent to DocumentListeners.\n The DocumentEvent gives\n the location of the change and the kind of change if desired.\n The code fragment might look something like:\n  \n The horizontal alignment of JTextField can be set to be left\n justified, leading justified, centered, right justified or trailing justified.\n Right/trailing justification is useful if the required size\n of the field text is smaller than the size allocated to it.\n This is determined by the setHorizontalAlignment\n and getHorizontalAlignment methods.  The default\n is to be leading justified.\n "
    },
    {
        "API": "javax.swing.JTextField",
        "Code": "\n\n\u00a0public class UpperCaseField extends JTextField {\n\u00a0\n\u00a0    public UpperCaseField(int cols) {\n\u00a0        super(cols);\n\u00a0    }\n\u00a0\n\u00a0    protected Document createDefaultModel() {\n\u00a0        return new UpperCaseDocument();\n\u00a0    }\n\u00a0\n\u00a0    static class UpperCaseDocument extends PlainDocument {\n\u00a0\n\u00a0        public void insertString(int offs, String str, AttributeSet a)\n\u00a0            throws BadLocationException {\n\u00a0\n\u00a0            if (str == null) {\n\u00a0                return;\n\u00a0            }\n\u00a0            char[] upper = str.toCharArray();\n\u00a0            for (int i = 0; i < upper.length; i++) {\n\u00a0                upper[i] = Character.toUpperCase(upper[i]);\n\u00a0            }\n\u00a0            super.insertString(offs, new String(upper), a);\n\u00a0        }\n\u00a0    }\n\u00a0}\n\n ",
        "Description": "\n Customized fields can easily be created by extending the model and\n changing the default model provided.  For example, the following piece\n of code will create a field that holds only upper case characters.  It\n will work even if text is pasted into from the clipboard or it is altered via\n programmatic changes.\n  \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n "
    },
    {
        "API": "javax.swing.plaf.nimbus.NimbusStyle",
        "Code": "\n     JButton.States = Enabled, Disabled, Toolbar\n     JButton[Enabled].backgroundPainter = somePainter\n     JButton[Disabled].background = BLUE\n     JButton[Toolbar].backgroundPainter = someOtherPaint\n ",
        "Description": "Sometimes, however, you need to have a custom state. For example, you\n want JButton to render differently if it's parent is a JToolbar. In Nimbus,\n you specify these custom states by including a special key in UIDefaults.\n The following UIDefaults entries define three states for this button: As you can see, the JButton.States entry lists the states\n that the JButton style will support. You then specify the settings for\n each state. If you do not specify the JButton.States entry,\n then the standard Synth states will be assumed. If you specify the entry\n but the list of states is empty or null, then the standard synth states\n will be assumed."
    },
    {
        "API": "javax.swing.plaf.nimbus.State",
        "Code": "\n     public final class IndeterminateState extends State<JProgressBar> {\n         public IndeterminateState() {\n             super(\"Indeterminate\");\n         }\n\n         @Override\n         protected boolean isInState(JProgressBar c) {\n             return c.isIndeterminate();\n         }\n     }\n ",
        "Description": "For example, the following might be an implementation of a custom\n \"Indeterminate\" state for JProgressBars: "
    },
    {
        "API": "javax.xml.crypto.dsig.Manifest",
        "Code": "\n <element name=\"Manifest\" type=\"ds:ManifestType\"/>\n   <complexType name=\"ManifestType\">\n     <sequence>\n       <element ref=\"ds:Reference\" maxOccurs=\"unbounded\"/>\n     </sequence>\n     <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n   </complexType>\n ",
        "Description": "\n W3C Recommendation for XML-Signature Syntax and Processing Manifest"
    },
    {
        "API": "javax.xml.crypto.dsig.Manifest",
        "Code": "\n   XMLSignatureFactory factory = XMLSignatureFactory.getInstance(\"DOM\");\n   List references = Collections.singletonList(factory.newReference\n       (\"#reference-1\", DigestMethod.SHA1));\n   Manifest manifest = factory.newManifest(references, \"manifest-1\");\n ",
        "Description": "XMLSignatureFactory "
    },
    {
        "API": "javax.xml.crypto.dsig.SignatureProperties",
        "Code": "\n<element name=\"SignatureProperties\" type=\"ds:SignaturePropertiesType\"/>\n   <complexType name=\"SignaturePropertiesType\">\n     <sequence>\n       <element ref=\"ds:SignatureProperty\" maxOccurs=\"unbounded\"/>\n     </sequence>\n     <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n   </complexType>\n ",
        "Description": "\n W3C Recommendation for XML-Signature Syntax and Processing SignatureProperties"
    },
    {
        "API": "javax.xml.crypto.dsig.SignatureProperties",
        "Code": "\n   XMLSignatureFactory factory = XMLSignatureFactory.getInstance(\"DOM\");\n   SignatureProperties properties =\n      factory.newSignatureProperties(props, \"signature-properties-1\");\n ",
        "Description": "XMLSignatureFactory "
    },
    {
        "API": "javax.xml.crypto.dsig.SignatureProperty",
        "Code": "\n<element name=\"SignatureProperty\" type=\"ds:SignaturePropertyType\"/>\n   <complexType name=\"SignaturePropertyType\" mixed=\"true\">\n     <choice maxOccurs=\"unbounded\">\n       <any namespace=\"##other\" processContents=\"lax\"/>\n       <!-- (1,1) elements from (1, unbounded) namespaces -->\n     </choice>\n     <attribute name=\"Target\" type=\"anyURI\" use=\"required\"/>\n     <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n   </complexType>\n ",
        "Description": "\n W3C Recommendation for XML-Signature Syntax and Processing SignatureProperty"
    },
    {
        "API": "javax.xml.crypto.dsig.SignatureProperty",
        "Code": "\n   XMLSignatureFactory factory = XMLSignatureFactory.getInstance(\"DOM\");\n   SignatureProperty property = factory.newSignatureProperty\n      (Collections.singletonList(content), \"#Signature-1\", \"TimeStamp\");\n ",
        "Description": "XMLSignatureFactory "
    },
    {
        "API": "javax.xml.crypto.dsig.SignedInfo",
        "Code": "\n <element name=\"SignedInfo\" type=\"ds:SignedInfoType\"/>\n <complexType name=\"SignedInfoType\">\n   <sequence>\n     <element ref=\"ds:CanonicalizationMethod\"/>\n     <element ref=\"ds:SignatureMethod\"/>\n     <element ref=\"ds:Reference\" maxOccurs=\"unbounded\"/>\n   </sequence>\n   <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n </complexType>\n ",
        "Description": "\n W3C Recommendation for XML-Signature Syntax and Processing SignedInfo"
    },
    {
        "API": "javax.xml.crypto.dsig.XMLObject",
        "Code": "\n <element name=\"Object\" type=\"ds:ObjectType\"/>\n <complexType name=\"ObjectType\" mixed=\"true\">\n   <sequence minOccurs=\"0\" maxOccurs=\"unbounded\">\n     <any namespace=\"##any\" processContents=\"lax\"/>\n   </sequence>\n   <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n   <attribute name=\"MimeType\" type=\"string\" use=\"optional\"/>\n   <attribute name=\"Encoding\" type=\"anyURI\" use=\"optional\"/>\n </complexType>\n ",
        "Description": "XMLObject XMLObject"
    },
    {
        "API": "javax.xml.crypto.dsig.XMLObject",
        "Code": "\n   XMLSignatureFactory fac = XMLSignatureFactory.getInstance(\"DOM\");\n   List content = Collections.singletonList(fac.newManifest(references)));\n   XMLObject object = factory.newXMLObject(content, \"object-1\", null, null);\n ",
        "Description": "XMLSignatureFactory Note that this class is named XMLObject rather than\n Object to avoid naming clashes with the existing\n java.lang.Object class."
    },
    {
        "API": "javax.xml.crypto.dsig.XMLSignature",
        "Code": "\n <element name=\"Signature\" type=\"ds:SignatureType\"/>\n <complexType name=\"SignatureType\">\n    <sequence>\n      <element ref=\"ds:SignedInfo\"/>\n      <element ref=\"ds:SignatureValue\"/>\n      <element ref=\"ds:KeyInfo\" minOccurs=\"0\"/>\n      <element ref=\"ds:Object\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n    </sequence>\n    <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n </complexType>\n ",
        "Description": "\n W3C Recommendation for XML-Signature Syntax and Processing \n An XMLSignature instance may be created by invoking one of the\n newXMLSignature methods of the\n XMLSignatureFactory class.\n\n "
    },
    {
        "API": "javax.xml.crypto.dsig.spec.ExcC14NParameterSpec",
        "Code": "\n <schema xmlns=\"http://www.w3.org/2001/XMLSchema\"\n         xmlns:ec=\"http://www.w3.org/2001/10/xml-exc-c14n#\"\n         targetNamespace=\"http://www.w3.org/2001/10/xml-exc-c14n#\"\n         version=\"0.1\" elementFormDefault=\"qualified\">\n\n <element name=\"InclusiveNamespaces\" type=\"ec:InclusiveNamespaces\"/>\n <complexType name=\"InclusiveNamespaces\">\n   <attribute name=\"PrefixList\" type=\"xsd:string\"/>\n </complexType>\n </schema>\n ",
        "Description": "\n Exclusive XML Canonicalization (C14N) algorithm "
    },
    {
        "API": "javax.xml.crypto.dsig.spec.HMACParameterSpec",
        "Code": "\n <element name=\"HMACOutputLength\" minOccurs=\"0\" type=\"ds:HMACOutputLengthType\"/>\n <simpleType name=\"HMACOutputLengthType\">\n   <restriction base=\"integer\"/>\n </simpleType>\n ",
        "Description": "HMACOutputLength "
    },
    {
        "API": "javax.xml.crypto.dsig.spec.XPathFilterParameterSpec",
        "Code": "\n <element name=\"XPath\" type=\"string\"/>\n ",
        "Description": "Map "
    },
    {
        "API": "javax.xml.crypto.dsig.spec.XPathType",
        "Code": "\n <schema xmlns=\"http://www.w3.org/2001/XMLSchema\"\n         xmlns:xf=\"http://www.w3.org/2002/06/xmldsig-filter2\"\n         targetNamespace=\"http://www.w3.org/2002/06/xmldsig-filter2\"\n         version=\"0.1\" elementFormDefault=\"qualified\">\n\n <element name=\"XPath\"\n          type=\"xf:XPathType\"/>\n\n <complexType name=\"XPathType\">\n   <simpleContent>\n     <extension base=\"string\">\n       <attribute name=\"Filter\">\n         <simpleType>\n           <restriction base=\"string\">\n             <enumeration value=\"intersect\"/>\n             <enumeration value=\"subtract\"/>\n             <enumeration value=\"union\"/>\n           </restriction>\n         </simpleType>\n       </attribute>\n     </extension>\n   </simpleContent>\n </complexType>\n ",
        "Description": "\n W3C Recommendation for XML-Signature XPath Filter 2.0 "
    },
    {
        "API": "javax.xml.ws.WebServiceRef",
        "Code": "\n    public class MyClient {\n       @Addressing\n       @WebServiceRef(StockQuoteService.class)\n       private StockQuoteProvider stockQuoteProvider;\n       ...\n    }\n ",
        "Description": "\n For example, in the code below, the injected\n StockQuoteProvider proxy MUST\n have WS-Addressing enabled as specifed by the\n Addressing\n annotation.\n\n  \n If a JAX-WS implementation encounters an unsupported or unrecognized\n annotation annotated with the WebServiceFeatureAnnotation\n that is specified with WebServiceRef, an ERROR MUST be given."
    },
    {
        "API": "javax.xml.ws.WebServiceRefs",
        "Code": "\n    @WebServiceRefs({@WebServiceRef(name=\"service/stockquoteservice\", value=StockQuoteService.class),\n                     @WebServiceRef(name=\"service/stockquoteprovider\", type=StockQuoteProvider.class, value=StockQuoteService.class})\n    public class MyClient {\n        void init() {\n            Context ic = new InitialContext();\n            StockQuoteService service = (StockQuoteService) ic.lookup(\"java:comp/env/service/stockquoteservice\");\n            StockQuoteProvider port = (StockQuoteProvider) ic.lookup(\"java:comp/env/service/stockquoteprovider\");\n            ...\n       }\n       ...\n    }\n ",
        "Description": "\nExample: The StockQuoteProvider\n proxy instance, and the StockQuoteService service\n instance are injected using @WebServiceRefs.\n\n  "
    },
    {
        "API": "java.awt.GraphicsDevice.setDisplayMode(java.awt.DisplayMode)",
        "Code": "\n Frame frame;\n DisplayMode newDisplayMode;\n GraphicsDevice gd;\n // create a Frame, select desired DisplayMode from the list of modes\n // returned by gd.getDisplayModes() ...\n\n if (gd.isFullScreenSupported()) {\n     gd.setFullScreenWindow(frame);\n } else {\n    // proceed in non-full-screen mode\n    frame.setSize(...);\n    frame.setLocation(...);\n    frame.setVisible(true);\n }\n\n if (gd.isDisplayChangeSupported()) {\n     gd.setDisplayMode(newDisplayMode);\n }\n ",
        "Description": "\n Example code:\n  "
    },
    {
        "API": "java.awt.image.ImageProducer.requestTopDownLeftRightResend(java.awt.image.ImageConsumer)",
        "Code": "\n  ic.setHints(TOPDOWNLEFTRIGHT | < otherhints >);\n  ic.setPixels(...);      // As many times as needed\n  ic.imageComplete();\n ",
        "Description": "ImageConsumer "
    },
    {
        "API": "java.awt.image.WritableRaster.setRect(java.awt.image.Raster)",
        "Code": "\n       Raster srcRaster;\n       WritableRaster dstRaster;\n       for (int b = 0; b < srcRaster.getNumBands(); b++) {\n           dstRaster.setSample(x, y, b, srcRaster.getSample(x, y, b));\n       }\n ",
        "Description": "\n If all samples of both source and destination Rasters are of\n integral type and less than or equal to 32 bits in size, then calling\n this method is equivalent to executing the following code for all\n x,y addresses valid in both Rasters.\n  \n When copying a float or double source to an integral type destination,\n each source sample is cast to the destination type.  When copying an\n integral type source to a float or double destination, the source\n is first converted to a 32-bit int (if necessary), using the above\n rules for integral types, and then the int is cast to float or\n double.\n "
    },
    {
        "API": "java.awt.print.PrinterJob.lookupStreamPrintServices(java.lang.String)",
        "Code": "\n FileOutputStream outstream;\n StreamPrintService psPrinter;\n String psMimeType = \"application/postscript\";\n PrinterJob pj = PrinterJob.getPrinterJob();\n\n StreamPrintServiceFactory[] factories =\n     PrinterJob.lookupStreamPrintServices(psMimeType);\n if (factories.length > 0) {\n     try {\n         outstream = new File(\"out.ps\");\n         psPrinter =  factories[0].getPrintService(outstream);\n         // psPrinter can now be set as the service on a PrinterJob\n         pj.setPrintService(psPrinter)\n     } catch (Exception e) {\n         e.printStackTrace();\n     }\n }\n ",
        "Description": " PrinterJob"
    },
    {
        "API": "java.beans.PropertyChangeSupport.getPropertyChangeListeners()",
        "Code": "\n PropertyChangeListener[] listeners = bean.getPropertyChangeListeners();\n for (int i = 0; i < listeners.length; i++) {\n   if (listeners[i] instanceof PropertyChangeListenerProxy) {\n     PropertyChangeListenerProxy proxy =\n                    (PropertyChangeListenerProxy)listeners[i];\n     if (proxy.getPropertyName().equals(\"foo\")) {\n       // proxy is a PropertyChangeListener which was associated\n       // with the property named \"foo\"\n     }\n   }\n }\n ",
        "Description": "\n If some listeners have been added with a named property, then\n the returned array will be a mixture of PropertyChangeListeners\n and PropertyChangeListenerProxys. If the calling\n method is interested in distinguishing the listeners then it must\n test each element to see if it's a\n PropertyChangeListenerProxy, perform the cast, and examine\n the parameter.\n\n  "
    },
    {
        "API": "java.beans.VetoableChangeSupport.getVetoableChangeListeners()",
        "Code": "\n VetoableChangeListener[] listeners = bean.getVetoableChangeListeners();\n for (int i = 0; i < listeners.length; i++) {\n        if (listeners[i] instanceof VetoableChangeListenerProxy) {\n     VetoableChangeListenerProxy proxy =\n                    (VetoableChangeListenerProxy)listeners[i];\n     if (proxy.getPropertyName().equals(\"foo\")) {\n       // proxy is a VetoableChangeListener which was associated\n       // with the property named \"foo\"\n     }\n   }\n }\n ",
        "Description": "\n If some listeners have been added with a named property, then\n the returned array will be a mixture of VetoableChangeListeners\n and VetoableChangeListenerProxys. If the calling\n method is interested in distinguishing the listeners then it must\n test each element to see if it's a\n VetoableChangeListenerProxy, perform the cast, and examine\n the parameter.\n\n  "
    },
    {
        "API": "java.io.DataInput.readChar()",
        "Code": " (char)((a << 8) | (b & 0xff))\n ",
        "Description": "b writeChar"
    },
    {
        "API": "java.io.DataInput.readInt()",
        "Code": "\n (((a & 0xff) << 24) | ((b & 0xff) << 16) |\n  ((c & 0xff) <<  8) | (d & 0xff))\n ",
        "Description": "a-d writeInt"
    },
    {
        "API": "java.io.DataInput.readLong()",
        "Code": "\n (((long)(a & 0xff) << 56) |\n  ((long)(b & 0xff) << 48) |\n  ((long)(c & 0xff) << 40) |\n  ((long)(d & 0xff) << 32) |\n  ((long)(e & 0xff) << 24) |\n  ((long)(f & 0xff) << 16) |\n  ((long)(g & 0xff) <<  8) |\n  ((long)(h & 0xff)))\n ",
        "Description": "a-h \n This method is suitable\n for reading bytes written by the writeLong\n method of interface DataOutput."
    },
    {
        "API": "java.io.DataInput.readShort()",
        "Code": " (short)((a << 8) | (b & 0xff))\n ",
        "Description": "b writeShort"
    },
    {
        "API": "java.io.DataInput.readUnsignedShort()",
        "Code": " (((a & 0xff) << 8) | (b & 0xff))\n ",
        "Description": "b writeShort"
    },
    {
        "API": "java.io.DataInput.readUTF()",
        "Code": " (char)(((a & 0x1F) << 6) | (b & 0x3F))\n ",
        "Description": "\n If the first byte\n of a group matches the bit pattern 110xxxxx,\n then the group consists of that byte a\n and a second byte b. If there\n is no byte b (because byte\n a was the last of the bytes\n to be read), or if byte b does\n not match the bit pattern 10xxxxxx,\n then a UTFDataFormatException\n is thrown. Otherwise, the group is converted\n to the character:\n  1110xxxx"
    },
    {
        "API": "java.io.DataInput.readUTF()",
        "Code": "\n (char)(((a & 0x0F) << 12) | ((b & 0x3F) << 6) | (c & 0x3F))\n ",
        "Description": "UTFDataFormatException 1111xxxx"
    },
    {
        "API": "java.io.DataOutput.writeChar(int)",
        "Code": "\n (byte)(0xff & (v >> 8))\n (byte)(0xff & v)\n ",
        "Description": "char \n The bytes written by this method may be\n read by the readChar method\n of interface DataInput , which\n will then return a char equal\n to (char)v."
    },
    {
        "API": "java.io.DataOutput.writeInt(int)",
        "Code": "\n (byte)(0xff & (v >> 24))\n (byte)(0xff & (v >> 16))\n (byte)(0xff & (v >>  8))\n (byte)(0xff & v)\n ",
        "Description": "int \n The bytes written by this method may be read\n by the readInt method of interface\n DataInput , which will then\n return an int equal to v."
    },
    {
        "API": "java.io.DataOutput.writeLong(long)",
        "Code": "\n (byte)(0xff & (v >> 56))\n (byte)(0xff & (v >> 48))\n (byte)(0xff & (v >> 40))\n (byte)(0xff & (v >> 32))\n (byte)(0xff & (v >> 24))\n (byte)(0xff & (v >> 16))\n (byte)(0xff & (v >>  8))\n (byte)(0xff & v)\n ",
        "Description": "long \n The bytes written by this method may be\n read by the readLong method\n of interface DataInput , which\n will then return a long equal\n to v."
    },
    {
        "API": "java.io.DataOutput.writeShort(int)",
        "Code": "\n (byte)(0xff & (v >> 8))\n (byte)(0xff & v)\n ",
        "Description": " \n The bytes written by this method may be\n read by the readShort method\n of interface DataInput , which\n will then return a short equal\n to (short)v."
    },
    {
        "API": "java.io.DataOutput.writeUTF(java.lang.String)",
        "Code": "(byte)c ",
        "Description": "\n If a character c\n is in the range \\u0001 through\n \\u007f, it is represented\n by one byte:\n  \n If a character c is \\u0000\n or is in the range \\u0080\n through \\u07ff, then it is\n represented by two bytes, to be written\n in the order shown: "
    },
    {
        "API": "java.io.DataOutput.writeUTF(java.lang.String)",
        "Code": "\n (byte)(0xc0 | (0x1f & (c >> 6)))\n (byte)(0x80 | (0x3f & c))\n ",
        "Description": "\n If a character c is \\u0000\n or is in the range \\u0080\n through \\u07ff, then it is\n represented by two bytes, to be written\n in the order shown:   If a character\n c is in the range \\u0800\n through uffff, then it is\n represented by three bytes, to be written\n in the order shown: "
    },
    {
        "API": "java.io.DataOutput.writeUTF(java.lang.String)",
        "Code": "\n (byte)(0xe0 | (0x0f & (c >> 12)))\n (byte)(0x80 | (0x3f & (c >>  6)))\n (byte)(0x80 | (0x3f & c))\n ",
        "Description": " If a character\n c is in the range \\u0800\n through uffff, then it is\n represented by three bytes, to be written\n in the order shown:   First,\n the total number of bytes needed to represent\n all the characters of s is\n calculated. If this number is larger than\n 65535, then a UTFDataFormatException\n is thrown. Otherwise, this length is written\n to the output stream in exactly the manner\n of the writeShort method;\n after this, the one-, two-, or three-byte\n representation of each character in the\n string s is written."
    },
    {
        "API": "java.io.InputStream.read(byte[])",
        "Code": " read(b, 0, b.length) ",
        "Description": " The read(b) method for class InputStream\n has the same effect as:  "
    },
    {
        "API": "java.io.PipedInputStream.connect(java.io.PipedOutputStream)",
        "Code": "snk.connect(src) ",
        "Description": "\n If src is an\n unconnected piped output stream and snk\n is an unconnected piped input stream, they\n may be connected by either the call:\n\n  \n or the call:\n\n "
    },
    {
        "API": "java.io.PipedInputStream.connect(java.io.PipedOutputStream)",
        "Code": "src.connect(snk) ",
        "Description": "\n or the call:\n\n  \n The two calls have the same effect."
    },
    {
        "API": "java.io.PipedReader.connect(java.io.PipedWriter)",
        "Code": "snk.connect(src) ",
        "Description": "\n If src is an\n unconnected piped writer and snk\n is an unconnected piped reader, they\n may be connected by either the call:\n\n  \n or the call:\n\n "
    },
    {
        "API": "java.io.PipedReader.connect(java.io.PipedWriter)",
        "Code": "src.connect(snk) ",
        "Description": "\n or the call:\n\n  \n The two calls have the same effect."
    },
    {
        "API": "java.lang.Character.isSurrogatePair(char,char)",
        "Code": "\n isHighSurrogate(high) && isLowSurrogate(low)\n ",
        "Description": " "
    },
    {
        "API": "java.lang.Double.longBitsToDouble(long)",
        "Code": "\n int s = ((bits >> 63) == 0) ? 1 : -1;\n int e = (int)((bits >> 52) & 0x7ffL);\n long m = (e == 0) ?\n                 (bits & 0xfffffffffffffL) << 1 :\n                 (bits & 0xfffffffffffffL) | 0x10000000000000L;\n ",
        "Description": " "
    },
    {
        "API": "java.lang.Double.valueOf(java.lang.String)",
        "Code": "\n  final String Digits     = \"(\\\\p{Digit}+)\";\n  final String HexDigits  = \"(\\\\p{XDigit}+)\";\n  // an exponent is 'e' or 'E' followed by an optionally\n  // signed decimal integer.\n  final String Exp        = \"[eE][+-]?\"+Digits;\n  final String fpRegex    =\n      (\"[\\\\x00-\\\\x20]*\"+  // Optional leading \"whitespace\"\n       \"[+-]?(\" + // Optional sign character\n       \"NaN|\" +           // \"NaN\" string\n       \"Infinity|\" +      // \"Infinity\" string\n\n       // A decimal floating-point string representing a finite positive\n       // number without a leading sign has at most five basic pieces:\n       // Digits . Digits ExponentPart FloatTypeSuffix\n       //\n       // Since this method allows integer-only strings as input\n       // in addition to strings of floating-point literals, the\n       // two sub-patterns below are simplifications of the grammar\n       // productions from section 3.10.2 of\n       // The Java Language Specification.\n\n       // Digits ._opt Digits_opt ExponentPart_opt FloatTypeSuffix_opt\n       \"(((\"+Digits+\"(\\\\.)?(\"+Digits+\"?)(\"+Exp+\")?)|\"+\n\n       // . Digits ExponentPart_opt FloatTypeSuffix_opt\n       \"(\\\\.(\"+Digits+\")(\"+Exp+\")?)|\"+\n\n       // Hexadecimal strings\n       \"((\" +\n        // 0[xX] HexDigits ._opt BinaryExponent FloatTypeSuffix_opt\n        \"(0[xX]\" + HexDigits + \"(\\\\.)?)|\" +\n\n        // 0[xX] HexDigits_opt . HexDigits BinaryExponent FloatTypeSuffix_opt\n        \"(0[xX]\" + HexDigits + \"?(\\\\.)\" + HexDigits + \")\" +\n\n        \")[pP][+-]?\" + Digits + \"))\" +\n       \"[fFdD]?))\" +\n       \"[\\\\x00-\\\\x20]*\");// Optional trailing \"whitespace\"\n\n  if (Pattern.matches(fpRegex, myString))\n      Double.valueOf(myString); // Will not throw NumberFormatException\n  else {\n      // Perform suitable alternative action\n  }\n ",
        "Description": "To avoid calling this method on an invalid string and having\n a NumberFormatException be thrown, the regular\n expression below can be used to screen the input string:\n\n  "
    },
    {
        "API": "java.lang.Float.intBitsToFloat(int)",
        "Code": "\n int s = ((bits >> 31) == 0) ? 1 : -1;\n int e = ((bits >> 23) & 0xff);\n int m = (e == 0) ?\n                 (bits & 0x7fffff) << 1 :\n                 (bits & 0x7fffff) | 0x800000;\n ",
        "Description": " "
    },
    {
        "API": "java.lang.StackTraceElement.equals(java.lang.Object)",
        "Code": "\n     equals(a.getFileName(), b.getFileName()) &&\n     a.getLineNumber() == b.getLineNumber()) &&\n     equals(a.getClassName(), b.getClassName()) &&\n     equals(a.getMethodName(), b.getMethodName())\n ",
        "Description": "b equals"
    },
    {
        "API": "java.lang.String.join(java.lang.CharSequence,java.lang.CharSequence...)",
        "Code": "\n     String message = String.join(\"-\", \"Java\", \"is\", \"cool\");\n     // message returned is: \"Java-is-cool\"\n ",
        "Description": " "
    },
    {
        "API": "java.lang.String.join(java.lang.CharSequence,java.lang.Iterable<? extends java.lang.CharSequence>)",
        "Code": "\n     List<String> strings = new LinkedList<>();\n     strings.add(\"Java\");strings.add(\"is\");\n     strings.add(\"cool\");\n     String message = String.join(\" \", strings);\n     //message returned is: \"Java is cool\"\n\n     Set<String> strings = new LinkedHashSet<>();\n     strings.add(\"Java\"); strings.add(\"is\");\n     strings.add(\"very\"); strings.add(\"cool\");\n     String message = String.join(\"-\", strings);\n     //message returned is: \"Java-is-very-cool\"\n ",
        "Description": " "
    },
    {
        "API": "java.lang.StringBuffer.getChars(int,int,char[],int)",
        "Code": "\n dstbegin + (srcEnd-srcBegin) - 1\n ",
        "Description": "dstBegin "
    },
    {
        "API": "java.lang.StringBuffer.indexOf(java.lang.String)",
        "Code": "\n this.toString().startsWith(str, <i>k</i>)\n ",
        "Description": "k true"
    },
    {
        "API": "java.lang.StringBuffer.indexOf(java.lang.String,int)",
        "Code": "\n     k >= Math.min(fromIndex, this.length()) &&\n                   this.toString().startsWith(str, k)\n ",
        "Description": "k k"
    },
    {
        "API": "java.lang.StringBuffer.lastIndexOf(java.lang.String)",
        "Code": "\n this.toString().startsWith(str, k)\n ",
        "Description": "k "
    },
    {
        "API": "java.lang.StringBuffer.lastIndexOf(java.lang.String,int)",
        "Code": "\n     k <= Math.min(fromIndex, this.length()) &&\n                   this.toString().startsWith(str, k)\n ",
        "Description": "k k"
    },
    {
        "API": "java.lang.StringBuffer.subSequence(int,int)",
        "Code": "\n sb.subSequence(begin,&nbsp;end)",
        "Description": " An invocation of this method of the form\n\n  \n sb.substring(begin,&nbsp;end)"
    },
    {
        "API": "java.lang.StringBuffer.subSequence(int,int)",
        "Code": "\n sb.substring(begin,&nbsp;end)",
        "Description": "\n sb.subSequence(begin,&nbsp;end) CharSequence"
    },
    {
        "API": "java.lang.StringBuilder.getChars(int,int,char[],int)",
        "Code": "\n dstbegin + (srcEnd-srcBegin) - 1\n ",
        "Description": "dstBegin "
    },
    {
        "API": "java.lang.StringBuilder.indexOf(java.lang.String)",
        "Code": "\n this.toString().startsWith(str, <i>k</i>)\n ",
        "Description": "k true"
    },
    {
        "API": "java.lang.StringBuilder.indexOf(java.lang.String,int)",
        "Code": "\n     k >= Math.min(fromIndex, this.length()) &&\n                   this.toString().startsWith(str, k)\n ",
        "Description": "k k"
    },
    {
        "API": "java.lang.StringBuilder.lastIndexOf(java.lang.String)",
        "Code": "\n this.toString().startsWith(str, k)\n ",
        "Description": "k "
    },
    {
        "API": "java.lang.StringBuilder.lastIndexOf(java.lang.String,int)",
        "Code": "\n     k <= Math.min(fromIndex, this.length()) &&\n                   this.toString().startsWith(str, k)\n ",
        "Description": "k k"
    },
    {
        "API": "java.lang.StringBuilder.subSequence(int,int)",
        "Code": "\n sb.subSequence(begin,&nbsp;end)",
        "Description": " An invocation of this method of the form\n\n  \n sb.substring(begin,&nbsp;end)"
    },
    {
        "API": "java.lang.StringBuilder.subSequence(int,int)",
        "Code": "\n sb.substring(begin,&nbsp;end)",
        "Description": "\n sb.subSequence(begin,&nbsp;end) CharSequence"
    },
    {
        "API": "java.lang.instrument.Instrumentation.setNativeMethodPrefix(java.lang.instrument.ClassFileTransformer,java.lang.String)",
        "Code": "\n   native boolean foo(int x);",
        "Description": "\n Since native methods cannot be directly instrumented\n (they have no bytecodes), they must be wrapped with\n a non-native method which can be instrumented.\n For example, if we had:\n  \n We could transform the class file (with the\n ClassFileTransformer during the initial definition\n of the class) so that this becomes:\n "
    },
    {
        "API": "java.lang.instrument.Instrumentation.setNativeMethodPrefix(java.lang.instrument.ClassFileTransformer,java.lang.String)",
        "Code": "\n   boolean foo(int x) {\n     ... record entry to foo ...\n     return wrapped_foo(x);\n   }\n\n   native boolean wrapped_foo(int x);",
        "Description": "\n We could transform the class file (with the\n ClassFileTransformer during the initial definition\n of the class) so that this becomes:\n  \n Where foo becomes a wrapper for the actual native\n method with the appended prefix \"wrapped_\".  Note that\n \"wrapped_\" would be a poor choice of prefix since it\n might conceivably form the name of an existing method\n thus something like \"$$$MyAgentWrapped$$$_\" would be\n better but would make these examples less readable.\n "
    },
    {
        "API": "java.lang.instrument.Instrumentation.setNativeMethodPrefix(java.lang.instrument.ClassFileTransformer,java.lang.String)",
        "Code": "\n   Java_somePackage_someClass_foo(JNIEnv* env, jint x)",
        "Description": "\n The wrapper will allow data to be collected on the native\n method call, but now the problem becomes linking up the\n wrapped method with the native implementation.\n That is, the method wrapped_foo needs to be\n resolved to the native implementation of foo,\n which might be:\n  \n This function allows the prefix to be specified and the\n proper resolution to occur.\n Specifically, when the standard resolution fails, the\n resolution is retried taking the prefix into consideration.\n There are two ways that resolution occurs, explicit\n resolution with the JNI function RegisterNatives\n and the normal automatic resolution.  For\n RegisterNatives, the JVM will attempt this\n association:\n "
    },
    {
        "API": "java.lang.instrument.Instrumentation.setNativeMethodPrefix(java.lang.instrument.ClassFileTransformer,java.lang.String)",
        "Code": "\n   method(foo) -> nativeImplementation(foo)\n ",
        "Description": "\n This function allows the prefix to be specified and the\n proper resolution to occur.\n Specifically, when the standard resolution fails, the\n resolution is retried taking the prefix into consideration.\n There are two ways that resolution occurs, explicit\n resolution with the JNI function RegisterNatives\n and the normal automatic resolution.  For\n RegisterNatives, the JVM will attempt this\n association:\n  \n When this fails, the resolution will be retried with\n the specified prefix prepended to the method name,\n yielding the correct resolution:\n "
    },
    {
        "API": "java.lang.instrument.Instrumentation.setNativeMethodPrefix(java.lang.instrument.ClassFileTransformer,java.lang.String)",
        "Code": "\n   method(wrapped_foo) -> nativeImplementation(foo)\n ",
        "Description": "\n When this fails, the resolution will be retried with\n the specified prefix prepended to the method name,\n yielding the correct resolution:\n  \n For automatic resolution, the JVM will attempt:\n "
    },
    {
        "API": "java.lang.instrument.Instrumentation.setNativeMethodPrefix(java.lang.instrument.ClassFileTransformer,java.lang.String)",
        "Code": "\n   method(wrapped_foo) -> nativeImplementation(wrapped_foo)\n ",
        "Description": "\n For automatic resolution, the JVM will attempt:\n  \n When this fails, the resolution will be retried with\n the specified prefix deleted from the implementation name,\n yielding the correct resolution:\n "
    },
    {
        "API": "java.lang.instrument.Instrumentation.setNativeMethodPrefix(java.lang.instrument.ClassFileTransformer,java.lang.String)",
        "Code": "\n   method(wrapped_foo) -> nativeImplementation(foo)\n ",
        "Description": "\n When this fails, the resolution will be retried with\n the specified prefix deleted from the implementation name,\n yielding the correct resolution:\n  \n Note that since the prefix is only used when standard\n resolution fails, native methods can be wrapped selectively.\n "
    },
    {
        "API": "java.lang.invoke.CallSite.dynamicInvoker()",
        "Code": "\n MethodHandle getTarget, invoker, result;\n getTarget = MethodHandles.publicLookup().bind(this, \"getTarget\", MethodType.methodType(MethodHandle.class));\n invoker = MethodHandles.exactInvoker(this.type());\n result = MethodHandles.foldArguments(invoker, getTarget)\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.LambdaMetafactory.altMetafactory(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.Object...)",
        "Code": "\n  CallSite altMetafactory(MethodHandles.Lookup caller,\n                          String invokedName,\n                          MethodType invokedType,\n                          Object... args)\n ",
        "Description": "The argument list for this method includes three fixed parameters,\n corresponding to the parameters automatically stacked by the VM for the\n bootstrap method in an invokedynamic invocation, and an Object[]\n parameter that contains additional parameters.  The declared argument\n list for this method is:\n\n  but it behaves as if the argument list is as follows:\n\n "
    },
    {
        "API": "java.lang.invoke.LambdaMetafactory.altMetafactory(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.Object...)",
        "Code": "\n  CallSite altMetafactory(MethodHandles.Lookup caller,\n                          String invokedName,\n                          MethodType invokedType,\n                          MethodType samMethodType,\n                          MethodHandle implMethod,\n                          MethodType instantiatedMethodType,\n                          int flags,\n                          int markerInterfaceCount,  // IF flags has MARKERS set\n                          Class... markerInterfaces, // IF flags has MARKERS set\n                          int bridgeCount,           // IF flags has BRIDGES set\n                          MethodType... bridges      // IF flags has BRIDGES set\n                          )\n ",
        "Description": "but it behaves as if the argument list is as follows:\n\n  Arguments that appear in the argument list for\n metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)\n have the same specification as in that method.  The additional arguments\n are interpreted as follows:\n "
    },
    {
        "API": "java.lang.invoke.MethodHandle.asCollector(java.lang.Class<?>,int)",
        "Code": "\nMethodHandle deepToString = publicLookup()\n  .findStatic(Arrays.class, \"deepToString\", methodType(String.class, Object[].class));\nassertEquals(\"[won]\",   (String) deepToString.invokeExact(new Object[]{\"won\"}));\nMethodHandle ts1 = deepToString.asCollector(Object[].class, 1);\nassertEquals(methodType(String.class, Object.class), ts1.type());\n//assertEquals(\"[won]\", (String) ts1.invokeExact(         new Object[]{\"won\"})); //FAIL\nassertEquals(\"[[won]]\", (String) ts1.invokeExact((Object) new Object[]{\"won\"}));\n// arrayType can be a subtype of Object[]\nMethodHandle ts2 = deepToString.asCollector(String[].class, 2);\nassertEquals(methodType(String.class, String.class, String.class), ts2.type());\nassertEquals(\"[two, too]\", (String) ts2.invokeExact(\"two\", \"too\"));\nMethodHandle ts0 = deepToString.asCollector(Object[].class, 0);\nassertEquals(\"[]\", (String) ts0.invokeExact());\n// collectors can be nested, Lisp-style\nMethodHandle ts22 = deepToString.asCollector(Object[].class, 3).asCollector(String[].class, 2);\nassertEquals(\"[A, B, [C, D]]\", ((String) ts22.invokeExact((Object)'A', (Object)\"B\", \"C\", \"D\")));\n// arrayType can be any primitive array type\nMethodHandle bytesToString = publicLookup()\n  .findStatic(Arrays.class, \"toString\", methodType(String.class, byte[].class))\n  .asCollector(byte[].class, 3);\nassertEquals(\"[1, 2, 3]\", (String) bytesToString.invokeExact((byte)1, (byte)2, (byte)3));\nMethodHandle longsToString = publicLookup()\n  .findStatic(Arrays.class, \"toString\", methodType(String.class, long[].class))\n  .asCollector(long[].class, 1);\nassertEquals(\"[123]\", (String) longsToString.invokeExact((long)123));\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandle.asFixedArity()",
        "Code": "\nMethodHandle asListVar = publicLookup()\n  .findStatic(Arrays.class, \"asList\", methodType(List.class, Object[].class))\n  .asVarargsCollector(Object[].class);\nMethodHandle asListFix = asListVar.asFixedArity();\nassertEquals(\"[1]\", asListVar.invoke(1).toString());\nException caught = null;\ntry { asListFix.invoke((Object)1); }\ncatch (Exception ex) { caught = ex; }\nassert(caught instanceof ClassCastException);\nassertEquals(\"[two, too]\", asListVar.invoke(\"two\", \"too\").toString());\ntry { asListFix.invoke(\"two\", \"too\"); }\ncatch (Exception ex) { caught = ex; }\nassert(caught instanceof WrongMethodTypeException);\nObject[] argv = { \"three\", \"thee\", \"tee\" };\nassertEquals(\"[three, thee, tee]\", asListVar.invoke(argv).toString());\nassertEquals(\"[three, thee, tee]\", asListFix.invoke(argv).toString());\nassertEquals(1, ((List) asListVar.invoke((Object)argv)).size());\nassertEquals(\"[three, thee, tee]\", asListFix.invoke((Object)argv).toString());\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandle.asSpreader(java.lang.Class<?>,int)",
        "Code": "\nMethodHandle equals = publicLookup()\n  .findVirtual(String.class, \"equals\", methodType(boolean.class, Object.class));\nassert( (boolean) equals.invokeExact(\"me\", (Object)\"me\"));\nassert(!(boolean) equals.invokeExact(\"me\", (Object)\"thee\"));\n// spread both arguments from a 2-array:\nMethodHandle eq2 = equals.asSpreader(Object[].class, 2);\nassert( (boolean) eq2.invokeExact(new Object[]{ \"me\", \"me\" }));\nassert(!(boolean) eq2.invokeExact(new Object[]{ \"me\", \"thee\" }));\n// try to spread from anything but a 2-array:\nfor (int n = 0; n <= 10; n++) {\n  Object[] badArityArgs = (n == 2 ? null : new Object[n]);\n  try { assert((boolean) eq2.invokeExact(badArityArgs) && false); }\n  catch (IllegalArgumentException ex) { } // OK\n}\n// spread both arguments from a String array:\nMethodHandle eq2s = equals.asSpreader(String[].class, 2);\nassert( (boolean) eq2s.invokeExact(new String[]{ \"me\", \"me\" }));\nassert(!(boolean) eq2s.invokeExact(new String[]{ \"me\", \"thee\" }));\n// spread second arguments from a 1-array:\nMethodHandle eq1 = equals.asSpreader(Object[].class, 1);\nassert( (boolean) eq1.invokeExact(\"me\", new Object[]{ \"me\" }));\nassert(!(boolean) eq1.invokeExact(\"me\", new Object[]{ \"thee\" }));\n// spread no arguments from a 0-array or null:\nMethodHandle eq0 = equals.asSpreader(Object[].class, 0);\nassert( (boolean) eq0.invokeExact(\"me\", (Object)\"me\", new Object[0]));\nassert(!(boolean) eq0.invokeExact(\"me\", (Object)\"thee\", (Object[])null));\n// asSpreader and asCollector are approximate inverses:\nfor (int n = 0; n <= 2; n++) {\n    for (Class<?> a : new Class<?>[]{Object[].class, String[].class, CharSequence[].class}) {\n        MethodHandle equals2 = equals.asSpreader(a, n).asCollector(a, n);\n        assert( (boolean) equals2.invokeWithArguments(\"me\", \"me\"));\n        assert(!(boolean) equals2.invokeWithArguments(\"me\", \"thee\"));\n    }\n}\nMethodHandle caToString = publicLookup()\n  .findStatic(Arrays.class, \"toString\", methodType(String.class, char[].class));\nassertEquals(\"[A, B, C]\", (String) caToString.invokeExact(\"ABC\".toCharArray()));\nMethodHandle caString3 = caToString.asCollector(char[].class, 3);\nassertEquals(\"[A, B, C]\", (String) caString3.invokeExact('A', 'B', 'C'));\nMethodHandle caToString2 = caString3.asSpreader(char[].class, 2);\nassertEquals(\"[A, B, C]\", (String) caToString2.invokeExact('A', \"BC\".toCharArray()));\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandle.asVarargsCollector(java.lang.Class<?>)",
        "Code": "\nMethodHandle deepToString = publicLookup()\n  .findStatic(Arrays.class, \"deepToString\", methodType(String.class, Object[].class));\nMethodHandle ts1 = deepToString.asVarargsCollector(Object[].class);\nassertEquals(\"[won]\",   (String) ts1.invokeExact(    new Object[]{\"won\"}));\nassertEquals(\"[won]\",   (String) ts1.invoke(         new Object[]{\"won\"}));\nassertEquals(\"[won]\",   (String) ts1.invoke(                      \"won\" ));\nassertEquals(\"[[won]]\", (String) ts1.invoke((Object) new Object[]{\"won\"}));\n// findStatic of Arrays.asList(...) produces a variable arity method handle:\nMethodHandle asList = publicLookup()\n  .findStatic(Arrays.class, \"asList\", methodType(List.class, Object[].class));\nassertEquals(methodType(List.class, Object[].class), asList.type());\nassert(asList.isVarargsCollector());\nassertEquals(\"[]\", asList.invoke().toString());\nassertEquals(\"[1]\", asList.invoke(1).toString());\nassertEquals(\"[two, too]\", asList.invoke(\"two\", \"too\").toString());\nString[] argv = { \"three\", \"thee\", \"tee\" };\nassertEquals(\"[three, thee, tee]\", asList.invoke(argv).toString());\nassertEquals(\"[three, thee, tee]\", asList.invoke((Object[])argv).toString());\nList ls = (List) asList.invoke((Object)argv);\nassertEquals(1, ls.size());\nassertEquals(\"[three, thee, tee]\", Arrays.toString((Object[])ls.get(0)));\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandle.invokeWithArguments(java.lang.Object...)",
        "Code": "\n MethodHandle invoker = MethodHandles.spreadInvoker(this.type(), 0);\n Object result = invoker.invokeExact(this, arguments);\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandle.invokeWithArguments(java.util.List<?>)",
        "Code": "\n   invokeWithArguments(arguments.toArray()\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandle.toString()",
        "Code": "\n \"MethodHandle\" + type().toString()\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.catchException(java.lang.invoke.MethodHandle,java.lang.Class<? extends java.lang.Throwable>,java.lang.invoke.MethodHandle)",
        "Code": "\n T target(A..., B...);\n T handler(ExType, A...);\n T adapter(A... a, B... b) {\n   try {\n     return target(a..., b...);\n   } catch (ExType ex) {\n     return handler(ex, a...);\n   }\n }\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.collectArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle)",
        "Code": "\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle deepToString = publicLookup()\n  .findStatic(Arrays.class, \"deepToString\", methodType(String.class, Object[].class));\n\nMethodHandle ts1 = deepToString.asCollector(String[].class, 1);\nassertEquals(\"[strange]\", (String) ts1.invokeExact(\"strange\"));\n\nMethodHandle ts2 = deepToString.asCollector(String[].class, 2);\nassertEquals(\"[up, down]\", (String) ts2.invokeExact(\"up\", \"down\"));\n\nMethodHandle ts3 = deepToString.asCollector(String[].class, 3);\nMethodHandle ts3_ts2 = collectArguments(ts3, 1, ts2);\nassertEquals(\"[top, [up, down], strange]\",\n             (String) ts3_ts2.invokeExact(\"top\", \"up\", \"down\", \"strange\"));\n\nMethodHandle ts3_ts2_ts1 = collectArguments(ts3_ts2, 3, ts1);\nassertEquals(\"[top, [up, down], [strange]]\",\n             (String) ts3_ts2_ts1.invokeExact(\"top\", \"up\", \"down\", \"strange\"));\n\nMethodHandle ts3_ts2_ts3 = collectArguments(ts3_ts2, 1, ts3);\nassertEquals(\"[top, [[up, down, strange], charm], bottom]\",\n             (String) ts3_ts2_ts3.invokeExact(\"top\", \"up\", \"down\", \"strange\", \"charm\", \"bottom\"));\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.collectArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle)",
        "Code": "\n T target(A...,V,C...);\n V filter(B...);\n T adapter(A... a,B... b,C... c) {\n   V v = filter(b...);\n   return target(a...,v,c...);\n }\n // and if the filter has no arguments:\n T target2(A...,V,C...);\n V filter2();\n T adapter2(A... a,C... c) {\n   V v = filter2();\n   return target2(a...,v,c...);\n }\n // and if the filter has a void return:\n T target3(A...,C...);\n void filter3(B...);\n void adapter3(A... a,B... b,C... c) {\n   filter3(b...);\n   return target3(a...,c...);\n }\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.collectArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle)",
        "Code": "\n mh = MethodHandles.dropArguments(mh, 1, coll.type().parameterList()); //step 2\n mh = MethodHandles.foldArguments(mh, coll); //step 1\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.dropArguments(java.lang.invoke.MethodHandle,int,java.util.List<java.lang.Class<?>>)",
        "Code": "\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat = lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nassertEquals(\"xy\", (String) cat.invokeExact(\"x\", \"y\"));\nMethodType bigType = cat.type().insertParameterTypes(0, int.class, String.class);\nMethodHandle d0 = dropArguments(cat, 0, bigType.parameterList().subList(0,2));\nassertEquals(bigType, d0.type());\nassertEquals(\"yz\", (String) d0.invokeExact(123, \"x\", \"y\", \"z\"));\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.dropArguments(java.lang.invoke.MethodHandle,int,java.util.List<java.lang.Class<?>>)",
        "Code": "\n dropArguments (target, pos, valueTypes.toArray(new Class[0]))\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.dropArguments(java.lang.invoke.MethodHandle,int,java.lang.Class<?>...)",
        "Code": "\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat = lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nassertEquals(\"xy\", (String) cat.invokeExact(\"x\", \"y\"));\nMethodHandle d0 = dropArguments(cat, 0, String.class);\nassertEquals(\"yz\", (String) d0.invokeExact(\"x\", \"y\", \"z\"));\nMethodHandle d1 = dropArguments(cat, 1, String.class);\nassertEquals(\"xz\", (String) d1.invokeExact(\"x\", \"y\", \"z\"));\nMethodHandle d2 = dropArguments(cat, 2, String.class);\nassertEquals(\"xy\", (String) d2.invokeExact(\"x\", \"y\", \"z\"));\nMethodHandle d12 = dropArguments(cat, 1, int.class, boolean.class);\nassertEquals(\"xz\", (String) d12.invokeExact(\"x\", 12, true, \"z\"));\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.dropArguments(java.lang.invoke.MethodHandle,int,java.lang.Class<?>...)",
        "Code": "\n dropArguments (target, pos, Arrays.asList(valueTypes))\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.filterArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle...)",
        "Code": "\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat = lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nMethodHandle upcase = lookup().findVirtual(String.class,\n  \"toUpperCase\", methodType(String.class));\nassertEquals(\"xy\", (String) cat.invokeExact(\"x\", \"y\"));\nMethodHandle f0 = filterArguments(cat, 0, upcase);\nassertEquals(\"Xy\", (String) f0.invokeExact(\"x\", \"y\")); // Xy\nMethodHandle f1 = filterArguments(cat, 1, upcase);\nassertEquals(\"xY\", (String) f1.invokeExact(\"x\", \"y\")); // xY\nMethodHandle f2 = filterArguments(cat, 0, upcase, upcase);\nassertEquals(\"XY\", (String) f2.invokeExact(\"x\", \"y\")); // XY\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.filterArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle...)",
        "Code": "\n V target(P... p, A[i]... a[i], B... b);\n A[i] filter[i](V[i]);\n T adapter(P... p, V[i]... v[i], B... b) {\n   return target(p..., f[i](v[i])..., b...);\n }\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.filterReturnValue(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)",
        "Code": "\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat = lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nMethodHandle length = lookup().findVirtual(String.class,\n  \"length\", methodType(int.class));\nSystem.out.println((String) cat.invokeExact(\"x\", \"y\")); // xy\nMethodHandle f0 = filterReturnValue(cat, length);\nSystem.out.println((int) f0.invokeExact(\"x\", \"y\")); // 2\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.filterReturnValue(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)",
        "Code": "\n V target(A...);\n T filter(V);\n T adapter(A... a) {\n   V v = target(a...);\n   return filter(v);\n }\n // and if the target has a void return:\n void target2(A...);\n T filter2();\n T adapter2(A... a) {\n   target2(a...);\n   return filter2();\n }\n // and if the filter has a void return:\n V target3(A...);\n void filter3(V);\n void adapter3(A... a) {\n   V v = target3(a...);\n   filter3(v);\n }\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.foldArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)",
        "Code": "\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,\n  \"println\", methodType(void.class, String.class))\n    .bindTo(System.out);\nMethodHandle cat = lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nassertEquals(\"boojum\", (String) cat.invokeExact(\"boo\", \"jum\"));\nMethodHandle catTrace = foldArguments(cat, trace);\n// also prints \"boo\":\nassertEquals(\"boojum\", (String) catTrace.invokeExact(\"boo\", \"jum\"));\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.foldArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)",
        "Code": "\n // there are N arguments in A...\n T target(V, A[N]..., B...);\n V combiner(A...);\n T adapter(A... a, B... b) {\n   V v = combiner(a...);\n   return target(v, a..., b...);\n }\n // and if the combiner has a void return:\n T target2(A[N]..., B...);\n void combiner2(A...);\n T adapter2(A... a, B... b) {\n   combiner2(a...);\n   return target2(a..., b...);\n }\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.guardWithTest(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)",
        "Code": "\n boolean test(A...);\n T target(A...,B...);\n T fallback(A...,B...);\n T adapter(A... a,B... b) {\n   if (test(a...))\n     return target(a..., b...);\n   else\n     return fallback(a..., b...);\n }\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.permuteArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodType,int...)",
        "Code": "\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodType intfn1 = methodType(int.class, int.class);\nMethodType intfn2 = methodType(int.class, int.class, int.class);\nMethodHandle sub = ... (int x, int y) -> (x-y) ...;\nassert(sub.type().equals(intfn2));\nMethodHandle sub1 = permuteArguments(sub, intfn2, 0, 1);\nMethodHandle rsub = permuteArguments(sub, intfn2, 1, 0);\nassert((int)rsub.invokeExact(1, 100) == 99);\nMethodHandle add = ... (int x, int y) -> (x+y) ...;\nassert(add.type().equals(intfn2));\nMethodHandle twice = permuteArguments(add, intfn1, 0, 0);\nassert(twice.type().equals(intfn1));\nassert((int)twice.invokeExact(21) == 42);\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.spreadInvoker(java.lang.invoke.MethodType,int)",
        "Code": "\nMethodHandle invoker = MethodHandles.invoker(type);\nint spreadArgCount = type.parameterCount() - leadingArgCount;\ninvoker = invoker.asSpreader(Object[].class, spreadArgCount);\nreturn invoker;\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.Lookup.bind(java.lang.Object,java.lang.String,java.lang.invoke.MethodType)",
        "Code": "\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle mh0 = lookup().findVirtual(defc, name, type);\nMethodHandle mh1 = mh0.bindTo(receiver);\nMethodType mt1 = mh1.type();\nif (mh0.isVarargsCollector())\n  mh1 = mh1.asVarargsCollector(mt1.parameterType(mt1.parameterCount()-1));\nreturn mh1;\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.Lookup.findConstructor(java.lang.Class<?>,java.lang.invoke.MethodType)",
        "Code": "\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle MH_newArrayList = publicLookup().findConstructor(\n  ArrayList.class, methodType(void.class, Collection.class));\nCollection orig = Arrays.asList(\"x\", \"y\");\nCollection copy = (ArrayList) MH_newArrayList.invokeExact(orig);\nassert(orig != copy);\nassertEquals(orig, copy);\n// a variable-arity constructor:\nMethodHandle MH_newProcessBuilder = publicLookup().findConstructor(\n  ProcessBuilder.class, methodType(void.class, String[].class));\nProcessBuilder pb = (ProcessBuilder)\n  MH_newProcessBuilder.invoke(\"x\", \"y\", \"z\");\nassertEquals(\"[x, y, z]\", pb.command().toString());\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.Lookup.findSpecial(java.lang.Class<?>,java.lang.String,java.lang.invoke.MethodType,java.lang.Class<?>)",
        "Code": "\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nstatic class Listie extends ArrayList {\n  public String toString() { return \"[wee Listie]\"; }\n  static Lookup lookup() { return MethodHandles.lookup(); }\n}\n...\n// no access to constructor via invokeSpecial:\nMethodHandle MH_newListie = Listie.lookup()\n  .findConstructor(Listie.class, methodType(void.class));\nListie l = (Listie) MH_newListie.invokeExact();\ntry { assertEquals(\"impossible\", Listie.lookup().findSpecial(\n        Listie.class, \"<init>\", methodType(void.class), Listie.class));\n } catch (NoSuchMethodException ex) { } // OK\n// access to super and self methods via invokeSpecial:\nMethodHandle MH_super = Listie.lookup().findSpecial(\n  ArrayList.class, \"toString\" , methodType(String.class), Listie.class);\nMethodHandle MH_this = Listie.lookup().findSpecial(\n  Listie.class, \"toString\" , methodType(String.class), Listie.class);\nMethodHandle MH_duper = Listie.lookup().findSpecial(\n  Object.class, \"toString\" , methodType(String.class), Listie.class);\nassertEquals(\"[]\", (String) MH_super.invokeExact(l));\nassertEquals(\"\"+l, (String) MH_this.invokeExact(l));\nassertEquals(\"[]\", (String) MH_duper.invokeExact(l)); // ArrayList method\ntry { assertEquals(\"inaccessible\", Listie.lookup().findSpecial(\n        String.class, \"toString\", methodType(String.class), Listie.class));\n } catch (IllegalAccessException ex) { } // OK\nListie subl = new Listie() { public String toString() { return \"[subclass]\"; } };\nassertEquals(\"\"+l, (String) MH_this.invokeExact(subl)); // Listie method\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.Lookup.findStatic(java.lang.Class<?>,java.lang.String,java.lang.invoke.MethodType)",
        "Code": "\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle MH_asList = publicLookup().findStatic(Arrays.class,\n  \"asList\", methodType(List.class, Object[].class));\nassertEquals(\"[x, y]\", MH_asList.invoke(\"x\", \"y\").toString());\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.Lookup.findVirtual(java.lang.Class<?>,java.lang.String,java.lang.invoke.MethodType)",
        "Code": "\nimport static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle MH_concat = publicLookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nMethodHandle MH_hashCode = publicLookup().findVirtual(Object.class,\n  \"hashCode\", methodType(int.class));\nMethodHandle MH_hashCode_String = publicLookup().findVirtual(String.class,\n  \"hashCode\", methodType(int.class));\nassertEquals(\"xy\", (String) MH_concat.invokeExact(\"x\", \"y\"));\nassertEquals(\"xy\".hashCode(), (int) MH_hashCode.invokeExact((Object)\"xy\"));\nassertEquals(\"xy\".hashCode(), (int) MH_hashCode_String.invokeExact(\"xy\"));\n// interface method:\nMethodHandle MH_subSequence = publicLookup().findVirtual(CharSequence.class,\n  \"subSequence\", methodType(CharSequence.class, int.class, int.class));\nassertEquals(\"def\", MH_subSequence.invoke(\"abcdefghi\", 3, 6).toString());\n// constructor \"internal method\" must be accessed differently:\nMethodType MT_newString = methodType(void.class); //()V for new String()\ntry { assertEquals(\"impossible\", lookup()\n        .findVirtual(String.class, \"<init>\", MT_newString));\n } catch (NoSuchMethodException ex) { } // OK\nMethodHandle MH_newString = publicLookup()\n  .findConstructor(String.class, MT_newString);\nassertEquals(\"\", (String) MH_newString.invokeExact());\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MutableCallSite.dynamicInvoker()",
        "Code": "\n MethodHandle getTarget, invoker, result;\n getTarget = MethodHandles.publicLookup().bind(this, \"getTarget\", MethodType.methodType(MethodHandle.class));\n invoker = MethodHandles.exactInvoker(this.type());\n result = MethodHandles.foldArguments(invoker, getTarget)\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.VolatileCallSite.dynamicInvoker()",
        "Code": "\n MethodHandle getTarget, invoker, result;\n getTarget = MethodHandles.publicLookup().bind(this, \"getTarget\", MethodType.methodType(MethodHandle.class));\n invoker = MethodHandles.exactInvoker(this.type());\n result = MethodHandles.foldArguments(invoker, getTarget)\n ",
        "Description": " "
    },
    {
        "API": "java.nio.ByteBuffer.compact()",
        "Code": "\n   buf.clear();          // Prepare buffer for use\n   while (in.read(buf) >= 0 || buf.position != 0) {\n       buf.flip();\n       out.write(buf);\n       buf.compact();    // In case of partial write\n   }\n ",
        "Description": " "
    },
    {
        "API": "java.nio.ByteBuffer.get(byte[],int,int)",
        "Code": "\n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get():\n ",
        "Description": " In other words, an invocation of this method of the form\n src.get(dst,\u00a0off,\u00a0len) has exactly the same effect as\n the loop\n\n  "
    },
    {
        "API": "java.nio.ByteBuffer.put(byte[],int,int)",
        "Code": "\n     for (int i = off; i < off + len; i++)\n         dst.put(a[i]);\n ",
        "Description": " In other words, an invocation of this method of the form\n dst.put(src,\u00a0off,\u00a0len) has exactly the same effect as\n the loop\n\n  "
    },
    {
        "API": "java.nio.CharBuffer.get(char[],int,int)",
        "Code": "\n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get():\n ",
        "Description": " In other words, an invocation of this method of the form\n src.get(dst,\u00a0off,\u00a0len) has exactly the same effect as\n the loop\n\n  "
    },
    {
        "API": "java.nio.CharBuffer.put(char[],int,int)",
        "Code": "\n     for (int i = off; i < off + len; i++)\n         dst.put(a[i]);\n ",
        "Description": " In other words, an invocation of this method of the form\n dst.put(src,\u00a0off,\u00a0len) has exactly the same effect as\n the loop\n\n  "
    },
    {
        "API": "java.nio.CharBuffer.put(java.lang.String,int,int)",
        "Code": "\n     for (int i = start; i < end; i++)\n         dst.put(src.charAt(i));\n ",
        "Description": " In other words, an invocation of this method of the form\n dst.put(src,\u00a0start,\u00a0end) has exactly the same effect\n as the loop\n\n  "
    },
    {
        "API": "java.nio.DoubleBuffer.get(double[],int,int)",
        "Code": "\n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get():\n ",
        "Description": " In other words, an invocation of this method of the form\n src.get(dst,\u00a0off,\u00a0len) has exactly the same effect as\n the loop\n\n  "
    },
    {
        "API": "java.nio.DoubleBuffer.put(double[],int,int)",
        "Code": "\n     for (int i = off; i < off + len; i++)\n         dst.put(a[i]);\n ",
        "Description": " In other words, an invocation of this method of the form\n dst.put(src,\u00a0off,\u00a0len) has exactly the same effect as\n the loop\n\n  "
    },
    {
        "API": "java.nio.FloatBuffer.get(float[],int,int)",
        "Code": "\n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get():\n ",
        "Description": " In other words, an invocation of this method of the form\n src.get(dst,\u00a0off,\u00a0len) has exactly the same effect as\n the loop\n\n  "
    },
    {
        "API": "java.nio.FloatBuffer.put(float[],int,int)",
        "Code": "\n     for (int i = off; i < off + len; i++)\n         dst.put(a[i]);\n ",
        "Description": " In other words, an invocation of this method of the form\n dst.put(src,\u00a0off,\u00a0len) has exactly the same effect as\n the loop\n\n  "
    },
    {
        "API": "java.nio.IntBuffer.get(int[],int,int)",
        "Code": "\n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get():\n ",
        "Description": " In other words, an invocation of this method of the form\n src.get(dst,\u00a0off,\u00a0len) has exactly the same effect as\n the loop\n\n  "
    },
    {
        "API": "java.nio.IntBuffer.put(int[],int,int)",
        "Code": "\n     for (int i = off; i < off + len; i++)\n         dst.put(a[i]);\n ",
        "Description": " In other words, an invocation of this method of the form\n dst.put(src,\u00a0off,\u00a0len) has exactly the same effect as\n the loop\n\n  "
    },
    {
        "API": "java.nio.LongBuffer.get(long[],int,int)",
        "Code": "\n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get():\n ",
        "Description": " In other words, an invocation of this method of the form\n src.get(dst,\u00a0off,\u00a0len) has exactly the same effect as\n the loop\n\n  "
    },
    {
        "API": "java.nio.LongBuffer.put(long[],int,int)",
        "Code": "\n     for (int i = off; i < off + len; i++)\n         dst.put(a[i]);\n ",
        "Description": " In other words, an invocation of this method of the form\n dst.put(src,\u00a0off,\u00a0len) has exactly the same effect as\n the loop\n\n  "
    },
    {
        "API": "java.nio.ShortBuffer.get(short[],int,int)",
        "Code": "\n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get():\n ",
        "Description": " In other words, an invocation of this method of the form\n src.get(dst,\u00a0off,\u00a0len) has exactly the same effect as\n the loop\n\n  "
    },
    {
        "API": "java.nio.ShortBuffer.put(short[],int,int)",
        "Code": "\n     for (int i = off; i < off + len; i++)\n         dst.put(a[i]);\n ",
        "Description": " In other words, an invocation of this method of the form\n dst.put(src,\u00a0off,\u00a0len) has exactly the same effect as\n the loop\n\n  "
    },
    {
        "API": "java.nio.channels.SelectionKey.isAcceptable()",
        "Code": "\n k.readyOps() & OP_ACCEPT != 0\n ",
        "Description": " "
    },
    {
        "API": "java.nio.channels.SelectionKey.isConnectable()",
        "Code": "\n k.readyOps() & OP_CONNECT != 0\n ",
        "Description": " "
    },
    {
        "API": "java.nio.channels.SelectionKey.isReadable()",
        "Code": "\n k.readyOps() & OP_READ != 0\n ",
        "Description": " "
    },
    {
        "API": "java.nio.channels.SelectionKey.isWritable()",
        "Code": "\n k.readyOps() & OP_WRITE != 0\n ",
        "Description": " "
    },
    {
        "API": "java.nio.file.Files.lines(java.nio.file.Path)",
        "Code": "\n Files.lines(path, StandardCharsets.UTF_8)\n ",
        "Description": " This method works as if invoking it were equivalent to evaluating the\n expression:\n  "
    },
    {
        "API": "java.nio.file.Files.newBufferedReader(java.nio.file.Path)",
        "Code": "\n Files.newBufferedReader(path, StandardCharsets.UTF_8)\n ",
        "Description": " This method works as if invoking it were equivalent to evaluating the\n expression:\n  "
    },
    {
        "API": "java.nio.file.Files.newBufferedWriter(java.nio.file.Path,java.nio.file.OpenOption...)",
        "Code": "\n Files.newBufferedWriter(path, StandardCharsets.UTF_8, options)\n ",
        "Description": " This method works as if invoking it were equivalent to evaluating the\n expression:\n  "
    },
    {
        "API": "java.nio.file.Files.readAllLines(java.nio.file.Path)",
        "Code": "\n Files.readAllLines(path, StandardCharsets.UTF_8)\n ",
        "Description": " This method works as if invoking it were equivalent to evaluating the\n expression:\n  "
    },
    {
        "API": "java.nio.file.Files.write(java.nio.file.Path,java.lang.Iterable<? extends java.lang.CharSequence>,java.nio.file.OpenOption...)",
        "Code": "\n Files.write(path, lines, StandardCharsets.UTF_8, options);\n ",
        "Description": " This method works as if invoking it were equivalent to evaluating the\n expression:\n  "
    },
    {
        "API": "java.security.cert.X509Extension.getCriticalExtensionOIDs()",
        "Code": "\n X509Certificate cert = null;\n try (InputStream inStrm = new FileInputStream(\"DER-encoded-Cert\")) {\n     CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n     cert = (X509Certificate)cf.generateCertificate(inStrm);\n }\n\n Set<String> critSet = cert.getCriticalExtensionOIDs();\n if (critSet != null && !critSet.isEmpty()) {\n     System.out.println(\"Set of critical extensions:\");\n     for (String oid : critSet) {\n         System.out.println(oid);\n     }\n }\n ",
        "Description": " "
    },
    {
        "API": "java.security.cert.X509Extension.getNonCriticalExtensionOIDs()",
        "Code": "\n CertificateFactory cf = null;\n X509CRL crl = null;\n try (InputStream inStrm = new FileInputStream(\"DER-encoded-CRL\")) {\n     cf = CertificateFactory.getInstance(\"X.509\");\n     crl = (X509CRL)cf.generateCRL(inStrm);\n }\n\n byte[] certData = <DER-encoded certificate data>\n ByteArrayInputStream bais = new ByteArrayInputStream(certData);\n X509Certificate cert = (X509Certificate)cf.generateCertificate(bais);\n X509CRLEntry badCert =\n              crl.getRevokedCertificate(cert.getSerialNumber());\n\n if (badCert != null) {\n     Set<String> nonCritSet = badCert.getNonCriticalExtensionOIDs();\n     if (nonCritSet != null)\n         for (String oid : nonCritSet) {\n             System.out.println(oid);\n         }\n }\n ",
        "Description": " "
    },
    {
        "API": "java.security.cert.CertPath.hashCode()",
        "Code": "\n  hashCode = path.getType().hashCode();\n  hashCode = 31*hashCode + path.getCertificates().hashCode();\n ",
        "Description": " path1.equals(path2)"
    },
    {
        "API": "java.security.cert.TrustAnchor.TrustAnchor(java.security.cert.X509Certificate,byte[])",
        "Code": "\n  NameConstraints ::= SEQUENCE {\n       permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,\n       excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }\n\n  GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree\n\n  GeneralSubtree ::= SEQUENCE {\n       base                    GeneralName,\n       minimum         [0]     BaseDistance DEFAULT 0,\n       maximum         [1]     BaseDistance OPTIONAL }\n\n  BaseDistance ::= INTEGER (0..MAX)\n\n  GeneralName ::= CHOICE {\n       otherName                       [0]     OtherName,\n       rfc822Name                      [1]     IA5String,\n       dNSName                         [2]     IA5String,\n       x400Address                     [3]     ORAddress,\n       directoryName                   [4]     Name,\n       ediPartyName                    [5]     EDIPartyName,\n       uniformResourceIdentifier       [6]     IA5String,\n       iPAddress                       [7]     OCTET STRING,\n       registeredID                    [8]     OBJECT IDENTIFIER}\n ",
        "Description": "\n The name constraints are specified as a byte array. This byte array\n should contain the DER encoded form of the name constraints, as they\n would appear in the NameConstraints structure defined in\n RFC 3280\n and X.509. The ASN.1 definition of this structure appears below.\n\n  \n Note that the name constraints byte array supplied is cloned to protect\n against subsequent modifications."
    },
    {
        "API": "java.security.cert.X509CertSelector.addSubjectAlternativeName(int,byte[])",
        "Code": "\n  GeneralName ::= CHOICE {\n       otherName                       [0]     OtherName,\n       rfc822Name                      [1]     IA5String,\n       dNSName                         [2]     IA5String,\n       x400Address                     [3]     ORAddress,\n       directoryName                   [4]     Name,\n       ediPartyName                    [5]     EDIPartyName,\n       uniformResourceIdentifier       [6]     IA5String,\n       iPAddress                       [7]     OCTET STRING,\n       registeredID                    [8]     OBJECT IDENTIFIER}\n ",
        "Description": "\n The name is provided as a byte array. This byte array should contain\n the DER encoded name, as it would appear in the GeneralName structure\n defined in RFC 3280 and X.509. The encoded byte array should only contain\n the encoded value of the name, and should not include the tag associated\n with the name in the GeneralName structure. The ASN.1 definition of this\n structure appears below.\n  \n Note that the byte array supplied here is cloned to protect against\n subsequent modifications."
    },
    {
        "API": "java.security.cert.X509CertSelector.setAuthorityKeyIdentifier(byte[])",
        "Code": "\n AuthorityKeyIdentifier ::= SEQUENCE {\n    keyIdentifier             [0] KeyIdentifier           OPTIONAL,\n    authorityCertIssuer       [1] GeneralNames            OPTIONAL,\n    authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }\n\n KeyIdentifier ::= OCTET STRING\n ",
        "Description": "\n If authorityKeyID is not null, it\n should contain a single DER encoded value corresponding to the contents\n of the extension value (not including the object identifier,\n criticality setting, and encapsulating OCTET STRING)\n for an AuthorityKeyIdentifier extension.\n The ASN.1 notation for this structure follows.\n\n  \n Authority key identifiers are not parsed by the\n X509CertSelector.  Instead, the values are\n compared using a byte-by-byte comparison.\n "
    },
    {
        "API": "java.security.cert.X509CertSelector.setIssuer(byte[])",
        "Code": "\n Name ::= CHOICE {\n   RDNSequence }\n\n RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\n\n RelativeDistinguishedName ::=\n   SET SIZE (1 .. MAX) OF AttributeTypeAndValue\n\n AttributeTypeAndValue ::= SEQUENCE {\n   type     AttributeType,\n   value    AttributeValue }\n\n AttributeType ::= OBJECT IDENTIFIER\n\n AttributeValue ::= ANY DEFINED BY AttributeType\n ....\n DirectoryString ::= CHOICE {\n       teletexString           TeletexString (SIZE (1..MAX)),\n       printableString         PrintableString (SIZE (1..MAX)),\n       universalString         UniversalString (SIZE (1..MAX)),\n       utf8String              UTF8String (SIZE (1.. MAX)),\n       bmpString               BMPString (SIZE (1..MAX)) }\n ",
        "Description": "\n If issuerDN is not null, it should contain a\n single DER encoded distinguished name, as defined in X.501. The ASN.1\n notation for this structure is as follows.\n  \n Note that the byte array specified here is cloned to protect against\n subsequent modifications."
    },
    {
        "API": "java.security.cert.X509CertSelector.setNameConstraints(byte[])",
        "Code": "\n  NameConstraints ::= SEQUENCE {\n       permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,\n       excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }\n\n  GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree\n\n  GeneralSubtree ::= SEQUENCE {\n       base                    GeneralName,\n       minimum         [0]     BaseDistance DEFAULT 0,\n       maximum         [1]     BaseDistance OPTIONAL }\n\n  BaseDistance ::= INTEGER (0..MAX)\n\n  GeneralName ::= CHOICE {\n       otherName                       [0]     OtherName,\n       rfc822Name                      [1]     IA5String,\n       dNSName                         [2]     IA5String,\n       x400Address                     [3]     ORAddress,\n       directoryName                   [4]     Name,\n       ediPartyName                    [5]     EDIPartyName,\n       uniformResourceIdentifier       [6]     IA5String,\n       iPAddress                       [7]     OCTET STRING,\n       registeredID                    [8]     OBJECT IDENTIFIER}\n ",
        "Description": "\n The name constraints are specified as a byte array. This byte array\n should contain the DER encoded form of the name constraints, as they\n would appear in the NameConstraints structure defined in RFC 3280\n and X.509. The ASN.1 definition of this structure appears below.\n\n  \n Note that the byte array supplied here is cloned to protect against\n subsequent modifications."
    },
    {
        "API": "java.security.cert.X509CertSelector.setSubjectKeyIdentifier(byte[])",
        "Code": "\n SubjectKeyIdentifier ::= KeyIdentifier\n\n KeyIdentifier ::= OCTET STRING\n ",
        "Description": "\n If subjectKeyID is not null, it\n should contain a single DER encoded value corresponding to the contents\n of the extension value (not including the object identifier,\n criticality setting, and encapsulating OCTET STRING)\n for a SubjectKeyIdentifier extension.\n The ASN.1 notation for this structure follows.\n\n  \n Since the format of subject key identifiers is not mandated by\n any standard, subject key identifiers are not parsed by the\n X509CertSelector. Instead, the values are compared using\n a byte-by-byte comparison.\n "
    },
    {
        "API": "java.security.cert.X509CertSelector.setSubjectPublicKey(byte[])",
        "Code": "\n SubjectPublicKeyInfo  ::=  SEQUENCE  {\n   algorithm            AlgorithmIdentifier,\n   subjectPublicKey     BIT STRING  }\n\n AlgorithmIdentifier  ::=  SEQUENCE  {\n   algorithm               OBJECT IDENTIFIER,\n   parameters              ANY DEFINED BY algorithm OPTIONAL  }\n                              -- contains a value of the type\n                              -- registered for use with the\n                              -- algorithm object identifier value\n ",
        "Description": "\n If key is not null, it should contain a\n single DER encoded SubjectPublicKeyInfo structure, as defined in X.509.\n The ASN.1 notation for this structure is as follows.\n  \n Note that the byte array supplied here is cloned to protect against\n subsequent modifications."
    },
    {
        "API": "java.security.cert.X509CRLSelector.setIssuerNames(java.util.Collection<?>)",
        "Code": "\n Name ::= CHOICE {\n   RDNSequence }\n\n RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\n\n RelativeDistinguishedName ::=\n   SET SIZE (1 .. MAX) OF AttributeTypeAndValue\n\n AttributeTypeAndValue ::= SEQUENCE {\n   type     AttributeType,\n   value    AttributeValue }\n\n AttributeType ::= OBJECT IDENTIFIER\n\n AttributeValue ::= ANY DEFINED BY AttributeType\n ....\n DirectoryString ::= CHOICE {\n       teletexString           TeletexString (SIZE (1..MAX)),\n       printableString         PrintableString (SIZE (1..MAX)),\n       universalString         UniversalString (SIZE (1..MAX)),\n       utf8String              UTF8String (SIZE (1.. MAX)),\n       bmpString               BMPString (SIZE (1..MAX)) }\n ",
        "Description": "\n If a name is specified as a byte array, it should contain a single DER\n encoded distinguished name, as defined in X.501. The ASN.1 notation for\n this structure is as follows.\n  \n Note that a deep copy is performed on the Collection to\n protect against subsequent modifications."
    },
    {
        "API": "java.sql.DatabaseMetaData.getRowIdLifetime()",
        "Code": "\n     ROWID_UNSUPPORTED < ROWID_VALID_OTHER < ROWID_VALID_TRANSACTION\n         < ROWID_VALID_SESSION < ROWID_VALID_FOREVER\n ",
        "Description": "\n The returned int values have the following relationship:\n  \n     if (metadata.getRowIdLifetime() > DatabaseMetaData.ROWID_VALID_TRANSACTION)\n "
    },
    {
        "API": "java.sql.DatabaseMetaData.getRowIdLifetime()",
        "Code": "\n     if (metadata.getRowIdLifetime() > DatabaseMetaData.ROWID_VALID_TRANSACTION)\n ",
        "Description": "\n     ROWID_UNSUPPORTED < ROWID_VALID_OTHER < ROWID_VALID_TRANSACTION\n         < ROWID_VALID_SESSION < ROWID_VALID_FOREVER\n  "
    },
    {
        "API": "java.sql.Statement.getMoreResults()",
        "Code": "\n     // stmt is a Statement object\n     ((stmt.getMoreResults() == false) && (stmt.getUpdateCount() == -1))\n ",
        "Description": "There are no more results when the following is true:\n  "
    },
    {
        "API": "java.sql.Statement.getMoreResults(int)",
        "Code": "\n     // stmt is a Statement object\n     ((stmt.getMoreResults(current) == false) && (stmt.getUpdateCount() == -1))\n ",
        "Description": "There are no more results when the following is true:\n  "
    },
    {
        "API": "java.sql.Timestamp.hashCode()",
        "Code": "\n (int)(this.getTime()^(this.getTime() >>> 32))\n ",
        "Description": " "
    },
    {
        "API": "java.text.DateFormat.getTimeZone()",
        "Code": "\n getCalendar().getTimeZone()\n ",
        "Description": " "
    },
    {
        "API": "java.text.DateFormat.isLenient()",
        "Code": "\n getCalendar().isLenient()\n ",
        "Description": " "
    },
    {
        "API": "java.text.DateFormat.setLenient(boolean)",
        "Code": "\n getCalendar().setLenient(lenient)\n ",
        "Description": " "
    },
    {
        "API": "java.text.DateFormat.setTimeZone(java.util.TimeZone)",
        "Code": "\n getCalendar().setTimeZone(zone)\n ",
        "Description": " "
    },
    {
        "API": "java.time.temporal.TemporalAdjusters.ofDateAdjuster(java.util.function.UnaryOperator<java.time.LocalDate>)",
        "Code": "\n  static TemporalAdjuster TWO_DAYS_LATER =\n       TemporalAdjusters.ofDateAdjuster(date -> date.plusDays(2));\n ",
        "Description": "\n In general, user-written adjusters should be static constants:\n  "
    },
    {
        "API": "java.util.Collection.spliterator()",
        "Code": "\n     Stream<E> s = StreamSupport.stream(() -> spliterator(), spliteratorCharacteristics)\n ",
        "Description": "The default implementation should be overridden by subclasses that\n can return a more efficient spliterator.  In order to\n preserve expected laziness behavior for the stream() and\n parallelStream()} methods, spliterators should either have the\n characteristic of IMMUTABLE or CONCURRENT, or be\n late-binding.\n If none of these is practical, the overriding class should describe the\n spliterator's documented policy of binding and structural interference,\n and should override the stream() and parallelStream()\n methods to create streams using a Supplier of the spliterator,\n as in:\n  These requirements ensure that streams produced by the\n stream() and parallelStream() methods will reflect the\n contents of the collection as of initiation of the terminal stream\n operation."
    },
    {
        "API": "java.util.List.hashCode()",
        "Code": "\n     int hashCode = 1;\n     for (E e : list)\n         hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());\n ",
        "Description": " list1.equals(list2)"
    },
    {
        "API": "java.util.List.subList(int,int)",
        "Code": "\n      list.subList(from, to).clear();\n ",
        "Description": "\n\n This method eliminates the need for explicit range operations (of\n the sort that commonly exist for arrays).  Any operation that expects\n a list can be used as a range operation by passing a subList view\n instead of a whole list.  For example, the following idiom\n removes a range of elements from a list:\n  indexOf"
    },
    {
        "API": "java.util.List.toArray(T[])",
        "Code": "\n     String[] y = x.toArray(new String[0]);\n ",
        "Description": "Suppose x is a list known to contain only strings.\n The following code can be used to dump the list into a newly\n allocated array of String:\n\n  toArray(new Object[0])"
    },
    {
        "API": "java.util.AbstractList.subList(int,int)",
        "Code": "\n      list.subList(from, to).clear();\n ",
        "Description": "\n\n This method eliminates the need for explicit range operations (of\n the sort that commonly exist for arrays).  Any operation that expects\n a list can be used as a range operation by passing a subList view\n instead of a whole list.  For example, the following idiom\n removes a range of elements from a list:\n  indexOf"
    },
    {
        "API": "java.util.Calendar.after(java.lang.Object)",
        "Code": "\n         compareTo(when) > 0\n ",
        "Description": "Object when"
    },
    {
        "API": "java.util.Calendar.before(java.lang.Object)",
        "Code": "\n         compareTo(when) < 0\n ",
        "Description": "Object when"
    },
    {
        "API": "java.util.Date.hashCode()",
        "Code": "\n (int)(this.getTime()^(this.getTime() >>> 32))\n ",
        "Description": " "
    },
    {
        "API": "java.util.Random.next(int)",
        "Code": " (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1)",
        "Description": "The general contract of next is that it returns an\n int value and if the argument bits is between\n 1 and 32 (inclusive), then that many low-order\n bits of the returned value will be (approximately) independently\n chosen bit values, each of which is (approximately) equally\n likely to be 0 or 1. The method next is\n implemented by class Random by atomically updating the seed to\n    (int)(seed >>> (48 - bits))."
    },
    {
        "API": "java.util.Random.next(int)",
        "Code": " (int)(seed >>> (48 - bits)).",
        "Description": " (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1) The Art of Computer Programming,"
    },
    {
        "API": "java.util.Random.setSeed(long)",
        "Code": " (seed ^ 0x5DEECE66DL) & ((1L << 48) - 1)",
        "Description": "Random haveNextNextGaussian"
    },
    {
        "API": "java.util.ResourceBundle.Control.getCandidateLocales(java.lang.String,java.util.Locale)",
        "Code": "\n     Locale(\"ja\", \"\", \"XX\")\n     Locale(\"ja\")\n     Locale.ROOT\n ",
        "Description": "For example, if the given baseName is \"Messages\"\n and the given locale is\n Locale(\"ja\",\u00a0\"\",\u00a0\"XX\"), then a\n List of Locales:\n  Locale"
    },
    {
        "API": "java.util.ResourceBundle.Control.getCandidateLocales(java.lang.String,java.util.Locale)",
        "Code": "\n     Messages_ja -> Messages\n ",
        "Description": "Locale "
    },
    {
        "API": "java.util.Scanner.reset()",
        "Code": "\n   scanner.useDelimiter(\"\\\\p{javaWhitespace}+\")\n          .useLocale(Locale.getDefault(Locale.Category.FORMAT))\n          .useRadix(10);\n ",
        "Description": " "
    },
    {
        "API": "java.util.SimpleTimeZone.SimpleTimeZone(int,java.lang.String,int,int,int,int,int,int,int,int)",
        "Code": "\n     SimpleTimeZone(rawOffset,\n                    ID,\n                    startMonth,\n                    startDay,\n                    startDayOfWeek,\n                    startTime,\n                    SimpleTimeZone.WALL_TIME,\n                    endMonth,\n                    endDay,\n                    endDayOfWeek,\n                    endTime,\n                    SimpleTimeZone.WALL_TIME,\n                    3600000)\n ",
        "Description": "endTime "
    },
    {
        "API": "java.util.SimpleTimeZone.SimpleTimeZone(int,java.lang.String,int,int,int,int,int,int,int,int,int)",
        "Code": "\n     SimpleTimeZone(rawOffset,\n                    ID,\n                    startMonth,\n                    startDay,\n                    startDayOfWeek,\n                    startTime,\n                    SimpleTimeZone.WALL_TIME,\n                    endMonth,\n                    endDay,\n                    endDayOfWeek,\n                    endTime,\n                    SimpleTimeZone.WALL_TIME,\n                    dstSavings)\n ",
        "Description": "endTime "
    },
    {
        "API": "java.util.SimpleTimeZone.setEndRule(int,int,int)",
        "Code": "setEndRule(endMonth, endDay, 0, endTime)",
        "Description": " "
    },
    {
        "API": "java.util.SimpleTimeZone.setStartRule(int,int,int,int)",
        "Code": "setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2*60*60*1000);",
        "Description": " "
    },
    {
        "API": "java.util.SimpleTimeZone.setStartRule(int,int,int)",
        "Code": "setStartRule(startMonth, startDay, 0, startTime)",
        "Description": " "
    },
    {
        "API": "java.util.TimerTask.scheduledExecutionTime()",
        "Code": "\n   public void run() {\n       if (System.currentTimeMillis() - scheduledExecutionTime() >=\n           MAX_TARDINESS)\n               return;  // Too late; skip this execution.\n       // Perform the task\n   }\n ",
        "Description": "This method is typically invoked from within a task's run method, to\n determine whether the current execution of the task is sufficiently\n timely to warrant performing the scheduled activity:\n  not"
    },
    {
        "API": "java.util.jar.Pack200.Packer.CLASS_ATTRIBUTE_PFX",
        "Code": "\n     Map p = packer.properties();\n     p.put(CODE_ATTRIBUTE_PFX+\"CoverageTable\",       \"NH[PHHII]\");\n     p.put(CODE_ATTRIBUTE_PFX+\"CharacterRangeTable\", \"NH[PHPOHIIH]\");\n     p.put(CLASS_ATTRIBUTE_PFX+\"SourceID\",           \"RUH\");\n     p.put(CLASS_ATTRIBUTE_PFX+\"CompilationID\",      \"RUH\");\n ",
        "Description": "\n Code like this might be used to support attributes for JCOV:\n  \n Code like this might be used to strip debugging attributes:\n "
    },
    {
        "API": "java.util.jar.Pack200.Packer.CLASS_ATTRIBUTE_PFX",
        "Code": "\n     Map p = packer.properties();\n     p.put(CODE_ATTRIBUTE_PFX+\"LineNumberTable\",    STRIP);\n     p.put(CODE_ATTRIBUTE_PFX+\"LocalVariableTable\", STRIP);\n     p.put(CLASS_ATTRIBUTE_PFX+\"SourceFile\",        STRIP);\n ",
        "Description": "\n Code like this might be used to strip debugging attributes:\n  "
    },
    {
        "API": "java.util.jar.Pack200.Packer.PASS_FILE_PFX",
        "Code": "\n     Map p = packer.properties();\n     p.put(PASS_FILE_PFX+0, \"mutants/Rogue.class\");\n     p.put(PASS_FILE_PFX+1, \"mutants/Wolverine.class\");\n     p.put(PASS_FILE_PFX+2, \"mutants/Storm.class\");\n     # Pass all files in an entire directory hierarchy:\n     p.put(PASS_FILE_PFX+3, \"police/\");\n ",
        "Description": "\n Examples:\n  "
    },
    {
        "API": "java.util.jar.Pack200.Packer.UNKNOWN_ATTRIBUTE",
        "Code": "\n     Map p = pack200.getProperties();\n     p.put(UNKNOWN_ATTRIBUTE, ERROR);\n     p.put(UNKNOWN_ATTRIBUTE, STRIP);\n     p.put(UNKNOWN_ATTRIBUTE, PASS);\n ",
        "Description": "\n Examples:\n  "
    },
    {
        "API": "java.util.prefs.Preferences.exportNode(java.io.OutputStream)",
        "Code": "\n <!DOCTYPE preferences SYSTEM \"http://java.sun.com/dtd/preferences.dtd\">\n ",
        "Description": "The XML document will have the following DOCTYPE declaration:\n  This method is an exception to the general rule that the results of\n concurrently executing multiple methods in this class yields\n results equivalent to some serial execution.  If the preferences\n at this node are modified concurrently with an invocation of this\n method, the exported preferences comprise a \"fuzzy snapshot\" of the\n preferences contained in the node; some of the concurrent modifications\n may be reflected in the exported data while others may not."
    },
    {
        "API": "java.util.prefs.Preferences.exportSubtree(java.io.OutputStream)",
        "Code": "\n <!DOCTYPE preferences SYSTEM \"http://java.sun.com/dtd/preferences.dtd\">\n ",
        "Description": "The XML document will have the following DOCTYPE declaration:\n  This method is an exception to the general rule that the results of\n concurrently executing multiple methods in this class yields\n results equivalent to some serial execution.  If the preferences\n or nodes in the subtree rooted at this node are modified concurrently\n with an invocation of this method, the exported preferences comprise a\n \"fuzzy snapshot\" of the subtree; some of the concurrent modifications\n may be reflected in the exported data while others may not."
    },
    {
        "API": "java.util.prefs.Preferences.importPreferences(java.io.InputStream)",
        "Code": "\n <!DOCTYPE preferences SYSTEM \"http://java.sun.com/dtd/preferences.dtd\">\n ",
        "Description": "The XML document must have the following DOCTYPE declaration:\n  exportNode(OutputStream)"
    },
    {
        "API": "java.util.stream.DoubleStream.collect(java.util.function.Supplier<R>,java.util.function.ObjDoubleConsumer<R>,,R>)",
        "Code": "\n     R result = supplier.get();\n     for (double element : this stream)\n         accumulator.accept(result, element);\n     return result;\n ",
        "Description": "ArrayList Like reduce(double, DoubleBinaryOperator), collect\n operations can be parallelized without requiring additional\n synchronization.\n\n "
    },
    {
        "API": "java.util.stream.DoubleStream.count()",
        "Code": "\n     return mapToLong(e -> 1L).sum();\n ",
        "Description": "reduction This is a terminal operation."
    },
    {
        "API": "java.util.stream.DoubleStream.max()",
        "Code": "\n     return reduce(Double::max);\n ",
        "Description": "reduction This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.DoubleStream.min()",
        "Code": "\n     return reduce(Double::min);\n ",
        "Description": "reduction This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.DoubleStream.reduce(double,java.util.function.DoubleBinaryOperator)",
        "Code": "\n     double result = identity;\n     for (double element : this stream)\n         result = accumulator.applyAsDouble(result, element)\n     return result;\n ",
        "Description": "associative The identity value must be an identity for the accumulator\n function. This means that for all x,\n accumulator.apply(identity, x) is equal to x.\n The accumulator function must be an\n associative function.\n\n "
    },
    {
        "API": "java.util.stream.DoubleStream.reduce(java.util.function.DoubleBinaryOperator)",
        "Code": "\n     boolean foundAny = false;\n     double result = null;\n     for (double element : this stream) {\n         if (!foundAny) {\n             foundAny = true;\n             result = element;\n         }\n         else\n             result = accumulator.applyAsDouble(result, element);\n     }\n     return foundAny ? OptionalDouble.of(result) : OptionalDouble.empty();\n ",
        "Description": "OptionalDouble The accumulator function must be an\n associative function.\n\n "
    },
    {
        "API": "java.util.stream.DoubleStream.sum()",
        "Code": "\n     return reduce(0, Double::sum);\n ",
        "Description": "reduction If any stream element is a NaN or the sum is at any point a NaN\n then the sum will be NaN.\n\n The value of a floating-point sum is a function both\n of the input values as well as the order of addition\n operations. The order of addition operations of this method is\n intentionally not defined to allow for implementation\n flexibility to improve the speed and accuracy of the computed\n result.\n\n In particular, this method may be implemented using compensated\n summation or other technique to reduce the error bound in the\n numerical sum compared to a simple summation of double\n values.\n\n "
    },
    {
        "API": "java.util.stream.IntStream.collect(java.util.function.Supplier<R>,java.util.function.ObjIntConsumer<R>,,R>)",
        "Code": "\n     R result = supplier.get();\n     for (int element : this stream)\n         accumulator.accept(result, element);\n     return result;\n ",
        "Description": "ArrayList Like reduce(int, IntBinaryOperator), collect operations\n can be parallelized without requiring additional synchronization.\n\n "
    },
    {
        "API": "java.util.stream.IntStream.count()",
        "Code": "\n     return mapToLong(e -> 1L).sum();\n ",
        "Description": "reduction This is a terminal operation."
    },
    {
        "API": "java.util.stream.IntStream.max()",
        "Code": "\n     return reduce(Integer::max);\n ",
        "Description": "reduction This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.IntStream.min()",
        "Code": "\n     return reduce(Integer::min);\n ",
        "Description": "reduction This is a terminal operation."
    },
    {
        "API": "java.util.stream.IntStream.reduce(int,java.util.function.IntBinaryOperator)",
        "Code": "\n     int result = identity;\n     for (int element : this stream)\n         result = accumulator.applyAsInt(result, element)\n     return result;\n ",
        "Description": "associative The identity value must be an identity for the accumulator\n function. This means that for all x,\n accumulator.apply(identity, x) is equal to x.\n The accumulator function must be an\n associative function.\n\n "
    },
    {
        "API": "java.util.stream.IntStream.reduce(java.util.function.IntBinaryOperator)",
        "Code": "\n     boolean foundAny = false;\n     int result = null;\n     for (int element : this stream) {\n         if (!foundAny) {\n             foundAny = true;\n             result = element;\n         }\n         else\n             result = accumulator.applyAsInt(result, element);\n     }\n     return foundAny ? OptionalInt.of(result) : OptionalInt.empty();\n ",
        "Description": "OptionalInt The accumulator function must be an\n associative function.\n\n "
    },
    {
        "API": "java.util.stream.IntStream.sum()",
        "Code": "\n     return reduce(0, Integer::sum);\n ",
        "Description": "reduction This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.LongStream.collect(java.util.function.Supplier<R>,java.util.function.ObjLongConsumer<R>,,R>)",
        "Code": "\n     R result = supplier.get();\n     for (long element : this stream)\n         accumulator.accept(result, element);\n     return result;\n ",
        "Description": "ArrayList Like reduce(long, LongBinaryOperator), collect operations\n can be parallelized without requiring additional synchronization.\n\n "
    },
    {
        "API": "java.util.stream.LongStream.count()",
        "Code": "\n     return map(e -> 1L).sum();\n ",
        "Description": "reduction This is a terminal operation."
    },
    {
        "API": "java.util.stream.LongStream.max()",
        "Code": "\n     return reduce(Long::max);\n ",
        "Description": "reduction This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.LongStream.min()",
        "Code": "\n     return reduce(Long::min);\n ",
        "Description": "reduction This is a terminal operation."
    },
    {
        "API": "java.util.stream.LongStream.reduce(long,java.util.function.LongBinaryOperator)",
        "Code": "\n     long result = identity;\n     for (long element : this stream)\n         result = accumulator.applyAsLong(result, element)\n     return result;\n ",
        "Description": "associative The identity value must be an identity for the accumulator\n function. This means that for all x,\n accumulator.apply(identity, x) is equal to x.\n The accumulator function must be an\n associative function.\n\n "
    },
    {
        "API": "java.util.stream.LongStream.reduce(java.util.function.LongBinaryOperator)",
        "Code": "\n     boolean foundAny = false;\n     long result = null;\n     for (long element : this stream) {\n         if (!foundAny) {\n             foundAny = true;\n             result = element;\n         }\n         else\n             result = accumulator.applyAsLong(result, element);\n     }\n     return foundAny ? OptionalLong.of(result) : OptionalLong.empty();\n ",
        "Description": "OptionalLong The accumulator function must be an\n associative function.\n\n "
    },
    {
        "API": "java.util.stream.LongStream.sum()",
        "Code": "\n     return reduce(0, Long::sum);\n ",
        "Description": "reduction This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.Stream.collect(java.util.function.Supplier<R>,,? super java.util.stream.Stream>,,R>)",
        "Code": "\n     R result = supplier.get();\n     for (T element : this stream)\n         accumulator.accept(result, element);\n     return result;\n ",
        "Description": "ArrayList Like reduce(Object, BinaryOperator), collect operations\n can be parallelized without requiring additional synchronization.\n\n "
    },
    {
        "API": "java.util.stream.Stream.count()",
        "Code": "\n     return mapToLong(e -> 1L).sum();\n ",
        "Description": "reduction This is a terminal operation."
    },
    {
        "API": "java.util.stream.Stream.reduce(java.util.stream.Stream,java.util.function.BinaryOperator<java.util.stream.Stream>)",
        "Code": "\n     T result = identity;\n     for (T element : this stream)\n         result = accumulator.apply(result, element)\n     return result;\n ",
        "Description": "associative The identity value must be an identity for the accumulator\n function. This means that for all t,\n accumulator.apply(identity, t) is equal to t.\n The accumulator function must be an\n associative function.\n\n "
    },
    {
        "API": "java.util.stream.Stream.reduce(java.util.function.BinaryOperator<java.util.stream.Stream>)",
        "Code": "\n     boolean foundAny = false;\n     T result = null;\n     for (T element : this stream) {\n         if (!foundAny) {\n             foundAny = true;\n             result = element;\n         }\n         else\n             result = accumulator.apply(result, element);\n     }\n     return foundAny ? Optional.of(result) : Optional.empty();\n ",
        "Description": "Optional The accumulator function must be an\n associative function.\n\n "
    },
    {
        "API": "java.util.stream.Stream.reduce(U,,? super,U>,java.util.function.BinaryOperator<U>)",
        "Code": "\n     U result = identity;\n     for (T element : this stream)\n         result = accumulator.apply(result, element)\n     return result;\n ",
        "Description": "reduction The identity value must be an identity for the combiner\n function.  This means that for all u, combiner(identity, u)\n is equal to u.  Additionally, the combiner function\n must be compatible with the accumulator function; for all\n u and t, the following must hold:\n "
    },
    {
        "API": "java.util.stream.Stream.reduce(U,,? super,U>,java.util.function.BinaryOperator<U>)",
        "Code": "\n     combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)\n ",
        "Description": "The identity value must be an identity for the combiner\n function.  This means that for all u, combiner(identity, u)\n is equal to u.  Additionally, the combiner function\n must be compatible with the accumulator function; for all\n u and t, the following must hold:\n  This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.Collectors.collectingAndThen(,,R>,,RR>)",
        "Code": "\n     List<String> people\n         = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList));\n ",
        "Description": "toList() "
    },
    {
        "API": "java.util.stream.Collectors.groupingBy(java.util.function.Function<? super,? extends K>,java.util.stream.Collector<? super,,D>)",
        "Code": "\n     Map<City, Set<String>> namesByCity\n         = people.stream().collect(groupingBy(Person::getCity,\n                                              mapping(Person::getLastName, toSet())));\n ",
        "Description": "For example, to compute the set of last names of people in each city:\n  "
    },
    {
        "API": "java.util.stream.Collectors.groupingBy(java.util.function.Function<? super,? extends K>,java.util.function.Supplier<M>,java.util.stream.Collector<? super,,D>)",
        "Code": "\n     Map<City, Set<String>> namesByCity\n         = people.stream().collect(groupingBy(Person::getCity, TreeMap::new,\n                                              mapping(Person::getLastName, toSet())));\n ",
        "Description": "For example, to compute the set of last names of people in each city,\n where the city names are sorted:\n  "
    },
    {
        "API": "java.util.stream.Collectors.groupingByConcurrent(java.util.function.Function<? super,? extends K>,java.util.stream.Collector<? super,,D>)",
        "Code": "\n     ConcurrentMap<City, Set<String>> namesByCity\n         = people.stream().collect(groupingByConcurrent(Person::getCity,\n                                                        mapping(Person::getLastName, toSet())));\n ",
        "Description": "For example, to compute the set of last names of people in each city,\n where the city names are sorted:\n  "
    },
    {
        "API": "java.util.stream.Collectors.groupingByConcurrent(java.util.function.Function<? super,? extends K>,java.util.function.Supplier<M>,java.util.stream.Collector<? super,,D>)",
        "Code": "\n     ConcurrentMap<City, Set<String>> namesByCity\n         = people.stream().collect(groupingBy(Person::getCity, ConcurrentSkipListMap::new,\n                                              mapping(Person::getLastName, toSet())));\n ",
        "Description": "For example, to compute the set of last names of people in each city,\n where the city names are sorted:\n  "
    },
    {
        "API": "javax.imageio.stream.ImageInputStream.readBits(int)",
        "Code": "\n long accum = 0L;\n for (int i = 0; i < numBits; i++) {\n   accum <<= 1; // Shift left one bit to make room\n   accum |= readBit();\n }\n ",
        "Description": " The byte order of the stream has no effect on this\n method.  The return value of this method is constructed as\n though the bits were read one at a time, and shifted into\n the right side of the return value, as shown by the following\n pseudo-code:\n\n  readBits(32)"
    },
    {
        "API": "javax.imageio.stream.ImageInputStream.readUTF()",
        "Code": "\n (char)(((a& 0x1F) << 6) | (b & 0x3F))\n ",
        "Description": "  1110xxxx"
    },
    {
        "API": "javax.imageio.stream.ImageInputStream.readUTF()",
        "Code": "\n (char)(((a & 0x0F) << 12) | ((b & 0x3F) << 6) | (c & 0x3F))\n ",
        "Description": "  1111xxxx"
    },
    {
        "API": "javax.imageio.stream.ImageOutputStream.writeUTF(java.lang.String)",
        "Code": "\n (byte)c\n ",
        "Description": "  If a character c is \\u0000 or\n is in the range \\u0080 through\n \\u07ff, then it is represented by two bytes,\n to be written in the order shown:\n\n "
    },
    {
        "API": "javax.imageio.stream.ImageOutputStream.writeUTF(java.lang.String)",
        "Code": "\n (byte)(0xc0 | (0x1f & (c >> 6)))\n (byte)(0x80 | (0x3f & c))\n ",
        "Description": "   If a character c is in the range\n \\u0800 through uffff, then it is\n represented by three bytes, to be written in the order shown:\n\n "
    },
    {
        "API": "javax.imageio.stream.ImageOutputStream.writeUTF(java.lang.String)",
        "Code": "\n (byte)(0xe0 | (0x0f & (c >> 12)))\n (byte)(0x80 | (0x3f & (c >> 6)))\n (byte)(0x80 | (0x3f & c))\n ",
        "Description": "   First, the total number of bytes needed to represent all\n the characters of s is calculated. If this number\n is larger than 65535, then a\n UTFDataFormatException is thrown. Otherwise, this\n length is written to the output stream in exactly the manner of\n the writeShort method; after this, the one-, two-,\n or three-byte representation of each character in the string\n s is written.\n\n "
    },
    {
        "API": "javax.management.openmbean.ArrayType.ArrayType(int,javax.management.openmbean.OpenType<?>)",
        "Code": "\n ArrayType<String[][][]> t = new ArrayType<String[][][]>(3, SimpleType.STRING);\n System.out.println(\"array class name       = \" + t.getClassName());\n System.out.println(\"element class name     = \" + t.getElementOpenType().getClassName());\n System.out.println(\"array type name        = \" + t.getTypeName());\n System.out.println(\"array type description = \" + t.getDescription());\n ",
        "Description": "\n As an example, the following piece of code:\n  \n array class name       = [[[Ljava.lang.String;\n element class name     = java.lang.String\n array type name        = [[[Ljava.lang.String;\n array type description = 3-dimension array of java.lang.String\n "
    },
    {
        "API": "javax.management.openmbean.ArrayType.ArrayType(int,javax.management.openmbean.OpenType<?>)",
        "Code": "\n array class name       = [[[Ljava.lang.String;\n element class name     = java.lang.String\n array type name        = [[[Ljava.lang.String;\n array type description = 3-dimension array of java.lang.String\n ",
        "Description": "\n ArrayType<String[][][]> t = new ArrayType<String[][][]>(3, SimpleType.STRING);\n System.out.println(\"array class name       = \" + t.getClassName());\n System.out.println(\"element class name     = \" + t.getElementOpenType().getClassName());\n System.out.println(\"array type name        = \" + t.getTypeName());\n System.out.println(\"array type description = \" + t.getDescription());\n  \n ArrayType<String[]> t1 = new ArrayType<String[]>(1, SimpleType.STRING);\n ArrayType<String[][]> t2 = new ArrayType<String[][]>(1, t1);\n ArrayType<String[][][]> t3 = new ArrayType<String[][][]>(1, t2);\n System.out.println(\"array class name       = \" + t3.getClassName());\n System.out.println(\"element class name     = \" + t3.getElementOpenType().getClassName());\n System.out.println(\"array type name        = \" + t3.getTypeName());\n System.out.println(\"array type description = \" + t3.getDescription());\n "
    },
    {
        "API": "javax.management.openmbean.ArrayType.ArrayType(int,javax.management.openmbean.OpenType<?>)",
        "Code": "\n ArrayType<String[]> t1 = new ArrayType<String[]>(1, SimpleType.STRING);\n ArrayType<String[][]> t2 = new ArrayType<String[][]>(1, t1);\n ArrayType<String[][][]> t3 = new ArrayType<String[][][]>(1, t2);\n System.out.println(\"array class name       = \" + t3.getClassName());\n System.out.println(\"element class name     = \" + t3.getElementOpenType().getClassName());\n System.out.println(\"array type name        = \" + t3.getTypeName());\n System.out.println(\"array type description = \" + t3.getDescription());\n ",
        "Description": "\n array class name       = [[[Ljava.lang.String;\n element class name     = java.lang.String\n array type name        = [[[Ljava.lang.String;\n array type description = 3-dimension array of java.lang.String\n  "
    },
    {
        "API": "javax.management.openmbean.ArrayType.ArrayType(javax.management.openmbean.SimpleType<?>,boolean)",
        "Code": "\n ArrayType<int[]> t = new ArrayType<int[]>(SimpleType.INTEGER, true);\n System.out.println(\"array class name       = \" + t.getClassName());\n System.out.println(\"element class name     = \" + t.getElementOpenType().getClassName());\n System.out.println(\"array type name        = \" + t.getTypeName());\n System.out.println(\"array type description = \" + t.getDescription());\n ",
        "Description": "\n As an example, the following piece of code:\n  \n array class name       = [I\n element class name     = java.lang.Integer\n array type name        = [I\n array type description = 1-dimension array of int\n "
    },
    {
        "API": "javax.management.openmbean.ArrayType.ArrayType(javax.management.openmbean.SimpleType<?>,boolean)",
        "Code": "\n array class name       = [I\n element class name     = java.lang.Integer\n array type name        = [I\n array type description = 1-dimension array of int\n ",
        "Description": "\n ArrayType<int[]> t = new ArrayType<int[]>(SimpleType.INTEGER, true);\n System.out.println(\"array class name       = \" + t.getClassName());\n System.out.println(\"element class name     = \" + t.getElementOpenType().getClassName());\n System.out.println(\"array type name        = \" + t.getTypeName());\n System.out.println(\"array type description = \" + t.getDescription());\n  "
    },
    {
        "API": "javax.management.openmbean.ArrayType.getArrayType(javax.management.openmbean.OpenType<E>)",
        "Code": "\n ArrayType<String[]> t1 = ArrayType.getArrayType(SimpleType.STRING);\n ArrayType<String[][]> t2 = ArrayType.getArrayType(t1);\n ArrayType<String[][][]> t3 = ArrayType.getArrayType(t2);\n System.out.println(\"array class name       = \" + t3.getClassName());\n System.out.println(\"element class name     = \" + t3.getElementOpenType().getClassName());\n System.out.println(\"array type name        = \" + t3.getTypeName());\n System.out.println(\"array type description = \" + t3.getDescription());\n ",
        "Description": "\n As an example, the following piece of code:\n  \n array class name       = [[[Ljava.lang.String;\n element class name     = java.lang.String\n array type name        = [[[Ljava.lang.String;\n array type description = 3-dimension array of java.lang.String\n "
    },
    {
        "API": "javax.management.openmbean.ArrayType.getArrayType(javax.management.openmbean.OpenType<E>)",
        "Code": "\n array class name       = [[[Ljava.lang.String;\n element class name     = java.lang.String\n array type name        = [[[Ljava.lang.String;\n array type description = 3-dimension array of java.lang.String\n ",
        "Description": "\n ArrayType<String[]> t1 = ArrayType.getArrayType(SimpleType.STRING);\n ArrayType<String[][]> t2 = ArrayType.getArrayType(t1);\n ArrayType<String[][][]> t3 = ArrayType.getArrayType(t2);\n System.out.println(\"array class name       = \" + t3.getClassName());\n System.out.println(\"element class name     = \" + t3.getElementOpenType().getClassName());\n System.out.println(\"array type name        = \" + t3.getTypeName());\n System.out.println(\"array type description = \" + t3.getDescription());\n  "
    },
    {
        "API": "javax.management.openmbean.ArrayType.getPrimitiveArrayType(java.lang.Class<T>)",
        "Code": "\n ArrayType<int[][][]> t = ArrayType.getPrimitiveArrayType(int[][][].class);\n System.out.println(\"array class name       = \" + t.getClassName());\n System.out.println(\"element class name     = \" + t.getElementOpenType().getClassName());\n System.out.println(\"array type name        = \" + t.getTypeName());\n System.out.println(\"array type description = \" + t.getDescription());\n ",
        "Description": "\n As an example, the following piece of code:\n  \n array class name       = [[[I\n element class name     = java.lang.Integer\n array type name        = [[[I\n array type description = 3-dimension array of int\n "
    },
    {
        "API": "javax.management.openmbean.ArrayType.getPrimitiveArrayType(java.lang.Class<T>)",
        "Code": "\n array class name       = [[[I\n element class name     = java.lang.Integer\n array type name        = [[[I\n array type description = 3-dimension array of int\n ",
        "Description": "\n ArrayType<int[][][]> t = ArrayType.getPrimitiveArrayType(int[][][].class);\n System.out.println(\"array class name       = \" + t.getClassName());\n System.out.println(\"element class name     = \" + t.getElementOpenType().getClassName());\n System.out.println(\"array type name        = \" + t.getTypeName());\n System.out.println(\"array type description = \" + t.getDescription());\n  "
    },
    {
        "API": "javax.print.ServiceUI.printDialog(java.awt.GraphicsConfiguration,int,int,javax.print.PrintService[],javax.print.PrintService,javax.print.DocFlavor,javax.print.attribute.PrintRequestAttributeSet)",
        "Code": "\n PrintService[] services = PrintServiceLookup.lookupPrintServices(\n                            DocFlavor.INPUT_STREAM.JPEG, null);\n PrintRequestAttributeSet attributes = new HashPrintRequestAttributeSet();\n if (services.length > 0) {\n    PrintService service =  ServiceUI.printDialog(null, 50, 50,\n                                               services, services[0],\n                                               null,\n                                               attributes);\n    if (service != null) {\n     ... print ...\n    }\n }\n ",
        "Description": "\n If the user cancels the dialog, the returned attributes will not reflect\n any changes made by the user.\n\n A typical basic usage of this method may be :\n  "
    },
    {
        "API": "javax.script.ScriptEngineFactory.getMethodCallSyntax(java.lang.String,java.lang.String,java.lang.String...)",
        "Code": "\n public String getMethodCallSyntax(String obj,\n                                   String m, String... args) {\n      String ret = obj;\n      ret += \".\" + m + \"(\";\n      for (int i = 0; i < args.length; i++) {\n          ret += args[i];\n          if (i < args.length - 1) {\n              ret += \",\";\n          }\n      }\n      ret += \")\";\n      return ret;\n }\n  ",
        "Description": " "
    },
    {
        "API": "javax.script.ScriptEngineFactory.getOutputStatement(java.lang.String)",
        "Code": "\n public String getOutputStatement(String toDisplay) {\n      return \"print(\" + toDisplay + \")\";\n }\n ",
        "Description": " "
    },
    {
        "API": "javax.script.ScriptEngineFactory.getProgram(java.lang.String...)",
        "Code": "\n public String getProgram(String... statements) {\n      String retval = \"<?\\n\";\n      int len = statements.length;\n      for (int i = 0; i < len; i++) {\n          retval += statements[i] + \";\\n\";\n      }\n      return retval += \"?>\";\n }\n ",
        "Description": " "
    },
    {
        "API": "javax.security.auth.callback.CallbackHandler.handle(javax.security.auth.callback.Callback[])",
        "Code": "\n public void handle(Callback[] callbacks)\n throws IOException, UnsupportedCallbackException {\n\n   for (int i = 0; i < callbacks.length; i++) {\n      if (callbacks[i] instanceof TextOutputCallback) {\n\n          // display the message according to the specified type\n          TextOutputCallback toc = (TextOutputCallback)callbacks[i];\n          switch (toc.getMessageType()) {\n          case TextOutputCallback.INFORMATION:\n              System.out.println(toc.getMessage());\n              break;\n          case TextOutputCallback.ERROR:\n              System.out.println(\"ERROR: \" + toc.getMessage());\n              break;\n          case TextOutputCallback.WARNING:\n              System.out.println(\"WARNING: \" + toc.getMessage());\n              break;\n          default:\n              throw new IOException(\"Unsupported message type: \" +\n                                  toc.getMessageType());\n          }\n\n      } else if (callbacks[i] instanceof NameCallback) {\n\n          // prompt the user for a username\n          NameCallback nc = (NameCallback)callbacks[i];\n\n          // ignore the provided defaultName\n          System.err.print(nc.getPrompt());\n          System.err.flush();\n          nc.setName((new BufferedReader\n                  (new InputStreamReader(System.in))).readLine());\n\n      } else if (callbacks[i] instanceof PasswordCallback) {\n\n          // prompt the user for sensitive information\n          PasswordCallback pc = (PasswordCallback)callbacks[i];\n          System.err.print(pc.getPrompt());\n          System.err.flush();\n          pc.setPassword(readPassword(System.in));\n\n      } else {\n          throw new UnsupportedCallbackException\n                  (callbacks[i], \"Unrecognized Callback\");\n      }\n   }\n }\n\n // Reads user password from given input stream.\n private char[] readPassword(InputStream in) throws IOException {\n    // insert code to read a user password from the input stream\n }\n ",
        "Description": " The handle method implementation checks the\n instance(s) of the Callback object(s) passed in\n to retrieve or display the requested information.\n The following example is provided to help demonstrate what an\n handle method implementation might look like.\n This example code is for guidance only.  Many details,\n including proper error handling, are left out for simplicity.\n\n  "
    },
    {
        "API": "javax.security.auth.kerberos.KerberosPrincipal.hashCode()",
        "Code": "\n  hashCode = getName().hashCode();\n ",
        "Description": " "
    },
    {
        "API": "javax.security.auth.x500.X500Principal.X500Principal(byte[])",
        "Code": "\n Name ::= CHOICE {\n   RDNSequence }\n\n RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\n\n RelativeDistinguishedName ::=\n   SET SIZE (1 .. MAX) OF AttributeTypeAndValue\n\n AttributeTypeAndValue ::= SEQUENCE {\n   type     AttributeType,\n   value    AttributeValue }\n\n AttributeType ::= OBJECT IDENTIFIER\n\n AttributeValue ::= ANY DEFINED BY AttributeType\n ....\n DirectoryString ::= CHOICE {\n       teletexString           TeletexString (SIZE (1..MAX)),\n       printableString         PrintableString (SIZE (1..MAX)),\n       universalString         UniversalString (SIZE (1..MAX)),\n       utf8String              UTF8String (SIZE (1.. MAX)),\n       bmpString               BMPString (SIZE (1..MAX)) }\n ",
        "Description": "X500Principal "
    },
    {
        "API": "javax.security.cert.X509Certificate.getInstance(java.io.InputStream)",
        "Code": "\n public <subClass>(InputStream inStream) ...\n ",
        "Description": "Note: Only one DER-encoded\n certificate is expected to be in the input stream.\n Also, all X509Certificate\n subclasses must provide a constructor of the form:\n  "
    },
    {
        "API": "javax.security.cert.X509Certificate.getInstance(byte[])",
        "Code": "\n public <subClass>(InputStream inStream) ...\n ",
        "Description": "Note: All X509Certificate\n subclasses must provide a constructor of the form:\n  "
    },
    {
        "API": "javax.swing.plaf.nimbus.NimbusLookAndFeel.register(javax.swing.plaf.synth.Region,java.lang.String)",
        "Code": "\n     laf.register(NimbusFooUI.FOO_REGION, \"Foo\");\n ",
        "Description": "For example, suppose I had a component named JFoo. Suppose I then registered\n this component with the NimbusLookAndFeel in this manner: In this case, I could then register properties for this component with\n UIDefaults in the following manner:"
    },
    {
        "API": "javax.swing.plaf.nimbus.NimbusLookAndFeel.register(javax.swing.plaf.synth.Region,java.lang.String)",
        "Code": "\n     UIManager.put(\"Foo.background\", new ColorUIResource(Color.BLACK));\n     UIManager.put(\"Foo.Enabled.backgroundPainter\", new FooBackgroundPainter());\n ",
        "Description": "In this case, I could then register properties for this component with\n UIDefaults in the following manner: It is also possible to register a named component with Nimbus.\n For example, suppose you wanted to style the background of a JPanel\n named \"MyPanel\" differently from other JPanels. You could accomplish this\n by doing the following:"
    },
    {
        "API": "javax.swing.plaf.nimbus.NimbusLookAndFeel.register(javax.swing.plaf.synth.Region,java.lang.String)",
        "Code": "\n     laf.register(Region.PANEL, \"\\\"MyPanel\\\"\");\n     UIManager.put(\"\\\"MyPanel\\\".background\", new ColorUIResource(Color.RED));\n ",
        "Description": "It is also possible to register a named component with Nimbus.\n For example, suppose you wanted to style the background of a JPanel\n named \"MyPanel\" differently from other JPanels. You could accomplish this\n by doing the following: "
    },
    {
        "API": "javax.swing.plaf.nimbus.State.State(java.lang.String)",
        "Code": "\n     defaults.put(\"Button.States\", \"Enabled, Foo, Disabled\");\n     defaults.put(\"Button.Foo\", new FooState(\"Foo\"));\n ",
        "Description": "For example, the following would be correct: "
    },
    {
        "API": "javax.swing.plaf.nimbus.State.isInState(javax.swing.plaf.nimbus.State)",
        "Code": " return c.isIndeterminate();",
        "Description": "Nimbus uses this method to help determine what state a JComponent is\n in. For example, a custom State could exist for JProgressBar such that\n it would return true when the progress bar is indeterminate.\n Such an implementation of this method would simply be: "
    },
    {
        "API": "javax.swing.text.Document.getText(int,int,javax.swing.text.Segment)",
        "Code": "\n\n \u00a0 int nleft = doc.getDocumentLength();\n \u00a0 Segment text = new Segment();\n \u00a0 int offs = 0;\n \u00a0 text.setPartialReturn(true);\n \u00a0 while (nleft > 0) {\n \u00a0     doc.getText(offs, nleft, text);\n \u00a0     // do someting with text\n \u00a0     nleft -= text.count;\n \u00a0     offs += text.count;\n \u00a0 }\n\n ",
        "Description": "\n If the partialReturn property on the txt parameter is false, the\n data returned in the Segment will be the entire length requested and\n may or may not be a copy depending upon how the data was stored.\n If the partialReturn property is true, only the amount of text that\n can be returned without creating a copy is returned.  Using partial\n returns will give better performance for situations where large\n parts of the document are being scanned.  The following is an example\n of using the partial return to access the entire document:\n\n  "
    },
    {
        "API": "javax.swing.text.AbstractDocument.readUnlock()",
        "Code": "\n \u00a0   readLock();\n \u00a0   try {\n \u00a0       // do something\n \u00a0   } finally {\n \u00a0       readUnlock();\n \u00a0   }\n ",
        "Description": " "
    },
    {
        "API": "javax.swing.text.JTextComponent.loadKeymap(javax.swing.text.Keymap,javax.swing.text.JTextComponent.KeyBinding[],javax.swing.Action[])",
        "Code": "\n\n   static final JTextComponent.KeyBinding[] defaultBindings = {\n     new JTextComponent.KeyBinding(\n       KeyStroke.getKeyStroke(KeyEvent.VK_C, InputEvent.CTRL_MASK),\n       DefaultEditorKit.copyAction),\n     new JTextComponent.KeyBinding(\n       KeyStroke.getKeyStroke(KeyEvent.VK_V, InputEvent.CTRL_MASK),\n       DefaultEditorKit.pasteAction),\n     new JTextComponent.KeyBinding(\n       KeyStroke.getKeyStroke(KeyEvent.VK_X, InputEvent.CTRL_MASK),\n       DefaultEditorKit.cutAction),\n   };\n\n   JTextComponent c = new JTextPane();\n   Keymap k = c.getKeymap();\n   JTextComponent.loadKeymap(k, defaultBindings, c.getActions());\n\n ",
        "Description": "\n Loads a keymap with a bunch of\n bindings.  This can be used to take a static table of\n definitions and load them into some keymap.  The following\n example illustrates an example of binding some keys to\n the cut, copy, and paste actions associated with a\n JTextComponent.  A code fragment to accomplish\n this might look as follows:\n  null"
    },
    {
        "API": "java.awt.GraphicsDevice.setDisplayMode(java.awt.DisplayMode)",
        "Code": "\n Frame frame;\n DisplayMode newDisplayMode;\n GraphicsDevice gd;\n // create a Frame, select desired DisplayMode from the list of modes\n // returned by gd.getDisplayModes() ...\n\n if (gd.isFullScreenSupported()) {\n     gd.setFullScreenWindow(frame);\n } else {\n    // proceed in non-full-screen mode\n    frame.setSize(...);\n    frame.setLocation(...);\n    frame.setVisible(true);\n }\n\n if (gd.isDisplayChangeSupported()) {\n     gd.setDisplayMode(newDisplayMode);\n }\n ",
        "Description": "\n Example code:\n  "
    },
    {
        "API": "java.io.DataInput.readChar()",
        "Code": "(char)((a << 8) | (b & 0xff))\n ",
        "Description": " writeChar"
    },
    {
        "API": "java.io.DataInput.readShort()",
        "Code": "(short)((a << 8) | (b & 0xff))\n ",
        "Description": " writeShort"
    },
    {
        "API": "java.io.DataInput.readUnsignedShort()",
        "Code": "(((a & 0xff) << 8) | (b & 0xff))\n ",
        "Description": " writeShort"
    },
    {
        "API": "java.io.DataInput.readUTF()",
        "Code": "(char)(((a& 0x1F) << 6) | (b & 0x3F))\n ",
        "Description": "\n 1110xxxx"
    },
    {
        "API": "java.io.DataInput.readUTF()",
        "Code": "\n (char)(((a & 0x0F) << 12) | ((b & 0x3F) << 6) | (c & 0x3F))\n ",
        "Description": "\n 1111xxxx"
    },
    {
        "API": "java.io.DataOutput.writeChar(int)",
        "Code": "\n (byte)(0xff & (v >> 8))\n (byte)(0xff & v)\n ",
        "Description": " \n The bytes written by this method may be\n read by the readChar method\n of interface DataInput , which\n will then return a char equal\n to (char)v."
    },
    {
        "API": "java.io.DataOutput.writeInt(int)",
        "Code": "\n (byte)(0xff & (v >> 24))\n (byte)(0xff & (v >> 16))\n (byte)(0xff & (v >>    8))\n (byte)(0xff & v)\n ",
        "Description": " \n The bytes written by this method may be read\n by the readInt method of interface\n DataInput , which will then\n return an int equal to v."
    },
    {
        "API": "java.io.DataOutput.writeLong(long)",
        "Code": "\n (byte)(0xff & (v >> 56))\n (byte)(0xff & (v >> 48))\n (byte)(0xff & (v >> 40))\n (byte)(0xff & (v >> 32))\n (byte)(0xff & (v >> 24))\n (byte)(0xff & (v >> 16))\n (byte)(0xff & (v >>  8))\n (byte)(0xff & v)\n ",
        "Description": " \n The bytes written by this method may be\n read by the readLong method\n of interface DataInput , which\n will then return a long equal\n to v."
    },
    {
        "API": "java.io.DataOutput.writeShort(int)",
        "Code": "\n (byte)(0xff & (v >> 8))\n (byte)(0xff & v)\n  ",
        "Description": "\n \n The bytes written by this method may be\n read by the readShort method\n of interface DataInput , which\n will then return a short equal\n to (short)v."
    },
    {
        "API": "java.io.DataOutput.writeUTF(java.lang.String)",
        "Code": "(byte)c ",
        "Description": "\n \n If a character c is \\u0000\n or is in the range \\u0080\n through \\u07ff, then it is\n represented by two bytes, to be written\n in the order shown:"
    },
    {
        "API": "java.io.DataOutput.writeUTF(java.lang.String)",
        "Code": "\n (byte)(0xc0 | (0x1f & (c >> 6)))\n (byte)(0x80 | (0x3f & c))\n  ",
        "Description": "   If a character\n c is in the range \\u0800\n through uffff, then it is\n represented by three bytes, to be written\n in the order shown:"
    },
    {
        "API": "java.io.DataOutput.writeUTF(java.lang.String)",
        "Code": "\n (byte)(0xe0 | (0x0f & (c >> 12)))\n (byte)(0x80 | (0x3f & (c >>  6)))\n (byte)(0x80 | (0x3f & c))\n  ",
        "Description": "   First,\n the total number of bytes needed to represent\n all the characters of s is\n calculated. If this number is larger than\n 65535, then a UTFDataFormatException\n is thrown. Otherwise, this length is written\n to the output stream in exactly the manner\n of the writeShort method;\n after this, the one-, two-, or three-byte\n representation of each character in the\n string s is written."
    },
    {
        "API": "java.io.InputStream.read(byte[])",
        "Code": " read(b, 0, b.length) ",
        "Description": " The read(b) method for class InputStream\n has the same effect as:  "
    },
    {
        "API": "java.io.PipedInputStream.connect(java.io.PipedOutputStream)",
        "Code": "snk.connect(src) ",
        "Description": "\n \n or the call:\n "
    },
    {
        "API": "java.io.PipedInputStream.connect(java.io.PipedOutputStream)",
        "Code": "src.connect(snk) ",
        "Description": "\n \n The two\n calls have the same effect."
    },
    {
        "API": "java.io.PipedReader.connect(java.io.PipedWriter)",
        "Code": "snk.connect(src) ",
        "Description": "\n \n or the call:\n "
    },
    {
        "API": "java.io.PipedReader.connect(java.io.PipedWriter)",
        "Code": "src.connect(snk) ",
        "Description": "\n \n The two\n calls have the same effect."
    },
    {
        "API": "java.lang.invoke.MethodHandles.Lookup.findConstructor(java.lang.Class<?>,java.lang.invoke.MethodType)",
        "Code": "import static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle MH_newArrayList = publicLookup().findConstructor(\n  ArrayList.class, methodType(void.class, Collection.class));\nCollection orig = Arrays.asList(\"x\", \"y\");\nCollection copy = (ArrayList) MH_newArrayList.invokeExact(orig);\nassert(orig != copy);\nassertEquals(orig, copy);\n// a variable-arity constructor:\nMethodHandle MH_newProcessBuilder = publicLookup().findConstructor(\n  ProcessBuilder.class, methodType(void.class, String[].class));\nProcessBuilder pb = (ProcessBuilder)\n  MH_newProcessBuilder.invoke(\"x\", \"y\", \"z\");\nassertEquals(\"[x, y, z]\", pb.command().toString());\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.Lookup.findSpecial(java.lang.Class<?>,java.lang.String,java.lang.invoke.MethodType,java.lang.Class<?>)",
        "Code": "import static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nstatic class Listie extends ArrayList {\n  public String toString() { return \"[wee Listie]\"; }\n  static Lookup lookup() { return MethodHandles.lookup(); }\n}\n...\n// no access to constructor via invokeSpecial:\nMethodHandle MH_newListie = Listie.lookup()\n  .findConstructor(Listie.class, methodType(void.class));\nListie l = (Listie) MH_newListie.invokeExact();\ntry { assertEquals(\"impossible\", Listie.lookup().findSpecial(\n        Listie.class, \"<init>\", methodType(void.class), Listie.class));\n } catch (NoSuchMethodException ex) { } // OK\n// access to super and self methods via invokeSpecial:\nMethodHandle MH_super = Listie.lookup().findSpecial(\n  ArrayList.class, \"toString\" , methodType(String.class), Listie.class);\nMethodHandle MH_this = Listie.lookup().findSpecial(\n  Listie.class, \"toString\" , methodType(String.class), Listie.class);\nMethodHandle MH_duper = Listie.lookup().findSpecial(\n  Object.class, \"toString\" , methodType(String.class), Listie.class);\nassertEquals(\"[]\", (String) MH_super.invokeExact(l));\nassertEquals(\"\"+l, (String) MH_this.invokeExact(l));\nassertEquals(\"[]\", (String) MH_duper.invokeExact(l)); // ArrayList method\ntry { assertEquals(\"inaccessible\", Listie.lookup().findSpecial(\n        String.class, \"toString\", methodType(String.class), Listie.class));\n } catch (IllegalAccessException ex) { } // OK\nListie subl = new Listie() { public String toString() { return \"[subclass]\"; } };\nassertEquals(\"\"+l, (String) MH_this.invokeExact(subl)); // Listie method\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.Lookup.findStatic(java.lang.Class<?>,java.lang.String,java.lang.invoke.MethodType)",
        "Code": "import static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle MH_asList = publicLookup().findStatic(Arrays.class,\n  \"asList\", methodType(List.class, Object[].class));\nassertEquals(\"[x, y]\", MH_asList.invoke(\"x\", \"y\").toString());\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.Lookup.findVirtual(java.lang.Class<?>,java.lang.String,java.lang.invoke.MethodType)",
        "Code": "import static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle MH_concat = publicLookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nMethodHandle MH_hashCode = publicLookup().findVirtual(Object.class,\n  \"hashCode\", methodType(int.class));\nMethodHandle MH_hashCode_String = publicLookup().findVirtual(String.class,\n  \"hashCode\", methodType(int.class));\nassertEquals(\"xy\", (String) MH_concat.invokeExact(\"x\", \"y\"));\nassertEquals(\"xy\".hashCode(), (int) MH_hashCode.invokeExact((Object)\"xy\"));\nassertEquals(\"xy\".hashCode(), (int) MH_hashCode_String.invokeExact(\"xy\"));\n// interface method:\nMethodHandle MH_subSequence = publicLookup().findVirtual(CharSequence.class,\n  \"subSequence\", methodType(CharSequence.class, int.class, int.class));\nassertEquals(\"def\", MH_subSequence.invoke(\"abcdefghi\", 3, 6).toString());\n// constructor \"internal method\" must be accessed differently:\nMethodType MT_newString = methodType(void.class); //()V for new String()\ntry { assertEquals(\"impossible\", lookup()\n        .findVirtual(String.class, \"<init>\", MT_newString));\n } catch (NoSuchMethodException ex) { } // OK\nMethodHandle MH_newString = publicLookup()\n  .findConstructor(String.class, MT_newString);\nassertEquals(\"\", (String) MH_newString.invokeExact());\n ",
        "Description": " "
    },
    {
        "API": "java.security.cert.X509Extension.getCriticalExtensionOIDs()",
        "Code": "\n InputStream inStrm = null;\n X509Certificate cert = null;\n try {\n     inStrm = new FileInputStream(\"DER-encoded-Cert\");\n     CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n     cert = (X509Certificate)cf.generateCertificate(inStrm);\n } finally {\n     if (inStrm != null) {\n         inStrm.close();\n     }\n }\n\n Set critSet = cert.getCriticalExtensionOIDs();\n if (critSet != null && !critSet.isEmpty()) {\n     System.out.println(\"Set of critical extensions:\");\n     for (String oid : critSet) {\n         System.out.println(oid);\n     }\n }\n ",
        "Description": " "
    },
    {
        "API": "java.security.cert.X509Extension.getNonCriticalExtensionOIDs()",
        "Code": "\n InputStream inStrm = null;\n CertificateFactory cf = null;\n X509CRL crl = null;\n try {\n     inStrm = new FileInputStream(\"DER-encoded-CRL\");\n     cf = CertificateFactory.getInstance(\"X.509\");\n     crl = (X509CRL)cf.generateCRL(inStrm);\n } finally {\n     if (inStrm != null) {\n         inStrm.close();\n     }\n }\n\n byte[] certData = <DER-encoded certificate data>\n ByteArrayInputStream bais = new ByteArrayInputStream(certData);\n X509Certificate cert = (X509Certificate)cf.generateCertificate(bais);\n bais.close();\n X509CRLEntry badCert =\n              crl.getRevokedCertificate(cert.getSerialNumber());\n\n if (badCert != null) {\n     Set nonCritSet = badCert.getNonCriticalExtensionOIDs();\n     if (nonCritSet != null)\n         for (String oid : nonCritSet) {\n             System.out.println(oid);\n         }\n }\n ",
        "Description": " "
    },
    {
        "API": "java.security.cert.CertPath.hashCode()",
        "Code": "\n  hashCode = path.getType().hashCode();\n  hashCode = 31*hashCode + path.getCertificates().hashCode();\n ",
        "Description": " path1.equals(path2)"
    },
    {
        "API": "java.security.cert.TrustAnchor.TrustAnchor(java.security.cert.X509Certificate,byte[])",
        "Code": "\n  NameConstraints ::= SEQUENCE {\n       permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,\n       excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }\n\n  GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree\n\n  GeneralSubtree ::= SEQUENCE {\n       base                    GeneralName,\n       minimum         [0]     BaseDistance DEFAULT 0,\n       maximum         [1]     BaseDistance OPTIONAL }\n\n  BaseDistance ::= INTEGER (0..MAX)\n\n  GeneralName ::= CHOICE {\n       otherName                       [0]     OtherName,\n       rfc822Name                      [1]     IA5String,\n       dNSName                         [2]     IA5String,\n       x400Address                     [3]     ORAddress,\n       directoryName                   [4]     Name,\n       ediPartyName                    [5]     EDIPartyName,\n       uniformResourceIdentifier       [6]     IA5String,\n       iPAddress                       [7]     OCTET STRING,\n       registeredID                    [8]     OBJECT IDENTIFIER}\n ",
        "Description": "\n The name constraints are specified as a byte array. This byte array\n should contain the DER encoded form of the name constraints, as they\n would appear in the NameConstraints structure defined in\n RFC 3280\n and X.509. The ASN.1 definition of this structure appears below.\n\n  \n Note that the name constraints byte array supplied is cloned to protect\n against subsequent modifications."
    },
    {
        "API": "java.security.cert.X509CertSelector.addSubjectAlternativeName(int,byte[])",
        "Code": "\n  GeneralName ::= CHOICE {\n       otherName                       [0]     OtherName,\n       rfc822Name                      [1]     IA5String,\n       dNSName                         [2]     IA5String,\n       x400Address                     [3]     ORAddress,\n       directoryName                   [4]     Name,\n       ediPartyName                    [5]     EDIPartyName,\n       uniformResourceIdentifier       [6]     IA5String,\n       iPAddress                       [7]     OCTET STRING,\n       registeredID                    [8]     OBJECT IDENTIFIER}\n ",
        "Description": "\n The name is provided as a byte array. This byte array should contain\n the DER encoded name, as it would appear in the GeneralName structure\n defined in RFC 3280 and X.509. The encoded byte array should only contain\n the encoded value of the name, and should not include the tag associated\n with the name in the GeneralName structure. The ASN.1 definition of this\n structure appears below.\n  \n Note that the byte array supplied here is cloned to protect against\n subsequent modifications."
    },
    {
        "API": "java.security.cert.X509CertSelector.setAuthorityKeyIdentifier(byte[])",
        "Code": "\n AuthorityKeyIdentifier ::= SEQUENCE {\n    keyIdentifier             [0] KeyIdentifier           OPTIONAL,\n    authorityCertIssuer       [1] GeneralNames            OPTIONAL,\n    authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }\n\n KeyIdentifier ::= OCTET STRING\n ",
        "Description": "\n \n Authority key identifiers are not parsed by the\n X509CertSelector.  Instead, the values are\n compared using a byte-by-byte comparison.\n "
    },
    {
        "API": "java.security.cert.X509CertSelector.setIssuer(byte[])",
        "Code": "\n Name ::= CHOICE {\n   RDNSequence }\n\n RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\n\n RelativeDistinguishedName ::=\n   SET SIZE (1 .. MAX) OF AttributeTypeAndValue\n\n AttributeTypeAndValue ::= SEQUENCE {\n   type     AttributeType,\n   value    AttributeValue }\n\n AttributeType ::= OBJECT IDENTIFIER\n\n AttributeValue ::= ANY DEFINED BY AttributeType\n ....\n DirectoryString ::= CHOICE {\n       teletexString           TeletexString (SIZE (1..MAX)),\n       printableString         PrintableString (SIZE (1..MAX)),\n       universalString         UniversalString (SIZE (1..MAX)),\n       utf8String              UTF8String (SIZE (1.. MAX)),\n       bmpString               BMPString (SIZE (1..MAX)) }\n ",
        "Description": "\n If issuerDN is not null, it should contain a\n single DER encoded distinguished name, as defined in X.501. The ASN.1\n notation for this structure is as follows.\n  \n Note that the byte array specified here is cloned to protect against\n subsequent modifications."
    },
    {
        "API": "java.security.cert.X509CertSelector.setNameConstraints(byte[])",
        "Code": "\n  NameConstraints ::= SEQUENCE {\n       permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,\n       excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }\n\n  GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree\n\n  GeneralSubtree ::= SEQUENCE {\n       base                    GeneralName,\n       minimum         [0]     BaseDistance DEFAULT 0,\n       maximum         [1]     BaseDistance OPTIONAL }\n\n  BaseDistance ::= INTEGER (0..MAX)\n\n  GeneralName ::= CHOICE {\n       otherName                       [0]     OtherName,\n       rfc822Name                      [1]     IA5String,\n       dNSName                         [2]     IA5String,\n       x400Address                     [3]     ORAddress,\n       directoryName                   [4]     Name,\n       ediPartyName                    [5]     EDIPartyName,\n       uniformResourceIdentifier       [6]     IA5String,\n       iPAddress                       [7]     OCTET STRING,\n       registeredID                    [8]     OBJECT IDENTIFIER}\n ",
        "Description": "\n The name constraints are specified as a byte array. This byte array\n should contain the DER encoded form of the name constraints, as they\n would appear in the NameConstraints structure defined in RFC 3280\n and X.509. The ASN.1 definition of this structure appears below.\n\n  \n Note that the byte array supplied here is cloned to protect against\n subsequent modifications."
    },
    {
        "API": "java.security.cert.X509CertSelector.setSubjectKeyIdentifier(byte[])",
        "Code": "\n SubjectKeyIdentifier ::= KeyIdentifier\n\n KeyIdentifier ::= OCTET STRING\n ",
        "Description": "\n \n Since the format of subject key identifiers is not mandated by\n any standard, subject key identifiers are not parsed by the\n X509CertSelector. Instead, the values are compared using\n a byte-by-byte comparison.\n "
    },
    {
        "API": "java.security.cert.X509CertSelector.setSubjectPublicKey(byte[])",
        "Code": "\n SubjectPublicKeyInfo  ::=  SEQUENCE  {\n   algorithm            AlgorithmIdentifier,\n   subjectPublicKey     BIT STRING  }\n\n AlgorithmIdentifier  ::=  SEQUENCE  {\n   algorithm               OBJECT IDENTIFIER,\n   parameters              ANY DEFINED BY algorithm OPTIONAL  }\n                              -- contains a value of the type\n                              -- registered for use with the\n                              -- algorithm object identifier value\n ",
        "Description": "\n If key is not null, it should contain a\n single DER encoded SubjectPublicKeyInfo structure, as defined in X.509.\n The ASN.1 notation for this structure is as follows.\n  \n Note that the byte array supplied here is cloned to protect against\n subsequent modifications."
    },
    {
        "API": "java.security.cert.X509CRLSelector.setIssuerNames(java.util.Collection<?>)",
        "Code": "\n Name ::= CHOICE {\n   RDNSequence }\n\n RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\n\n RelativeDistinguishedName ::=\n   SET SIZE (1 .. MAX) OF AttributeTypeAndValue\n\n AttributeTypeAndValue ::= SEQUENCE {\n   type     AttributeType,\n   value    AttributeValue }\n\n AttributeType ::= OBJECT IDENTIFIER\n\n AttributeValue ::= ANY DEFINED BY AttributeType\n ....\n DirectoryString ::= CHOICE {\n       teletexString           TeletexString (SIZE (1..MAX)),\n       printableString         PrintableString (SIZE (1..MAX)),\n       universalString         UniversalString (SIZE (1..MAX)),\n       utf8String              UTF8String (SIZE (1.. MAX)),\n       bmpString               BMPString (SIZE (1..MAX)) }\n ",
        "Description": "\n If a name is specified as a byte array, it should contain a single DER\n encoded distinguished name, as defined in X.501. The ASN.1 notation for\n this structure is as follows.\n  \n Note that a deep copy is performed on the Collection to\n protect against subsequent modifications."
    },
    {
        "API": "java.util.Random.next(int)",
        "Code": "(seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1)",
        "Description": "The general contract of next is that it returns an\n int value and if the argument bits is between\n 1 and 32 (inclusive), then that many low-order\n bits of the returned value will be (approximately) independently\n chosen bit values, each of which is (approximately) equally\n likely to be 0 or 1. The method next is\n implemented by class Random by atomically updating the seed to\n   (int)(seed >>> (48 - bits))."
    },
    {
        "API": "java.util.Random.next(int)",
        "Code": "(int)(seed >>> (48 - bits)).",
        "Description": "(seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1) The Art of Computer Programming,"
    },
    {
        "API": "java.util.Random.setSeed(long)",
        "Code": "(seed ^ 0x5DEECE66DL) & ((1L << 48) - 1)",
        "Description": "Random haveNextNextGaussian"
    },
    {
        "API": "java.util.SimpleTimeZone.SimpleTimeZone(int,java.lang.String,int,int,int,int,int,int,int,int)",
        "Code": "\n     SimpleTimeZone(rawOffset,\n                    ID,\n                    startMonth,\n                    startDay,\n                    startDayOfWeek,\n                    startTime,\n                    SimpleTimeZone.WALL_TIME,\n                    endMonth,\n                    endDay,\n                    endDayOfWeek,\n                    endTime,\n                    SimpleTimeZone.WALL_TIME,\n                    3600000)\n ",
        "Description": "endTime "
    },
    {
        "API": "java.util.SimpleTimeZone.SimpleTimeZone(int,java.lang.String,int,int,int,int,int,int,int,int,int)",
        "Code": "\n     SimpleTimeZone(rawOffset,\n                    ID,\n                    startMonth,\n                    startDay,\n                    startDayOfWeek,\n                    startTime,\n                    SimpleTimeZone.WALL_TIME,\n                    endMonth,\n                    endDay,\n                    endDayOfWeek,\n                    endTime,\n                    SimpleTimeZone.WALL_TIME,\n                    dstSavings)\n ",
        "Description": "endTime "
    },
    {
        "API": "java.util.SimpleTimeZone.setEndRule(int,int,int)",
        "Code": "setEndRule(endMonth, endDay, 0, endTime)",
        "Description": " "
    },
    {
        "API": "java.util.SimpleTimeZone.setStartRule(int,int,int,int)",
        "Code": "setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2*60*60*1000);",
        "Description": " "
    },
    {
        "API": "java.util.SimpleTimeZone.setStartRule(int,int,int)",
        "Code": "setStartRule(startMonth, startDay, 0, startTime)",
        "Description": " "
    },
    {
        "API": "java.util.jar.Pack200.Packer.CLASS_ATTRIBUTE_PFX",
        "Code": "\n     Map p = packer.properties();\n     p.put(CODE_ATTRIBUTE_PFX+\"CoverageTable\",       \"NH[PHHII]\");\n     p.put(CODE_ATTRIBUTE_PFX+\"CharacterRangeTable\", \"NH[PHPOHIIH]\");\n     p.put(CLASS_ATTRIBUTE_PFX+\"SourceID\",           \"RUH\");\n     p.put(CLASS_ATTRIBUTE_PFX+\"CompilationID\",      \"RUH\");\n ",
        "Description": "\n Code like this might be used to support attributes for JCOV:\n  \n Code like this might be used to strip debugging attributes:\n "
    },
    {
        "API": "java.util.jar.Pack200.Packer.CLASS_ATTRIBUTE_PFX",
        "Code": "\n     Map p = packer.properties();\n     p.put(CODE_ATTRIBUTE_PFX+\"LineNumberTable\",    STRIP);\n     p.put(CODE_ATTRIBUTE_PFX+\"LocalVariableTable\", STRIP);\n     p.put(CLASS_ATTRIBUTE_PFX+\"SourceFile\",        STRIP);\n ",
        "Description": "\n Code like this might be used to strip debugging attributes:\n  "
    },
    {
        "API": "java.util.jar.Pack200.Packer.PASS_FILE_PFX",
        "Code": "\n     Map p = packer.properties();\n     p.put(PASS_FILE_PFX+0, \"mutants/Rogue.class\");\n     p.put(PASS_FILE_PFX+1, \"mutants/Wolverine.class\");\n     p.put(PASS_FILE_PFX+2, \"mutants/Storm.class\");\n     # Pass all files in an entire directory hierarchy:\n     p.put(PASS_FILE_PFX+3, \"police/\");\n ",
        "Description": "\n Examples:\n  "
    },
    {
        "API": "java.util.jar.Pack200.Packer.UNKNOWN_ATTRIBUTE",
        "Code": "\n     Map p = pack200.getProperties();\n     p.put(UNKNOWN_ATTRIBUTE, ERROR);\n     p.put(UNKNOWN_ATTRIBUTE, STRIP);\n     p.put(UNKNOWN_ATTRIBUTE, PASS);\n ",
        "Description": "\n Examples:\n  "
    },
    {
        "API": "javax.imageio.stream.ImageInputStream.readUTF()",
        "Code": "\n (char)(((a& 0x1F) << 6) | (b & 0x3F))\n ",
        "Description": "  1110xxxx"
    },
    {
        "API": "javax.imageio.stream.ImageInputStream.readUTF()",
        "Code": "\n (char)(((a & 0x0F) << 12) | ((b & 0x3F) << 6) | (c & 0x3F))\n ",
        "Description": "  1111xxxx"
    },
    {
        "API": "javax.imageio.stream.ImageOutputStream.writeUTF(java.lang.String)",
        "Code": "\n (byte)c\n ",
        "Description": "  If a character c is \\u0000 or\n is in the range \\u0080 through\n \\u07ff, then it is represented by two bytes,\n to be written in the order shown:\n\n "
    },
    {
        "API": "javax.imageio.stream.ImageOutputStream.writeUTF(java.lang.String)",
        "Code": "\n (byte)(0xc0 | (0x1f & (c >> 6)))\n (byte)(0x80 | (0x3f & c))\n ",
        "Description": "   If a character c is in the range\n \\u0800 through uffff, then it is\n represented by three bytes, to be written in the order shown:\n\n "
    },
    {
        "API": "javax.imageio.stream.ImageOutputStream.writeUTF(java.lang.String)",
        "Code": "\n (byte)(0xe0 | (0x0f & (c >> 12)))\n (byte)(0x80 | (0x3f & (c >> 6)))\n (byte)(0x80 | (0x3f & c))\n ",
        "Description": "   First, the total number of bytes needed to represent all\n the characters of s is calculated. If this number\n is larger than 65535, then a\n UTFDataFormatException is thrown. Otherwise, this\n length is written to the output stream in exactly the manner of\n the writeShort method; after this, the one-, two-,\n or three-byte representation of each character in the string\n s is written.\n\n "
    },
    {
        "API": "javax.script.ScriptEngineFactory.getOutputStatement(java.lang.String)",
        "Code": "\n public String getOutputStatement(String toDisplay) {\n      return \"print(\" + toDisplay + \")\";\n }\n ",
        "Description": "\n "
    },
    {
        "API": "javax.script.ScriptEngineFactory.getProgram(java.lang.String...)",
        "Code": "\n public String getProgram(String... statements) {\n      $retval = \"<?\\n\";\n      int len = statements.length;\n      for (int i = 0; i < len; i++) {\n          $retval += statements[i] + \";\\n\";\n      }\n      $retval += \"?>\";\n\n }\n ",
        "Description": "\n "
    },
    {
        "API": "javax.security.auth.kerberos.KerberosPrincipal.hashCode()",
        "Code": "\n  hashCode = getName().hashCode();\n ",
        "Description": " "
    },
    {
        "API": "javax.security.auth.x500.X500Principal.X500Principal(byte[])",
        "Code": "\n Name ::= CHOICE {\n   RDNSequence }\n\n RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\n\n RelativeDistinguishedName ::=\n   SET SIZE (1 .. MAX) OF AttributeTypeAndValue\n\n AttributeTypeAndValue ::= SEQUENCE {\n   type     AttributeType,\n   value    AttributeValue }\n\n AttributeType ::= OBJECT IDENTIFIER\n\n AttributeValue ::= ANY DEFINED BY AttributeType\n ....\n DirectoryString ::= CHOICE {\n       teletexString           TeletexString (SIZE (1..MAX)),\n       printableString         PrintableString (SIZE (1..MAX)),\n       universalString         UniversalString (SIZE (1..MAX)),\n       utf8String              UTF8String (SIZE (1.. MAX)),\n       bmpString               BMPString (SIZE (1..MAX)) }\n ",
        "Description": "X500Principal "
    },
    {
        "API": "javax.swing.plaf.nimbus.NimbusLookAndFeel.register(javax.swing.plaf.synth.Region,java.lang.String)",
        "Code": "\n     laf.register(NimbusFooUI.FOO_REGION, \"Foo\");\n ",
        "Description": "For example, suppose I had a component named JFoo. Suppose I then registered\n this component with the NimbusLookAndFeel in this manner: In this case, I could then register properties for this component with\n UIDefaults in the following manner:"
    },
    {
        "API": "javax.swing.plaf.nimbus.NimbusLookAndFeel.register(javax.swing.plaf.synth.Region,java.lang.String)",
        "Code": "\n     UIManager.put(\"Foo.background\", new ColorUIResource(Color.BLACK));\n     UIManager.put(\"Foo.Enabled.backgroundPainter\", new FooBackgroundPainter());\n ",
        "Description": "In this case, I could then register properties for this component with\n UIDefaults in the following manner: It is also possible to register a named component with Nimbus.\n For example, suppose you wanted to style the background of a JPanel\n named \"MyPanel\" differently from other JPanels. You could accomplish this\n by doing the following:"
    },
    {
        "API": "javax.swing.plaf.nimbus.NimbusLookAndFeel.register(javax.swing.plaf.synth.Region,java.lang.String)",
        "Code": "\n     laf.register(Region.PANEL, \"\\\"MyPanel\\\"\");\n     UIManager.put(\"\\\"MyPanel\\\".background\", new ColorUIResource(Color.RED));\n ",
        "Description": "It is also possible to register a named component with Nimbus.\n For example, suppose you wanted to style the background of a JPanel\n named \"MyPanel\" differently from other JPanels. You could accomplish this\n by doing the following: "
    },
    {
        "API": "javax.swing.plaf.nimbus.State.State(java.lang.String)",
        "Code": "\n     defaults.put(\"Button.States\", \"Enabled, Foo, Disabled\");\n     defaults.put(\"Button.Foo\", new FooState(\"Foo\"));\n ",
        "Description": "For example, the following would be correct: "
    },
    {
        "API": "javax.swing.plaf.nimbus.State.isInState(javax.swing.plaf.nimbus.State)",
        "Code": " return c.isIndeterminate();",
        "Description": "Nimbus uses this method to help determine what state a JComponent is\n in. For example, a custom State could exist for JProgressBar such that\n it would return true when the progress bar is indeterminate.\n Such an implementation of this method would simply be: "
    },
    {
        "API": "javax.swing.text.Document.getText(int,int,javax.swing.text.Segment)",
        "Code": "\n\n \u00a0 int nleft = doc.getDocumentLength();\n \u00a0 Segment text = new Segment();\n \u00a0 int offs = 0;\n \u00a0 text.setPartialReturn(true);\n \u00a0 while (nleft > 0) {\n \u00a0     doc.getText(offs, nleft, text);\n \u00a0     // do someting with text\n \u00a0     nleft -= text.count;\n \u00a0     offs += text.count;\n \u00a0 }\n\n ",
        "Description": "\n "
    },
    {
        "API": "javax.swing.text.AbstractDocument.readUnlock()",
        "Code": "\n \u00a0   readLock();\n \u00a0   try {\n \u00a0       // do something\n \u00a0   } finally {\n \u00a0       readUnlock();\n \u00a0   }\n ",
        "Description": " "
    },
    {
        "API": "javax.swing.text.JTextComponent.loadKeymap(javax.swing.text.Keymap,javax.swing.text.JTextComponent.KeyBinding[],javax.swing.Action[])",
        "Code": "\n\n   static final JTextComponent.KeyBinding[] defaultBindings = {\n     new JTextComponent.KeyBinding(\n       KeyStroke.getKeyStroke(KeyEvent.VK_C, InputEvent.CTRL_MASK),\n       DefaultEditorKit.copyAction),\n     new JTextComponent.KeyBinding(\n       KeyStroke.getKeyStroke(KeyEvent.VK_V, InputEvent.CTRL_MASK),\n       DefaultEditorKit.pasteAction),\n     new JTextComponent.KeyBinding(\n       KeyStroke.getKeyStroke(KeyEvent.VK_X, InputEvent.CTRL_MASK),\n       DefaultEditorKit.cutAction),\n   };\n\n   JTextComponent c = new JTextPane();\n   Keymap k = c.getKeymap();\n   JTextComponent.loadKeymap(k, defaultBindings, c.getActions());\n\n ",
        "Description": "\n Loads a keymap with a bunch of\n bindings.  This can be used to take a static table of\n definitions and load them into some keymap.  The following\n example illustrates an example of binding some keys to\n the cut, copy, and paste actions associated with a\n JTextComponent.  A code fragment to accomplish\n this might look as follows:\n  null"
    },
    {
        "API": "java.util.function",
        "Code": "// Assignment context      Predicate<String> p = String::isEmpty;       // Method invocation context      stream.filter(e -> e.getSize() > 10)...       // Cast context      stream.map((ToIntFunction) e -> e.getSize())...  ",
        "Description": "functional method The interfaces in this package are general purpose functional interfaces  used by the JDK, and are available to be used by user code as well.  While  they do not identify a complete set of function shapes to which lambda  expressions might be adapted, they provide enough to cover common  requirements. Other functional interfaces provided for specific purposes,  such as FileFilter, are defined in the packages where they  are used.   The interfaces in this package are annotated with  FunctionalInterface. This annotation is not a requirement  for the compiler to recognize an interface as a functional interface, but  merely an aid to capture design intent and enlist the help of the compiler in  identifying accidental violations of design intent.   Functional interfaces often represent abstract concepts like functions,  actions, or predicates.  In documenting functional interfaces, or referring  to variables typed as functional interfaces, it is common to refer directly  to those abstract concepts, for example using \"this function\" instead of  \"the function represented by this object\".  When an API method is said to  accept or return a functional interface in this manner, such as \"applies the  provided function to...\", this is understood to mean a non-null  reference to an object implementing the appropriate functional interface,  unless potential nullity is explicitly specified.   The functional interfaces in this package follow an extensible naming  convention, as follows:    There are several basic function shapes, including      Function (unary function from T to R),      Consumer (unary function from T to void),      Predicate (unary function from T to boolean),      and Supplier (nilary function to R).       Function shapes have a natural arity based on how they are most      commonly used.  The basic shapes can be modified by an arity prefix to      indicate a different arity, such as      BiFunction (binary function from T and      U to R).       There are additional derived function shapes which extend the basic      function shapes, including UnaryOperator      (extends Function) and BinaryOperator      (extends BiFunction).       Type parameters of functional interfaces can be specialized to      primitives with additional type prefixes.  To specialize the return type      for a type that has both generic return type and generic arguments, we      prefix ToXxx, as in ToIntFunction.      Otherwise, type arguments are specialized left-to-right, as in      DoubleConsumer      or ObjIntConsumer.      (The type prefix Obj is used to indicate that we don't want to      specialize this parameter, but want to move on to the next parameter,      as in ObjIntConsumer.)      These schemes can be combined, as in IntToDoubleFunction.       If there are specialization prefixes for all arguments, the arity      prefix may be left out (as in ObjIntConsumer).        "
    },
    {
        "API": "java.util.stream",
        "Code": "int sum = widgets.stream()                       .filter(b -> b.getColor() == RED)                       .mapToInt(b -> b.getWeight())                       .sum();  ",
        "Description": " Here we use widgets, a Collection<Widget>,  as a source for a stream, and then perform a filter-map-reduce on the stream  to obtain the sum of the weights of the red widgets.  (Summation is an  example of a reduction  operation.)   The key abstraction introduced in this package is stream.  The  classes Stream, IntStream,  LongStream, and DoubleStream  are streams over objects and the primitive int, long and  double types.  Streams differ from collections in several ways:    No storage.  A stream is not a data structure that stores elements;      instead, it conveys elements from a source such as a data structure,      an array, a generator function, or an I/O channel, through a pipeline of      computational operations. Functional in nature.  An operation on a stream produces a result,      but does not modify its source.  For example, filtering a Stream      obtained from a collection produces a new Stream without the      filtered elements, rather than removing elements from the source      collection. Laziness-seeking.  Many stream operations, such as filtering, mapping,      or duplicate removal, can be implemented lazily, exposing opportunities      for optimization.  For example, \"find the first String with      three consecutive vowels\" need not examine all the input strings.      Stream operations are divided into intermediate (Stream-producing)      operations and terminal (value- or side-effect-producing) operations.      Intermediate operations are always lazy. Possibly unbounded.  While collections have a finite size, streams      need not.  Short-circuiting operations such as limit(n) or      findFirst() can allow computations on infinite streams to      complete in finite time. Consumable. The elements of a stream are only visited once during      the life of a stream. Like an Iterator, a new stream      must be generated to revisit the same elements of the source.          Streams can be obtained in a number of ways. Some examples include:   From a Collection via the stream() and      parallelStream() methods; From an array via stream(Object[]); From static factory methods on the stream classes, such as      of(Object[]),      range(int, int)      or iterate(Object, UnaryOperator); "
    },
    {
        "API": "java.io.Console",
        "Code": "Console cons;\n char[] passwd;\n if ((cons = System.console()) != null &&\n     (passwd = cons.readPassword(\"[%s]\", \"Password:\")) != null) {\n     ...\n     java.util.Arrays.fill(passwd, ' ');\n }\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.CallSite",
        "Code": "static void test() throws Throwable {\n    // THE FOLLOWING LINE IS PSEUDOCODE FOR A JVM INSTRUCTION\n    InvokeDynamic[#bootstrapDynamic].baz(\"baz arg\", 2, 3.14);\n}\nprivate static void printArgs(Object... args) {\n  System.out.println(java.util.Arrays.deepToString(args));\n}\nprivate static final MethodHandle printArgs;\nstatic {\n  MethodHandles.Lookup lookup = MethodHandles.lookup();\n  Class thisClass = lookup.lookupClass();  // (who am I?)\n  printArgs = lookup.findStatic(thisClass,\n      \"printArgs\", MethodType.methodType(void.class, Object[].class));\n}\nprivate static CallSite bootstrapDynamic(MethodHandles.Lookup caller, String name, MethodType type) {\n  // ignore caller and name, but match the type:\n  return new ConstantCallSite(printArgs.asType(type));\n}\n",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandle",
        "Code": "Object x, y; String s; int i;\nMethodType mt; MethodHandle mh;\nMethodHandles.Lookup lookup = MethodHandles.lookup();\n// mt is (char,char)String\nmt = MethodType.methodType(String.class, char.class, char.class);\nmh = lookup.findVirtual(String.class, \"replace\", mt);\ns = (String) mh.invokeExact(\"daddy\",'d','n');\n// invokeExact(Ljava/lang/String;CC)Ljava/lang/String;\nassertEquals(s, \"nanny\");\n// weakly typed invocation (using MHs.invoke)\ns = (String) mh.invokeWithArguments(\"sappy\", 'p', 'v');\nassertEquals(s, \"savvy\");\n// mt is (Object[])List\nmt = MethodType.methodType(java.util.List.class, Object[].class);\nmh = lookup.findStatic(java.util.Arrays.class, \"asList\", mt);\nassert(mh.isVarargsCollector());\nx = mh.invoke(\"one\", \"two\");\n// invoke(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;\nassertEquals(x, java.util.Arrays.asList(\"one\",\"two\"));\n// mt is (Object,Object,Object)Object\nmt = MethodType.genericMethodType(3);\nmh = mh.asType(mt);\nx = mh.invokeExact((Object)1, (Object)2, (Object)3);\n// invokeExact(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\nassertEquals(x, java.util.Arrays.asList(1,2,3));\n// mt is ()int\nmt = MethodType.methodType(int.class);\nmh = lookup.findVirtual(java.util.List.class, \"size\", mt);\ni = (int) mh.invokeExact(java.util.Arrays.asList(1,2,3));\n// invokeExact(Ljava/util/List;)I\nassert(i == 3);\nmt = MethodType.methodType(void.class, String.class);\nmh = lookup.findVirtual(java.io.PrintStream.class, \"println\", mt);\nmh.invokeExact(System.out, \"Hello, world.\");\n// invokeExact(Ljava/io/PrintStream;Ljava/lang/String;)V\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MutableCallSite",
        "Code": "MutableCallSite name = new MutableCallSite(MethodType.methodType(String.class));\nMethodHandle MH_name = name.dynamicInvoker();\nMethodType MT_str1 = MethodType.methodType(String.class);\nMethodHandle MH_upcase = MethodHandles.lookup()\n    .findVirtual(String.class, \"toUpperCase\", MT_str1);\nMethodHandle worker1 = MethodHandles.filterReturnValue(MH_name, MH_upcase);\nname.setTarget(MethodHandles.constant(String.class, \"Rocky\"));\nassertEquals(\"ROCKY\", (String) worker1.invokeExact());\nname.setTarget(MethodHandles.constant(String.class, \"Fred\"));\nassertEquals(\"FRED\", (String) worker1.invokeExact());\n// (mutation can be continued indefinitely)\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MutableCallSite",
        "Code": "MethodType MT_str2 = MethodType.methodType(String.class, String.class);\nMethodHandle MH_cat = lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nMethodHandle MH_dear = MethodHandles.insertArguments(MH_cat, 1, \", dear?\");\nMethodHandle worker2 = MethodHandles.filterReturnValue(MH_name, MH_dear);\nassertEquals(\"Fred, dear?\", (String) worker2.invokeExact());\nname.setTarget(MethodHandles.constant(String.class, \"Wilma\"));\nassertEquals(\"WILMA\", (String) worker1.invokeExact());\nassertEquals(\"Wilma, dear?\", (String) worker2.invokeExact());\n ",
        "Description": " "
    },
    {
        "API": "java.net.CookieManager",
        "Code": "use\n CookieHandler <------- HttpURLConnection\n       ^\n       | impl\n       |         use\n CookieManager -------> CookiePolicy\n             |   use\n             |--------> HttpCookie\n             |              ^\n             |              | use\n             |   use        |\n             |--------> CookieStore\n                            ^\n                            | impl\n                            |\n                  Internal in-memory implementation\n ",
        "Description": " \n\n     CookieHandler is at the core of cookie management. User can call\n     CookieHandler.setDefault to set a concrete CookieHanlder implementation\n     to be used.\n   \n\n     CookiePolicy.shouldAccept will be called by CookieManager.put to see whether\n     or not one cookie should be accepted and put into cookie store. User can use\n     any of three pre-defined CookiePolicy, namely ACCEPT_ALL, ACCEPT_NONE and\n     ACCEPT_ORIGINAL_SERVER, or user can define his own CookiePolicy implementation\n     and tell CookieManager to use it.\n   \n\n     CookieStore is the place where any accepted HTTP cookie is stored in.\n     If not specified when created, a CookieManager instance will use an internal\n     in-memory implementation. Or user can implements one and tell CookieManager\n     to use it.\n   \n\n     Currently, only CookieStore.add(URI, HttpCookie) and CookieStore.get(URI)\n     are used by CookieManager. Others are for completeness and might be needed\n     by a more sophisticated CookieStore implementation, e.g. a NetscapeCookieSotre.\n   \n"
    },
    {
        "API": "java.net.CookieManager",
        "Code": "\n       // this should be done at the beginning of an HTTP session\n       CookieHandler.setDefault(new CookieManager(new MyCookieStore(), new MyCookiePolicy()));\n     ",
        "Description": " "
    },
    {
        "API": "java.net.CookieManager",
        "Code": "\n       // this should be done at the beginning of an HTTP session\n       CookieHandler.setDefault(new CookieManager());\n       // this can be done at any point of an HTTP session\n       ((CookieManager)CookieHandler.getDefault()).setCookiePolicy(new MyCookiePolicy());\n     ",
        "Description": " "
    },
    {
        "API": "java.nio.channels.AsynchronousChannel",
        "Code": "Future<V> operation(...)",
        "Description": " "
    },
    {
        "API": "java.nio.channels.AsynchronousChannel",
        "Code": "void operation(... A attachment, CompletionHandler<V,? super A> handler)",
        "Description": " "
    },
    {
        "API": "java.security.DomainLoadStoreParameter",
        "Code": "domain <domainName> [<property> ...] {\n         keystore <keystoreName> [<property> ...] ;\n         ...\n     };\n     ...\n ",
        "Description": " domainName"
    },
    {
        "API": "java.security.DomainLoadStoreParameter",
        "Code": "\n\n domain app1 {\n     keystore app1-truststore\n         keystoreURI=\"file:///app1/etc/truststore.jks\";\n\n     keystore system-truststore\n         keystoreURI=\"${java.home}/lib/security/cacerts\";\n\n     keystore app1-keystore\n         keystoreType=\"PKCS12\"\n         keystoreURI=\"file:///app1/etc/keystore.p12\";\n };\n\n ",
        "Description": " "
    },
    {
        "API": "java.security.MessageDigest",
        "Code": "MessageDigest md = MessageDigest.getInstance(\"SHA\");\n\n try {\n     md.update(toChapter1);\n     MessageDigest tc1 = md.clone();\n     byte[] toChapter1Digest = tc1.digest();\n     md.update(toChapter2);\n     ...etc.\n } catch (CloneNotSupportedException cnse) {\n     throw new DigestException(\"couldn't make digest of partial content\");\n }\n ",
        "Description": " Note that if a given implementation is not cloneable, it is\n still possible to compute intermediate digests by instantiating\n several instances, if the number of digests is known in advance.\n\n Note that this class is abstract and extends from\n MessageDigestSpi for historical reasons.\n Application developers should only take notice of the methods defined in\n this MessageDigest class; all the methods in\n the superclass are intended for cryptographic service providers who wish to\n supply their own implementations of message digest algorithms.\n\n  Android provides the following MessageDigest algorithms:\n \n\n\nAlgorithm\nSupported API Levels\n\n\n\n\nMD5\n1+\n\n\nSHA-1\n1+\n\n\nSHA-224\n1-8,22+\n\n\nSHA-256\n1+\n\n\nSHA-384\n1+\n\n\nSHA-512\n1+\n\n\n\n\n These algorithms are described in the \n MessageDigest section of the\n Java Cryptography Architecture Standard Algorithm Name Documentation.\n\nSee also:\nDigestInputStreamDigestOutputStream\n\n\n"
    },
    {
        "API": "java.security.SignedObject",
        "Code": "Signature signingEngine = Signature.getInstance(algorithm,\n                                                 provider);\n SignedObject so = new SignedObject(myobject, signingKey,\n                                    signingEngine);\n ",
        "Description": "verify  A typical usage for verification is the following (having\n received SignedObject so):\n\n Signature verificationEngine =\n     Signature.getInstance(algorithm, provider);\n if (so.verify(publickey, verificationEngine))\n     try {\n         Object myobj = so.getObject();\n     } catch (java.lang.ClassNotFoundException e) {};\n \n Several points are worth noting.  First, there is no need to\n initialize the signing or verification engine, as it will be\n re-initialized inside the constructor and the verify\n method. Secondly, for verification to succeed, the specified\n public key must be the public key corresponding to the private key\n used to generate the SignedObject.\n\n  More importantly, for flexibility reasons, the\n constructor and verify method allow for\n customized signature engines, which can implement signature\n algorithms that are not installed formally as part of a crypto\n provider.  However, it is crucial that the programmer writing the\n verifier code be aware what Signature engine is being\n used, as its own implementation of the verify method\n is invoked to verify a signature.  In other words, a malicious\n Signature may choose to always return true on\n verification in an attempt to bypass a security check.\n\n  The signature algorithm can be, among others, the NIST standard\n DSA, using DSA and SHA-1.  The algorithm is specified using the\n same convention as that for signatures. The DSA algorithm using the\n SHA-1 message digest algorithm can be specified, for example, as\n \"SHA/DSA\" or \"SHA-1/DSA\" (they are equivalent).  In the case of\n RSA, there are multiple choices for the message digest algorithm,\n so the signing algorithm could be specified as, for example,\n \"MD2/RSA\", \"MD5/RSA\" or \"SHA-1/RSA\".  The algorithm name must be\n specified, as there is no default.\n\n  The name of the Cryptography Package Provider is designated\n also by the Signature parameter to the constructor and the\n verify method.  If the provider is not\n specified, the default provider is used.  Each installation can\n be configured to use a particular provider as default.\n\n  Potential applications of SignedObject include:\n \n It can be used\n internally to any Java runtime as an unforgeable authorization\n token -- one that can be passed around without the fear that the\n token can be maliciously modified without being detected.\n  It\n can be used to sign and serialize data/object for storage outside\n the Java runtime (e.g., storing critical access control data on\n disk).\n  Nested SignedObjects can be used to construct a logical\n sequence of signatures, resembling a chain of authorization and\n delegation.\n \n\nSee also:\nSignature\n\n\n"
    },
    {
        "API": "java.security.SignedObject",
        "Code": "Signature verificationEngine =\n     Signature.getInstance(algorithm, provider);\n if (so.verify(publickey, verificationEngine))\n     try {\n         Object myobj = so.getObject();\n     } catch (java.lang.ClassNotFoundException e) {};\n ",
        "Description": "so  Several points are worth noting.  First, there is no need to\n initialize the signing or verification engine, as it will be\n re-initialized inside the constructor and the verify\n method. Secondly, for verification to succeed, the specified\n public key must be the public key corresponding to the private key\n used to generate the SignedObject.\n\n  More importantly, for flexibility reasons, the\n constructor and verify method allow for\n customized signature engines, which can implement signature\n algorithms that are not installed formally as part of a crypto\n provider.  However, it is crucial that the programmer writing the\n verifier code be aware what Signature engine is being\n used, as its own implementation of the verify method\n is invoked to verify a signature.  In other words, a malicious\n Signature may choose to always return true on\n verification in an attempt to bypass a security check.\n\n  The signature algorithm can be, among others, the NIST standard\n DSA, using DSA and SHA-1.  The algorithm is specified using the\n same convention as that for signatures. The DSA algorithm using the\n SHA-1 message digest algorithm can be specified, for example, as\n \"SHA/DSA\" or \"SHA-1/DSA\" (they are equivalent).  In the case of\n RSA, there are multiple choices for the message digest algorithm,\n so the signing algorithm could be specified as, for example,\n \"MD2/RSA\", \"MD5/RSA\" or \"SHA-1/RSA\".  The algorithm name must be\n specified, as there is no default.\n\n  The name of the Cryptography Package Provider is designated\n also by the Signature parameter to the constructor and the\n verify method.  If the provider is not\n specified, the default provider is used.  Each installation can\n be configured to use a particular provider as default.\n\n  Potential applications of SignedObject include:\n \n It can be used\n internally to any Java runtime as an unforgeable authorization\n token -- one that can be passed around without the fear that the\n token can be maliciously modified without being detected.\n  It\n can be used to sign and serialize data/object for storage outside\n the Java runtime (e.g., storing critical access control data on\n disk).\n  Nested SignedObjects can be used to construct a logical\n sequence of signatures, resembling a chain of authorization and\n delegation.\n \n\nSee also:\nSignature\n\n\n"
    },
    {
        "API": "java.security.cert.CertificateFactory",
        "Code": "FileInputStream fis = new FileInputStream(filename);\n BufferedInputStream bis = new BufferedInputStream(fis);\n\n CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n\n while (bis.available() > 0) {\n    Certificate cert = cf.generateCertificate(bis);\n    System.out.println(cert.toString());\n }\n ",
        "Description": "generateCertificate The following example parses a PKCS#7-formatted certificate reply stored\n in a file and extracts all the certificates from it:\n\n \n FileInputStream fis = new FileInputStream(filename);\n CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n Collection c = cf.generateCertificates(fis);\n Iterator i = c.iterator();\n while (i.hasNext()) {\n    Certificate cert = (Certificate)i.next();\n    System.out.println(cert);\n }\n \n Android provides the following CertificateFactory types:\n \n\n\nAlgorithm\nSupported API Levels\n\n\n\n\nX.509\n1+\n\n\n\n and the following CertPath encodings:\n \n\n\nName\nSupported (API Levels)\n\n\n\n\nPKCS7\n1+\n\n\nPkiPath\n1+\n\n\n\n\n The type and encodings are described in the \n CertificateFactory section and the \n CertPath Encodings section of the\n Java Cryptography Architecture Standard Algorithm Name Documentation.\n\nSee also:\nCertificateX509CertificateCertPathCRLX509CRL\n\n\n"
    },
    {
        "API": "java.security.cert.CertificateFactory",
        "Code": "\n FileInputStream fis = new FileInputStream(filename);\n CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n Collection c = cf.generateCertificates(fis);\n Iterator i = c.iterator();\n while (i.hasNext()) {\n    Certificate cert = (Certificate)i.next();\n    System.out.println(cert);\n }\n ",
        "Description": "  Android provides the following CertificateFactory types:\n \n\n\nAlgorithm\nSupported API Levels\n\n\n\n\nX.509\n1+\n\n\n\n and the following CertPath encodings:\n \n\n\nName\nSupported (API Levels)\n\n\n\n\nPKCS7\n1+\n\n\nPkiPath\n1+\n\n\n\n\n The type and encodings are described in the \n CertificateFactory section and the \n CertPath Encodings section of the\n Java Cryptography Architecture Standard Algorithm Name Documentation."
    },
    {
        "API": "java.security.cert.X509CRL",
        "Code": "\n CertificateList  ::=  SEQUENCE  {\n     tbsCertList          TBSCertList,\n     signatureAlgorithm   AlgorithmIdentifier,\n     signature            BIT STRING  }\n ",
        "Description": " \n More information can be found in\n RFC 3280: Internet X.509\n Public Key Infrastructure Certificate and CRL Profile.\n \n The ASN.1 definition of tbsCertList is:\n \n TBSCertList  ::=  SEQUENCE  {\n     version                 Version OPTIONAL,\n                             -- if present, must be v2\n     signature               AlgorithmIdentifier,\n     issuer                  Name,\n     thisUpdate              ChoiceOfTime,\n     nextUpdate              ChoiceOfTime OPTIONAL,\n     revokedCertificates     SEQUENCE OF SEQUENCE  {\n         userCertificate         CertificateSerialNumber,\n         revocationDate          ChoiceOfTime,\n         crlEntryExtensions      Extensions OPTIONAL\n                                 -- if present, must be v2\n         }  OPTIONAL,\n     crlExtensions           [0]  EXPLICIT Extensions OPTIONAL\n                                  -- if present, must be v2\n     }\n \n\n CRLs are instantiated using a certificate factory. The following is an\n example of how to instantiate an X.509 CRL:\n try (InputStream inStream = new FileInputStream(\"fileName-of-crl\")) {\n     CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n     X509CRL crl = (X509CRL)cf.generateCRL(inStream);\n }\n \n\nSee also:\nCRLCertificateFactoryX509Extension\n\n\n"
    },
    {
        "API": "java.security.cert.X509CRL",
        "Code": "\n TBSCertList  ::=  SEQUENCE  {\n     version                 Version OPTIONAL,\n                             -- if present, must be v2\n     signature               AlgorithmIdentifier,\n     issuer                  Name,\n     thisUpdate              ChoiceOfTime,\n     nextUpdate              ChoiceOfTime OPTIONAL,\n     revokedCertificates     SEQUENCE OF SEQUENCE  {\n         userCertificate         CertificateSerialNumber,\n         revocationDate          ChoiceOfTime,\n         crlEntryExtensions      Extensions OPTIONAL\n                                 -- if present, must be v2\n         }  OPTIONAL,\n     crlExtensions           [0]  EXPLICIT Extensions OPTIONAL\n                                  -- if present, must be v2\n     }\n ",
        "Description": "tbsCertList \n CRLs are instantiated using a certificate factory. The following is an\n example of how to instantiate an X.509 CRL:\n try (InputStream inStream = new FileInputStream(\"fileName-of-crl\")) {\n     CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n     X509CRL crl = (X509CRL)cf.generateCRL(inStream);\n }\n "
    },
    {
        "API": "java.security.cert.X509CRL",
        "Code": "try (InputStream inStream = new FileInputStream(\"fileName-of-crl\")) {\n     CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n     X509CRL crl = (X509CRL)cf.generateCRL(inStream);\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.CharacterIterator",
        "Code": "public void traverseForward(CharacterIterator iter) {\n     for(char c = iter.first(); c != CharacterIterator.DONE; c = iter.next()) {\n         processChar(c);\n     }\n }\n ",
        "Description": " public void traverseBackward(CharacterIterator iter) {\n     for(char c = iter.last(); c != CharacterIterator.DONE; c = iter.previous()) {\n         processChar(c);\n     }\n }\n "
    },
    {
        "API": "java.text.CharacterIterator",
        "Code": "public void traverseBackward(CharacterIterator iter) {\n     for(char c = iter.last(); c != CharacterIterator.DONE; c = iter.previous()) {\n         processChar(c);\n     }\n }\n ",
        "Description": "public void traverseForward(CharacterIterator iter) {\n     for(char c = iter.first(); c != CharacterIterator.DONE; c = iter.next()) {\n         processChar(c);\n     }\n }\n  public void traverseOut(CharacterIterator iter, int pos) {\n     for (char c = iter.setIndex(pos);\n              c != CharacterIterator.DONE && notBoundary(c);\n              c = iter.next()) {\n     }\n     int end = iter.getIndex();\n     for (char c = iter.setIndex(pos);\n             c != CharacterIterator.DONE && notBoundary(c);\n             c = iter.previous()) {\n     }\n     int start = iter.getIndex();\n     processSection(start, end);\n }\n "
    },
    {
        "API": "java.text.CharacterIterator",
        "Code": "public void traverseOut(CharacterIterator iter, int pos) {\n     for (char c = iter.setIndex(pos);\n              c != CharacterIterator.DONE && notBoundary(c);\n              c = iter.next()) {\n     }\n     int end = iter.getIndex();\n     for (char c = iter.setIndex(pos);\n             c != CharacterIterator.DONE && notBoundary(c);\n             c = iter.previous()) {\n     }\n     int start = iter.getIndex();\n     processSection(start, end);\n }\n ",
        "Description": "public void traverseBackward(CharacterIterator iter) {\n     for(char c = iter.last(); c != CharacterIterator.DONE; c = iter.previous()) {\n         processChar(c);\n     }\n }\n  "
    },
    {
        "API": "java.text.BreakIterator",
        "Code": "\n public static void main(String args[]) {\n      if (args.length == 1) {\n          String stringToExamine = args[0];\n          //print each word in order\n          BreakIterator boundary = BreakIterator.getWordInstance();\n          boundary.setText(stringToExamine);\n          printEachForward(boundary, stringToExamine);\n          //print each sentence in reverse order\n          boundary = BreakIterator.getSentenceInstance(Locale.US);\n          boundary.setText(stringToExamine);\n          printEachBackward(boundary, stringToExamine);\n          printFirst(boundary, stringToExamine);\n          printLast(boundary, stringToExamine);\n      }\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.BreakIterator",
        "Code": "\n public static void printEachForward(BreakIterator boundary, String source) {\n     int start = boundary.first();\n     for (int end = boundary.next();\n          end != BreakIterator.DONE;\n          start = end, end = boundary.next()) {\n          System.out.println(source.substring(start,end));\n     }\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.BreakIterator",
        "Code": "\n public static void printEachBackward(BreakIterator boundary, String source) {\n     int end = boundary.last();\n     for (int start = boundary.previous();\n          start != BreakIterator.DONE;\n          end = start, start = boundary.previous()) {\n         System.out.println(source.substring(start,end));\n     }\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.BreakIterator",
        "Code": "\n public static void printFirst(BreakIterator boundary, String source) {\n     int start = boundary.first();\n     int end = boundary.next();\n     System.out.println(source.substring(start,end));\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.BreakIterator",
        "Code": "\n public static void printLast(BreakIterator boundary, String source) {\n     int end = boundary.last();\n     int start = boundary.previous();\n     System.out.println(source.substring(start,end));\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.BreakIterator",
        "Code": "\n public static void printAt(BreakIterator boundary, int pos, String source) {\n     int end = boundary.following(pos);\n     int start = boundary.previous();\n     System.out.println(source.substring(start,end));\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.BreakIterator",
        "Code": "public static int nextWordStartAfter(int pos, String text) {\n     BreakIterator wb = BreakIterator.getWordInstance();\n     wb.setText(text);\n     int last = wb.following(pos);\n     int current = wb.next();\n     while (current != BreakIterator.DONE) {\n         for (int p = last; p < current; p++) {\n             if (Character.isLetter(text.codePointAt(p)))\n                 return last;\n         }\n         last = current;\n         current = wb.next();\n     }\n     return BreakIterator.DONE;\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.ChoiceFormat",
        "Code": "\n X matches j if and only if limit[j] \u2264 X < limit[j+1]\n ",
        "Description": " "
    },
    {
        "API": "java.text.ChoiceFormat",
        "Code": "double[] limits = {1,2,3,4,5,6,7};\n String[] dayOfWeekNames = {\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thur\",\"Fri\",\"Sat\"};\n ChoiceFormat form = new ChoiceFormat(limits, dayOfWeekNames);\n ParsePosition status = new ParsePosition(0);\n for (double i = 0.0; i <= 8.0; ++i) {\n     status.setIndex(0);\n     System.out.println(i + \" -> \" + form.format(i) + \" -> \"\n                              + form.parse(form.format(i),status));\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.ChoiceFormat",
        "Code": "double[] filelimits = {0,1,2};\n String[] filepart = {\"are no files\",\"is one file\",\"are {2} files\"};\n ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);\n Format[] testFormats = {fileform, null, NumberFormat.getInstance()};\n MessageFormat pattform = new MessageFormat(\"There {0} on {1}\");\n pattform.setFormats(testFormats);\n Object[] testArgs = {null, \"ADisk\", null};\n for (int i = 0; i < 4; ++i) {\n     testArgs[0] = new Integer(i);\n     testArgs[2] = testArgs[0];\n     System.out.println(pattform.format(testArgs));\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.ChoiceFormat",
        "Code": "ChoiceFormat fmt = new ChoiceFormat(\n      \"-1#is negative| 0#is zero or fraction | 1#is one |1.0<is 1+ |2#is two |2<is more than 2.\");\n System.out.println(\"Formatter Pattern : \" + fmt.toPattern());\n\n System.out.println(\"Format with -INF : \" + fmt.format(Double.NEGATIVE_INFINITY));\n System.out.println(\"Format with -1.0 : \" + fmt.format(-1.0));\n System.out.println(\"Format with 0 : \" + fmt.format(0));\n System.out.println(\"Format with 0.9 : \" + fmt.format(0.9));\n System.out.println(\"Format with 1.0 : \" + fmt.format(1));\n System.out.println(\"Format with 1.5 : \" + fmt.format(1.5));\n System.out.println(\"Format with 2 : \" + fmt.format(2));\n System.out.println(\"Format with 2.1 : \" + fmt.format(2.1));\n System.out.println(\"Format with NaN : \" + fmt.format(Double.NaN));\n System.out.println(\"Format with +INF : \" + fmt.format(Double.POSITIVE_INFINITY));\n ",
        "Description": " "
    },
    {
        "API": "java.text.ChoiceFormat",
        "Code": "Format with -INF : is negative\n Format with -1.0 : is negative\n Format with 0 : is zero or fraction\n Format with 0.9 : is zero or fraction\n Format with 1.0 : is one\n Format with 1.5 : is 1+\n Format with 2 : is two\n Format with 2.1 : is more than 2.\n Format with NaN : is negative\n Format with +INF : is more than 2.\n ",
        "Description": " "
    },
    {
        "API": "java.text.CollationKey",
        "Code": "// Create an array of CollationKeys for the Strings to be sorted.\n Collator myCollator = Collator.getInstance();\n CollationKey[] keys = new CollationKey[3];\n keys[0] = myCollator.getCollationKey(\"Tom\");\n keys[1] = myCollator.getCollationKey(\"Dick\");\n keys[2] = myCollator.getCollationKey(\"Harry\");\n sort(keys);\n\n //...\n\n // Inside body of sort routine, compare keys this way\n if (keys[i].compareTo(keys[j]) > 0)\n    // swap keys[i] and keys[j]\n\n //...\n\n // Finally, when we've returned from sort.\n System.out.println(keys[0].getSourceString());\n System.out.println(keys[1].getSourceString());\n System.out.println(keys[2].getSourceString());\n ",
        "Description": " "
    },
    {
        "API": "java.text.Collator",
        "Code": "// Compare two strings in the default locale\n Collator myCollator = Collator.getInstance();\n if( myCollator.compare(\"abc\", \"ABC\") < 0 )\n     System.out.println(\"abc is less than ABC\");\n else\n     System.out.println(\"abc is greater than or equal to ABC\");\n ",
        "Description": " "
    },
    {
        "API": "java.text.Collator",
        "Code": "\n //Get the Collator for US English and set its strength to PRIMARY\n Collator usCollator = Collator.getInstance(Locale.US);\n usCollator.setStrength(Collator.PRIMARY);\n if( usCollator.compare(\"abc\", \"ABC\") == 0 ) {\n     System.out.println(\"Strings are equivalent\");\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.DateFormat",
        "Code": "myString = DateFormat.getDateInstance().format(myDate);\n ",
        "Description": " "
    },
    {
        "API": "java.text.DateFormat",
        "Code": "DateFormat df = DateFormat.getDateInstance();\n for (int i = 0; i < myDate.length; ++i) {\n     output.println(df.format(myDate[i]) + \"; \");\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.DateFormat",
        "Code": "DateFormat df = DateFormat.getDateInstance(DateFormat.LONG, Locale.FRANCE);\n ",
        "Description": " "
    },
    {
        "API": "java.text.DateFormat",
        "Code": "myDate = df.parse(myString);\n ",
        "Description": " "
    },
    {
        "API": "java.text.DecimalFormat",
        "Code": "\n NumberFormat f = NumberFormat.getInstance(loc);\n if (f instanceof DecimalFormat) {\n     ((DecimalFormat) f).setDecimalSeparatorAlwaysShown(true);\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.DecimalFormat",
        "Code": "\n Pattern:\n         PositivePattern\n         PositivePattern ; NegativePattern\n PositivePattern:\n         Prefixopt Number Suffixopt\n NegativePattern:\n         Prefixopt Number Suffixopt\n Prefix:\n         any Unicode characters except \\uFFFE, \\uFFFF, and special characters\n Suffix:\n         any Unicode characters except \\uFFFE, \\uFFFF, and special characters\n Number:\n         Integer Exponentopt\n         Integer . Fraction Exponentopt\n Integer:\n         MinimumInteger\n         #\n         # Integer\n         # , Integer\n MinimumInteger:\n         0\n         0 MinimumInteger\n         0 , MinimumInteger\n Fraction:\n         MinimumFractionopt OptionalFractionopt\n MinimumFraction:\n         0 MinimumFractionopt\n OptionalFraction:\n         # OptionalFractionopt\n Exponent:\n         E MinimumExponent\n MinimumExponent:\n         0 MinimumExponentopt\n ",
        "Description": " "
    },
    {
        "API": "java.text.DecimalFormat",
        "Code": "<strong>// Print out a number using the localized number, integer, currency,\n // and percent format for each locale</strong>\n Locale[] locales = NumberFormat.getAvailableLocales();\n double myNumber = -1234.56;\n NumberFormat form;\n for (int j = 0; j < 4; ++j) {\n     System.out.println(\"FORMAT\");\n     for (int i = 0; i < locales.length; ++i) {\n         if (locales[i].getCountry().length() == 0) {\n            continue; // Skip language-only locales\n         }\n         System.out.print(locales[i].getDisplayName());\n         switch (j) {\n         case 0:\n             form = NumberFormat.getInstance(locales[i]); break;\n         case 1:\n             form = NumberFormat.getIntegerInstance(locales[i]); break;\n         case 2:\n             form = NumberFormat.getCurrencyInstance(locales[i]); break;\n         default:\n             form = NumberFormat.getPercentInstance(locales[i]); break;\n         }\n         if (form instanceof DecimalFormat) {\n             System.out.print(\": \" + ((DecimalFormat) form).toPattern());\n         }\n         System.out.print(\" -> \" + form.format(myNumber));\n         try {\n             System.out.println(\" -> \" + form.parse(form.format(myNumber)));\n         } catch (ParseException e) {}\n     }\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "\n MessageFormatPattern:\n         String\n         MessageFormatPattern FormatElement String\n\n FormatElement:\n         { ArgumentIndex }\n         { ArgumentIndex , FormatType }\n         { ArgumentIndex , FormatType , FormatStyle }\n\n FormatType: one of \n         number date time choice\n\n FormatStyle:\n         short\n         medium\n         long\n         full\n         integer\n         currency\n         percent\n         SubformatPattern\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "\n int planet = 7;\n String event = \"a disturbance in the Force\";\n\n String result = MessageFormat.format(\n     \"At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.\",\n     planet, new Date(), event);\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "\n At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "\n int fileCount = 1273;\n String diskName = \"MyDisk\";\n Object[] testArgs = {new Long(fileCount), diskName};\n\n MessageFormat form = new MessageFormat(\n     \"The disk \\\"{1}\\\" contains {0} file(s).\");\n\n System.out.println(form.format(testArgs));\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "\n The disk \"MyDisk\" contains 0 file(s).\n The disk \"MyDisk\" contains 1 file(s).\n The disk \"MyDisk\" contains 1,273 file(s).\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "\n MessageFormat form = new MessageFormat(\"The disk \\\"{1}\\\" contains {0}.\");\n double[] filelimits = {0,1,2};\n String[] filepart = {\"no files\",\"one file\",\"{0,number} files\"};\n ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);\n form.setFormatByArgumentIndex(0, fileform);\n\n int fileCount = 1273;\n String diskName = \"MyDisk\";\n Object[] testArgs = {new Long(fileCount), diskName};\n\n System.out.println(form.format(testArgs));\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "\n The disk \"MyDisk\" contains no files.\n The disk \"MyDisk\" contains one file.\n The disk \"MyDisk\" contains 1,273 files.\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "form.applyPattern(\n    \"There {0,choice,0#are no files|1#is one file|1<are {0,number,integer} files}.\");\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "\n MessageFormat mf = new MessageFormat(\"{0,number,#.##}, {0,number,#.#}\");\n Object[] objs = {new Double(3.1415)};\n String result = mf.format( objs );\n // result now equals \"3.14, 3.1\"\n objs = null;\n objs = mf.parse(result, new ParsePosition(0));\n // objs now equals {new Double(3.1)}\n ",
        "Description": " "
    },
    {
        "API": "java.text.MessageFormat",
        "Code": "\n MessageFormat mf = new MessageFormat(\"{0}, {0}, {0}\");\n String forParsing = \"x, y, z\";\n Object[] objs = mf.parse(forParsing, new ParsePosition(0));\n // result now equals {new String(\"z\")}\n ",
        "Description": " "
    },
    {
        "API": "java.text.NumberFormat",
        "Code": "myString = NumberFormat.getInstance().format(myNumber);\n ",
        "Description": " "
    },
    {
        "API": "java.text.NumberFormat",
        "Code": "NumberFormat nf = NumberFormat.getInstance();\n for (int i = 0; i < myNumber.length; ++i) {\n     output.println(nf.format(myNumber[i]) + \"; \");\n }\n ",
        "Description": " "
    },
    {
        "API": "java.text.NumberFormat",
        "Code": "NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);\n ",
        "Description": " "
    },
    {
        "API": "java.text.NumberFormat",
        "Code": "myNumber = nf.parse(myString);\n ",
        "Description": " "
    },
    {
        "API": "java.util.Scanner",
        "Code": "Scanner sc = new Scanner(System.in);\n     int i = sc.nextInt();\n ",
        "Description": " "
    },
    {
        "API": "java.util.Scanner",
        "Code": "Scanner sc = new Scanner(new File(\"myNumbers\"));\n      while (sc.hasNextLong()) {\n          long aLong = sc.nextLong();\n      }\n ",
        "Description": " "
    },
    {
        "API": "java.util.Scanner",
        "Code": "String input = \"1 fish 2 fish red fish blue fish\";\n     Scanner s = new Scanner(input).useDelimiter(\"\\\\s*fish\\\\s*\");\n     System.out.println(s.nextInt());\n     System.out.println(s.nextInt());\n     System.out.println(s.next());\n     System.out.println(s.next());\n     s.close();\n ",
        "Description": " "
    },
    {
        "API": "java.util.Scanner",
        "Code": "1\n     2\n     red\n     blue\n ",
        "Description": " "
    },
    {
        "API": "java.util.Scanner",
        "Code": "String input = \"1 fish 2 fish red fish blue fish\";\n     Scanner s = new Scanner(input);\n     s.findInLine(\"(\\\\d+) fish (\\\\d+) fish (\\\\w+) fish (\\\\w+)\");\n     MatchResult result = s.match();\n     for (int i=1; i<=result.groupCount(); i++)\n         System.out.println(result.group(i));\n     s.close();\n ",
        "Description": " "
    },
    {
        "API": "java.util.SimpleTimeZone",
        "Code": "\n      // Base GMT offset: -8:00\n      // DST starts:      at 2:00am in standard time\n      //                  on the first Sunday in April\n      // DST ends:        at 2:00am in daylight time\n      //                  on the last Sunday in October\n      // Save:            1 hour\n      SimpleTimeZone(-28800000,\n                     \"America/Los_Angeles\",\n                     Calendar.APRIL, 1, -Calendar.SUNDAY,\n                     7200000,\n                     Calendar.OCTOBER, -1, Calendar.SUNDAY,\n                     7200000,\n                     3600000)\n\n      // Base GMT offset: +1:00\n      // DST starts:      at 1:00am in UTC time\n      //                  on the last Sunday in March\n      // DST ends:        at 1:00am in UTC time\n      //                  on the last Sunday in October\n      // Save:            1 hour\n      SimpleTimeZone(3600000,\n                     \"Europe/Paris\",\n                     Calendar.MARCH, -1, Calendar.SUNDAY,\n                     3600000, SimpleTimeZone.UTC_TIME,\n                     Calendar.OCTOBER, -1, Calendar.SUNDAY,\n                     3600000, SimpleTimeZone.UTC_TIME,\n                     3600000)\n ",
        "Description": " setStartRule"
    },
    {
        "API": "java.util.concurrent.CompletionStage",
        "Code": " stage.thenApply(x -> square(x))\n      .thenAccept(x -> System.out.print(x))\n      .thenRun(() -> System.out.println());",
        "Description": "run compose"
    },
    {
        "API": "java.util.concurrent.CompletionStage",
        "Code": "(result, exception) -> {\n   if (exception == null) {\n     // triggering stage completed normally\n   } else {\n     // triggering stage completed exceptionally\n   }\n }",
        "Description": "null This interface does not define methods for initially creating,\n forcibly completing normally or exceptionally, probing completion\n status or results, or awaiting completion of a stage.\n Implementations of CompletionStage may provide means of achieving\n such effects, as appropriate.  Method toCompletableFuture()\n enables interoperability among different implementations of this\n interface by providing a common conversion type."
    },
    {
        "API": "java.util.jar.Pack200",
        "Code": "import java.util.jar.Pack200;\n    import java.util.jar.Pack200.*;\n    ...\n    // Create the Packer object\n    Packer packer = Pack200.newPacker();\n\n    // Initialize the state by setting the desired properties\n    Map p = packer.properties();\n    // take more time choosing codings for better compression\n    p.put(Packer.EFFORT, \"7\");  // default is \"5\"\n    // use largest-possible archive segments (>10% better compression).\n    p.put(Packer.SEGMENT_LIMIT, \"-1\");\n    // reorder files for better compression.\n    p.put(Packer.KEEP_FILE_ORDER, Packer.FALSE);\n    // smear modification times to a single value.\n    p.put(Packer.MODIFICATION_TIME, Packer.LATEST);\n    // ignore all JAR deflation requests,\n    // transmitting a single request to use \"store\" mode.\n    p.put(Packer.DEFLATE_HINT, Packer.FALSE);\n    // discard debug attributes\n    p.put(Packer.CODE_ATTRIBUTE_PFX+\"LineNumberTable\", Packer.STRIP);\n    // throw an error if an attribute is unrecognized\n    p.put(Packer.UNKNOWN_ATTRIBUTE, Packer.ERROR);\n    // pass one class file uncompressed:\n    p.put(Packer.PASS_FILE_PFX+0, \"mutants/Rogue.class\");\n    try {\n        JarFile jarFile = new JarFile(\"/tmp/testref.jar\");\n        FileOutputStream fos = new FileOutputStream(\"/tmp/test.pack\");\n        // Call the packer\n        packer.pack(jarFile, fos);\n        jarFile.close();\n        fos.close();\n\n        File f = new File(\"/tmp/test.pack\");\n        FileOutputStream fostream = new FileOutputStream(\"/tmp/test.jar\");\n        JarOutputStream jostream = new JarOutputStream(fostream);\n        Unpacker unpacker = Pack200.newUnpacker();\n        // Call the unpacker\n        unpacker.unpack(f, jostream);\n        // Must explicitly close the output.\n        jostream.close();\n    } catch (IOException ioe) {\n        ioe.printStackTrace();\n    }\n ",
        "Description": " \n A Pack200 file compressed with gzip can be hosted on HTTP/1.1 web servers.\n The deployment applications can use \"Accept-Encoding=pack200-gzip\". This\n indicates to the server that the client application desires a version of\n the file encoded with Pack200 and further compressed with gzip. Please\n refer to  Java Deployment Guide for more details and\n techniques.\n \n Unless otherwise noted, passing a null argument to a constructor or\n method in this class will cause a NullPointerException to be thrown.\n"
    },
    {
        "API": "java.util.logging.Logger",
        "Code": "\n\n   class DiagnosisMessages {\n     static String systemHealthStatus() {\n       // collect system health information\n       ...\n     }\n   }\n   ...\n   logger.log(Level.FINER, DiagnosisMessages.systemHealthStatus());\n",
        "Description": "<String> \n\n   logger.log(Level.FINER, DiagnosisMessages::systemHealthStatus);\n"
    },
    {
        "API": "java.util.logging.Logger",
        "Code": "\n\n   logger.log(Level.FINER, DiagnosisMessages::systemHealthStatus);\n",
        "Description": "\n\n   class DiagnosisMessages {\n     static String systemHealthStatus() {\n       // collect system health information\n       ...\n     }\n   }\n   ...\n   logger.log(Level.FINER, DiagnosisMessages.systemHealthStatus());\n \n When looking for a ResourceBundle, the logger will first look at\n whether a bundle was specified using setResourceBundle, and then\n only whether a resource bundle name was specified through the getLogger factory method.\n If no ResourceBundle or no resource bundle name is found,\n then it will use the nearest ResourceBundle or resource bundle\n name inherited from its parent tree.\n When a ResourceBundle was inherited or specified through the\n setResourceBundle method, then\n that ResourceBundle will be used. Otherwise if the logger only\n has or inherited a resource bundle name, then that resource bundle name\n will be mapped to a ResourceBundle object, using the default Locale\n at the time of logging.\n When mapping resource bundle names to\n ResourceBundle objects, the logger will first try to use the\n Thread's context class\n loader"
    },
    {
        "API": "java.util.prefs.Preferences",
        "Code": "<!DOCTYPE preferences SYSTEM \"http://java.sun.com/dtd/preferences.dtd\">\n ",
        "Description": " not"
    },
    {
        "API": "java.util.prefs.Preferences",
        "Code": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n    <!-- DTD for a Preferences tree. -->\n\n    <!-- The preferences element is at the root of an XML document\n         representing a Preferences tree. -->\n    <!ELEMENT preferences (root)>\n\n    <!-- The preferences element contains an optional version attribute,\n          which specifies version of DTD. -->\n    <!ATTLIST preferences EXTERNAL_XML_VERSION CDATA \"0.0\" >\n\n    <!-- The root element has a map representing the root's preferences\n         (if any), and one node for each child of the root (if any). -->\n    <!ELEMENT root (map, node*) >\n\n    <!-- Additionally, the root contains a type attribute, which\n         specifies whether it's the system or user root. -->\n    <!ATTLIST root\n              type (system|user) #REQUIRED >\n\n    <!-- Each node has a map representing its preferences (if any),\n         and one node for each child (if any). -->\n    <!ELEMENT node (map, node*) >\n\n    <!-- Additionally, each node has a name attribute -->\n    <!ATTLIST node\n              name CDATA #REQUIRED >\n\n    <!-- A map represents the preferences stored at a node (if any). -->\n    <!ELEMENT map (entry*) >\n\n    <!-- An entry represents a single preference, which is simply\n          a key-value pair. -->\n    <!ELEMENT entry EMPTY >\n    <!ATTLIST entry\n              key   CDATA #REQUIRED\n              value CDATA #REQUIRED >\n ",
        "Description": "not Preferences"
    },
    {
        "API": "java.util.stream.BaseStream",
        "Code": "int sum = widgets.stream()\n                      .filter(w -> w.getColor() == RED)\n                      .mapToInt(w -> w.getWeight())\n                      .sum();\n ",
        "Description": "IntStream Stream"
    },
    {
        "API": "java.util.stream.Collector",
        "Code": "A a1 = supplier.get();\n     accumulator.accept(a1, t1);\n     accumulator.accept(a1, t2);\n     R r1 = finisher.apply(a1);  // result without splitting\n\n     A a2 = supplier.get();\n     accumulator.accept(a2, t1);\n     A a3 = supplier.get();\n     accumulator.accept(a3, t2);\n     R r2 = finisher.apply(combiner.apply(a2, a3));  // result with splitting\n  ",
        "Description": "r2 For collectors that do not have the UNORDERED characteristic,\n two accumulated results a1 and a2 are equivalent if\n finisher.apply(a1).equals(finisher.apply(a2)).  For unordered\n collectors, equivalence is relaxed to allow for non-equality related to\n differences in order.  (For example, an unordered collector that accumulated\n elements to a List would consider two lists equivalent if they\n contained the same elements, ignoring order.)\n\n Libraries that implement reduction based on Collector, such as\n collect(Collector), must adhere to the following constraints:\n \nThe first argument passed to the accumulator function, both\n     arguments passed to the combiner function, and the argument passed to the\n     finisher function must be the result of a previous invocation of the\n     result supplier, accumulator, or combiner functions.\nThe implementation should not do anything with the result of any of\n     the result supplier, accumulator, or combiner functions other than to\n     pass them again to the accumulator, combiner, or finisher functions,\n     or return them to the caller of the reduction operation.\nIf a result is passed to the combiner or finisher\n     function, and the same object is not returned from that function, it is\n     never used again.\nOnce a result is passed to the combiner or finisher function, it\n     is never passed to the accumulator function again.\nFor non-concurrent collectors, any result returned from the result\n     supplier, accumulator, or combiner functions must be serially\n     thread-confined.  This enables collection to occur in parallel without\n     the Collector needing to implement any additional synchronization.\n     The reduction implementation must manage that the input is properly\n     partitioned, that partitions are processed in isolation, and combining\n     happens only after accumulation is complete.\nFor concurrent collectors, an implementation is free to (but not\n     required to) implement reduction concurrently.  A concurrent reduction\n     is one where the accumulator function is called concurrently from\n     multiple threads, using the same concurrently-modifiable result container,\n     rather than keeping the result isolated during accumulation.\n     A concurrent reduction should only be applied if the collector has the\n     UNORDERED characteristics or if the\n     originating data is unordered.\n\nIn addition to the predefined implementations in Collectors, the\n static factory methods of(Supplier, BiConsumer, BinaryOperator, Characteristics)\n can be used to construct collectors.  For example, you could create a collector\n that accumulates widgets into a TreeSet with:\n\n Collector<Widget, ?, TreeSet<Widget>> intoSet =\n         Collector.of(TreeSet::new, TreeSet::add,\n                      (left, right) -> { left.addAll(right); return left; });\n \n\n (This behavior is also implemented by the predefined collector\n toCollection(Supplier)).\n\nSee also:\ncollect(Collector)Collectors\n\n\n"
    },
    {
        "API": "java.util.stream.Collector",
        "Code": "Collector<Widget, ?, TreeSet<Widget>> intoSet =\n         Collector.of(TreeSet::new, TreeSet::add,\n                      (left, right) -> { left.addAll(right); return left; });\n ",
        "Description": "TreeSet toCollection(Supplier)"
    },
    {
        "API": "java.util.stream.DoubleStream",
        "Code": "double sum = widgets.stream()\n                         .filter(w -> w.getColor() == RED)\n                         .mapToDouble(w -> w.getWeight())\n                         .sum();\n ",
        "Description": "DoubleStream Stream"
    },
    {
        "API": "java.util.stream.IntStream",
        "Code": "int sum = widgets.stream()\n                      .filter(w -> w.getColor() == RED)\n                      .mapToInt(w -> w.getWeight())\n                      .sum();\n ",
        "Description": "IntStream Stream"
    },
    {
        "API": "java.util.stream.LongStream",
        "Code": "long sum = widgets.stream()\n                       .filter(w -> w.getColor() == RED)\n                       .mapToLong(w -> w.getWeight())\n                       .sum();\n ",
        "Description": "LongStream Stream"
    },
    {
        "API": "java.util.stream.Stream",
        "Code": "int sum = widgets.stream()\n                      .filter(w -> w.getColor() == RED)\n                      .mapToInt(w -> w.getWeight())\n                      .sum();\n ",
        "Description": "IntStream widgets"
    },
    {
        "API": "java.util.stream.Collectors",
        "Code": "// Accumulate names into a List\n     List<String> list = people.stream().map(Person::getName).collect(Collectors.toList());\n\n     // Accumulate names into a TreeSet\n     Set<String> set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::new));\n\n     // Convert elements to strings and concatenate them, separated by commas\n     String joined = things.stream()\n                           .map(Object::toString)\n                           .collect(Collectors.joining(\", \"));\n\n     // Compute sum of salaries of employee\n     int total = employees.stream()\n                          .collect(Collectors.summingInt(Employee::getSalary)));\n\n     // Group employees by department\n     Map<Department, List<Employee>> byDept\n         = employees.stream()\n                    .collect(Collectors.groupingBy(Employee::getDepartment));\n\n     // Compute sum of salaries by department\n     Map<Department, Integer> totalByDept\n         = employees.stream()\n                    .collect(Collectors.groupingBy(Employee::getDepartment,\n                                                   Collectors.summingInt(Employee::getSalary)));\n\n     // Partition students into passing and failing\n     Map<Boolean, List<Student>> passingFailing =\n         students.stream()\n                 .collect(Collectors.partitioningBy(s -> s.getGrade() >= PASS_THRESHOLD));\n\n ",
        "Description": " "
    },
    {
        "API": "javax.net.ssl.SSLEngine",
        "Code": "\n                   app data\n\n                |           ^\n                |     |     |\n                v     |     |\n           +----+-----|-----+----+\n           |          |          |\n           |       SSL|Engine    |\n   wrap()  |          |          |  unwrap()\n           | OUTBOUND | INBOUND  |\n           |          |          |\n           +----+-----|-----+----+\n                |     |     ^\n                |     |     |\n                v           |\n\n                   net data\n ",
        "Description": "SSLEngine \n (In the context of an SSLEngine, the term \"handshake\n data\" is taken to mean any data exchanged to establish and control a\n secure connection.  Handshake data includes the SSL/TLS messages\n \"alert\", \"change_cipher_spec,\" and \"handshake.\")\n \n There are five distinct phases to an SSLEngine.\n\n \n Creation - The SSLEngine has been created and\n     initialized, but has not yet been used.  During this phase, an\n     application may set any SSLEngine-specific settings\n     (enabled cipher suites, whether the SSLEngine should\n     handshake in client or server mode, and so on).  Once\n     handshaking has begun, though, any new settings (except\n     client/server mode, see below) will be used for\n     the next handshake.\n\n      Initial Handshake - The initial handshake is a procedure by\n     which the two peers exchange communication parameters until an\n     SSLSession is established.  Application data can not be sent during\n     this phase.\n\n      Application Data - Once the communication parameters have\n     been established and the handshake is complete, application data\n     may flow through the SSLEngine.  Outbound\n     application messages are encrypted and integrity protected,\n     and inbound messages reverse the process.\n\n       Rehandshaking - Either side may request a renegotiation of\n     the session at any time during the Application Data phase.  New\n     handshaking data can be intermixed among the application data.\n     Before starting the rehandshake phase, the application may\n     reset the SSL/TLS communication parameters such as the list of\n     enabled ciphersuites and whether to use client authentication,\n     but can not change between client/server modes.  As before, once\n     handshaking has begun, any new SSLEngine\n     configuration settings will not be used until the next\n     handshake.\n\n       Closure - When the connection is no longer needed, the\n     application should close the SSLEngine and should\n     send/receive any remaining messages to the peer before\n     closing the underlying transport mechanism.  Once an engine is\n     closed, it is not reusable:  a new SSLEngine must\n     be created.\n \n An SSLEngine is created by calling createSSLEngine() from an initialized\n SSLContext.  Any configuration\n parameters should be set before making the first call to\n wrap(), unwrap(), or\n beginHandshake().  These methods all trigger the\n initial handshake.\n \n Data moves through the engine by calling wrap() or unwrap() on outbound or inbound data, respectively.  Depending on\n the state of the SSLEngine, a wrap() call\n may consume application data from the source buffer and may produce\n network data in the destination buffer.  The outbound data\n may contain application and/or handshake data.  A call to\n unwrap() will examine the source buffer and may\n advance the handshake if the data is handshaking information, or\n may place application data in the destination buffer if the data\n is application.  The state of the underlying SSL/TLS algorithm\n will determine when data is consumed and produced.\n \n Calls to wrap() and unwrap() return an\n SSLEngineResult which indicates the status of the\n operation, and (optionally) how to interact with the engine to make\n progress.\n \n The SSLEngine produces/consumes complete SSL/TLS\n packets only, and does not store application data internally between\n calls to wrap()/unwrap().  Thus input and output\n ByteBuffers must be sized appropriately to hold the\n maximum record that can be produced.  Calls to getPacketBufferSize() and getApplicationBufferSize() should be used to determine\n the appropriate buffer sizes.  The size of the outbound application\n data buffer generally does not matter.  If buffer conditions do not\n allow for the proper consumption/production of data, the application\n must determine (via SSLEngineResult) and correct the\n problem, and then try the call again.\n \n For example, unwrap() will return a BUFFER_OVERFLOW result if the engine\n determines that there is not enough destination buffer space available.\n Applications should call getApplicationBufferSize()\n and compare that value with the space available in the destination buffer,\n enlarging the buffer if necessary.  Similarly, if unwrap()\n were to return a BUFFER_UNDERFLOW, the\n application should call getPacketBufferSize() to ensure\n that the source buffer has enough room to hold a record (enlarging if\n necessary), and then obtain more inbound data.\n\n SSLEngineResult r = engine.unwrap(src, dst);\n   switch (r.getStatus()) {\n   BUFFER_OVERFLOW:\n       // Could attempt to drain the dst buffer of any already obtained\n       // data, but we'll just increase it to the size needed.\n       int appSize = engine.getSession().getApplicationBufferSize();\n       ByteBuffer b = ByteBuffer.allocate(appSize + dst.position());\n       dst.flip();\n       b.put(dst);\n       dst = b;\n       // retry the operation.\n       break;\n   BUFFER_UNDERFLOW:\n       int netSize = engine.getSession().getPacketBufferSize();\n       // Resize buffer if needed.\n       if (netSize > dst.capacity()) {\n           ByteBuffer b = ByteBuffer.allocate(netSize);\n           src.flip();\n           b.put(src);\n           src = b;\n       }\n       // Obtain more inbound network data for src,\n       // then retry the operation.\n       break;\n   // other cases: CLOSED, OK.\n   }\n \n\n Unlike SSLSocket, all methods of SSLEngine are\n non-blocking.  SSLEngine implementations may\n require the results of tasks that may take an extended period of\n time to complete, or may even block.  For example, a TrustManager\n may need to connect to a remote certificate validation service,\n or a KeyManager might need to prompt a user to determine which\n certificate to use as part of client authentication.  Additionally,\n creating cryptographic signatures and verifying them can be slow,\n seemingly blocking.\n \n For any operation which may potentially block, the\n SSLEngine will create a Runnable\n delegated task.  When SSLEngineResult indicates that a\n delegated task result is needed, the application must call getDelegatedTask() to obtain an outstanding delegated task and\n call its run() method (possibly using\n a different thread depending on the compute strategy).  The\n application should continue obtaining delegated tasks until no more\n exist, and try the original operation again.\n \n At the end of a communication session, applications should properly\n close the SSL/TLS link.  The SSL/TLS protocols have closure handshake\n messages, and these messages should be communicated to the peer\n before releasing the SSLEngine and closing the\n underlying transport mechanism.  A close can be initiated by one of:\n an SSLException, an inbound closure handshake message, or one of the\n close methods.  In all cases, closure handshake messages are\n generated by the engine, and wrap() should be repeatedly\n called until the resulting SSLEngineResult's status\n returns \"CLOSED\", or isOutboundDone() returns true.  All\n data obtained from the wrap() method should be sent to the\n peer.\n \ncloseOutbound() is used to signal the engine that the\n application will not be sending any more data.\n \n A peer will signal its intent to close by sending its own closure\n handshake message.  After this message has been received and\n processed by the local SSLEngine's unwrap()\n call, the application can detect the close by calling\n unwrap() and looking for a SSLEngineResult\n with status \"CLOSED\", or if isInboundDone() returns true.\n If for some reason the peer closes the communication link without\n sending the proper SSL/TLS closure message, the application can\n detect the end-of-stream and can signal the engine via closeInbound() that there will no more inbound messages to\n process.  Some applications might choose to require orderly shutdown\n messages from a peer, in which case they can check that the closure\n was generated by a handshake message and not by an end-of-stream\n condition.\n \n There are two groups of cipher suites which you will need to know\n about when managing cipher suites:\n\n \n Supported cipher suites:  all the suites which are\n      supported by the SSL implementation.  This list is reported\n      using getSupportedCipherSuites().\n\n       Enabled cipher suites, which may be fewer than\n      the full set of supported suites.  This group is set using the\n      setEnabledCipherSuites(String[]) method, and\n      queried using the getEnabledCipherSuites() method.\n      Initially, a default set of cipher suites will be enabled on a\n      new engine that represents the minimum suggested\n      configuration.\n \n\n Implementation defaults require that only cipher suites which\n authenticate servers and provide confidentiality be enabled by\n default.  Only if both sides explicitly agree to unauthenticated\n and/or non-private (unencrypted) communications will such a\n cipher suite be selected.\n \n Each SSL/TLS connection must have one client and one server, thus\n each endpoint must decide which role to assume.  This choice determines\n who begins the handshaking process as well as which type of messages\n should be sent by each party.  The method setUseClientMode(boolean) configures the mode.  Once the initial\n handshaking has started, an SSLEngine can not switch\n between client and server modes, even when performing renegotiations.\n \n Applications might choose to process delegated tasks in different\n threads.  When an SSLEngine\n is created, the current AccessControlContext\n is saved.  All future delegated tasks will be processed using this\n context:  that is, all access control decisions will be made using the\n context captured at engine creation.\n\n \nConcurrency Notes:\n There are two concurrency issues to be aware of:\n\n \nThe wrap() and unwrap() methods\n      may execute concurrently of each other.\n\n       The SSL/TLS protocols employ ordered packets.\n      Applications must take care to ensure that generated packets\n      are delivered in sequence.  If packets arrive\n      out-of-order, unexpected or fatal results may occur.\n \n      For example:\n\n      \n              synchronized (outboundLock) {\n                  sslEngine.wrap(src, dst);\n                  outboundQueue.put(dst);\n              }\n      \n\n      As a corollary, two threads must not attempt to call the same method\n      (either wrap() or unwrap()) concurrently,\n      because there is no way to guarantee the eventual packet ordering.\n \nDefault configuration for different Android versions\nSSLEngine instances obtained from default SSLContext are configured as\n follows:\n\n \n   tr.deprecated {\n     background-color: #ccc;\n     color: #999;\n     font-style: italic;\n   }\n \nProtocols\n\n\n\nProtocol\nSupported (API Levels)\nEnabled by default (API Levels)\n\n\n\n\nSSLv3\n1\u201325\n1\u201322\n\n\nTLSv1\n1+\n1+\n\n\nTLSv1.1\n20+\n20+\n\n\nTLSv1.2\n20+\n20+\n\n\n\nCipher suites\n\n\n\nCipher suite\nSupported (API Levels)\nEnabled by default (API Levels)\n\n\n\n\nSSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA\n9-22\n9-19\n\n\nSSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA\n9-22\n9-19\n\n\nSSL_DHE_DSS_WITH_DES_CBC_SHA\n9-22\n9-19\n\n\nSSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA\n9-22\n9-19\n\n\nSSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA\n9-22\n9-19\n\n\nSSL_DHE_RSA_WITH_DES_CBC_SHA\n9-22\n9-19\n\n\nSSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA\n9-22\n\n\n\nSSL_DH_anon_EXPORT_WITH_RC4_40_MD5\n9-22\n\n\n\nSSL_DH_anon_WITH_3DES_EDE_CBC_SHA\n9-22\n\n\n\nSSL_DH_anon_WITH_DES_CBC_SHA\n9-22\n\n\n\nSSL_DH_anon_WITH_RC4_128_MD5\n9-22\n\n\n\nSSL_RSA_EXPORT_WITH_DES40_CBC_SHA\n9-22\n9-19\n\n\nSSL_RSA_EXPORT_WITH_RC4_40_MD5\n9-22\n9-19\n\n\nSSL_RSA_WITH_3DES_EDE_CBC_SHA\n9+\n9-19\n\n\nSSL_RSA_WITH_DES_CBC_SHA\n9-22\n9-19\n\n\nSSL_RSA_WITH_NULL_MD5\n9-22\n\n\n\nSSL_RSA_WITH_NULL_SHA\n9-22\n\n\n\nSSL_RSA_WITH_RC4_128_MD5\n9-25\n9-19\n\n\nSSL_RSA_WITH_RC4_128_SHA\n9-25\n9-23\n\n\nTLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA\n1-8\n1-8\n\n\nTLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA\n1-8\n1-8\n\n\nTLS_DHE_DSS_WITH_AES_128_CBC_SHA\n9-22\n9-22\n\n\nTLS_DHE_DSS_WITH_AES_128_CBC_SHA256\n20-22\n\n\n\nTLS_DHE_DSS_WITH_AES_128_GCM_SHA256\n20-22\n\n\n\nTLS_DHE_DSS_WITH_AES_256_CBC_SHA\n9-22\n20-22\n\n\nTLS_DHE_DSS_WITH_AES_256_CBC_SHA256\n20-22\n\n\n\nTLS_DHE_DSS_WITH_AES_256_GCM_SHA384\n20-22\n\n\n\nTLS_DHE_DSS_WITH_DES_CBC_SHA\n1-8\n1-8\n\n\nTLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA\n1-8\n1-8\n\n\nTLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA\n1-8\n1-8\n\n\nTLS_DHE_RSA_WITH_AES_128_CBC_SHA\n9-25\n9-25\n\n\nTLS_DHE_RSA_WITH_AES_128_CBC_SHA256\n20-25\n\n\n\nTLS_DHE_RSA_WITH_AES_128_GCM_SHA256\n20-25\n20-25\n\n\nTLS_DHE_RSA_WITH_AES_256_CBC_SHA\n9-25\n20-25\n\n\nTLS_DHE_RSA_WITH_AES_256_CBC_SHA256\n20-25\n\n\n\nTLS_DHE_RSA_WITH_AES_256_GCM_SHA384\n20-25\n20-25\n\n\nTLS_DHE_RSA_WITH_DES_CBC_SHA\n1-8\n1-8\n\n\nTLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA\n1-8\n\n\n\nTLS_DH_DSS_WITH_3DES_EDE_CBC_SHA\n1-8\n\n\n\nTLS_DH_DSS_WITH_DES_CBC_SHA\n1-8\n\n\n\nTLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA\n1-8\n\n\n\nTLS_DH_RSA_WITH_3DES_EDE_CBC_SHA\n1-8\n\n\n\nTLS_DH_RSA_WITH_DES_CBC_SHA\n1-8\n\n\n\nTLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA\n1-8\n\n\n\nTLS_DH_anon_WITH_3DES_EDE_CBC_SHA\n1-8\n\n\n\nTLS_DH_anon_WITH_AES_128_CBC_SHA\n9-22\n\n\n\nTLS_DH_anon_WITH_AES_128_CBC_SHA256\n20-22\n\n\n\nTLS_DH_anon_WITH_AES_128_GCM_SHA256\n20-22\n\n\n\nTLS_DH_anon_WITH_AES_256_CBC_SHA\n9-22\n\n\n\nTLS_DH_anon_WITH_AES_256_CBC_SHA256\n20-22\n\n\n\nTLS_DH_anon_WITH_AES_256_GCM_SHA384\n20-22\n\n\n\nTLS_DH_anon_WITH_DES_CBC_SHA\n1-8\n\n\n\nTLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA\n20-22\n\n\n\nTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\n20+\n20+\n\n\nTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\n20+\n\n\n\nTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\n20+\n20+\n\n\nTLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\n20+\n20+\n\n\nTLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\n20+\n\n\n\nTLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\n20+\n20+\n\n\nTLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\n24+\n24+\n\n\nTLS_ECDHE_ECDSA_WITH_NULL_SHA\n20-22\n\n\n\nTLS_ECDHE_ECDSA_WITH_RC4_128_SHA\n20-25\n20-23\n\n\nTLS_ECDHE_PSK_WITH_AES_128_CBC_SHA\n21+\n21+\n\n\nTLS_ECDHE_PSK_WITH_AES_256_CBC_SHA\n21+\n21+\n\n\nTLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256\n24+\n24+\n\n\nTLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\n20-22\n\n\n\nTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\n20+\n20+\n\n\nTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\n20+\n\n\n\nTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n20+\n20+\n\n\nTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n20+\n20+\n\n\nTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384\n20+\n\n\n\nTLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\n20+\n20+\n\n\nTLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\n24+\n24+\n\n\nTLS_ECDHE_RSA_WITH_NULL_SHA\n20-22\n\n\n\nTLS_ECDHE_RSA_WITH_RC4_128_SHA\n20-25\n20-23\n\n\nTLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA\n20-22\n\n\n\nTLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA\n20-22\n\n\n\nTLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256\n20-22\n\n\n\nTLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256\n20-22\n\n\n\nTLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA\n20-22\n\n\n\nTLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384\n20-22\n\n\n\nTLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384\n20-22\n\n\n\nTLS_ECDH_ECDSA_WITH_NULL_SHA\n20-22\n\n\n\nTLS_ECDH_ECDSA_WITH_RC4_128_SHA\n20-22\n\n\n\nTLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA\n20-22\n\n\n\nTLS_ECDH_RSA_WITH_AES_128_CBC_SHA\n20-22\n\n\n\nTLS_ECDH_RSA_WITH_AES_128_CBC_SHA256\n20-22\n\n\n\nTLS_ECDH_RSA_WITH_AES_128_GCM_SHA256\n20-22\n\n\n\nTLS_ECDH_RSA_WITH_AES_256_CBC_SHA\n20-22\n\n\n\nTLS_ECDH_RSA_WITH_AES_256_CBC_SHA384\n20-22\n\n\n\nTLS_ECDH_RSA_WITH_AES_256_GCM_SHA384\n20-22\n\n\n\nTLS_ECDH_RSA_WITH_NULL_SHA\n20-22\n\n\n\nTLS_ECDH_RSA_WITH_RC4_128_SHA\n20-22\n\n\n\nTLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA\n20-22\n\n\n\nTLS_ECDH_anon_WITH_AES_128_CBC_SHA\n20-22\n\n\n\nTLS_ECDH_anon_WITH_AES_256_CBC_SHA\n20-22\n\n\n\nTLS_ECDH_anon_WITH_NULL_SHA\n20-22\n\n\n\nTLS_ECDH_anon_WITH_RC4_128_SHA\n20-22\n\n\n\nTLS_EMPTY_RENEGOTIATION_INFO_SCSV\n20+\n20+\n\n\nTLS_FALLBACK_SCSV\n21+\n\n\n\nTLS_NULL_WITH_NULL_NULL\n1-8\n\n\n\nTLS_PSK_WITH_3DES_EDE_CBC_SHA\n21-22\n\n\n\nTLS_PSK_WITH_AES_128_CBC_SHA\n21+\n21+\n\n\nTLS_PSK_WITH_AES_256_CBC_SHA\n21+\n21+\n\n\nTLS_PSK_WITH_RC4_128_SHA\n21-25\n\n\n\nTLS_RSA_EXPORT_WITH_DES40_CBC_SHA\n1-8\n1-8\n\n\nTLS_RSA_WITH_3DES_EDE_CBC_SHA\n1-8\n1-8\n\n\nTLS_RSA_WITH_AES_128_CBC_SHA\n9+\n9+\n\n\nTLS_RSA_WITH_AES_128_CBC_SHA256\n20+\n\n\n\nTLS_RSA_WITH_AES_128_GCM_SHA256\n20+\n20+\n\n\nTLS_RSA_WITH_AES_256_CBC_SHA\n9+\n20+\n\n\nTLS_RSA_WITH_AES_256_CBC_SHA256\n20+\n\n\n\nTLS_RSA_WITH_AES_256_GCM_SHA384\n20+\n20+\n\n\nTLS_RSA_WITH_DES_CBC_SHA\n1-8\n1-8\n\n\nTLS_RSA_WITH_NULL_MD5\n1-8\n\n\n\nTLS_RSA_WITH_NULL_SHA\n1-8\n\n\n\nTLS_RSA_WITH_NULL_SHA256\n20-22\n\n\n\n\nNOTE: PSK cipher suites are enabled by default only if the SSLContext through\n which the engine was created has been initialized with a PSKKeyManager.\n\nSee also:\nSSLContextSSLSocketSSLServerSocketSSLSessionSocket\n\n\n"
    },
    {
        "API": "javax.net.ssl.SSLEngine",
        "Code": "SSLEngineResult r = engine.unwrap(src, dst);\n   switch (r.getStatus()) {\n   BUFFER_OVERFLOW:\n       // Could attempt to drain the dst buffer of any already obtained\n       // data, but we'll just increase it to the size needed.\n       int appSize = engine.getSession().getApplicationBufferSize();\n       ByteBuffer b = ByteBuffer.allocate(appSize + dst.position());\n       dst.flip();\n       b.put(dst);\n       dst = b;\n       // retry the operation.\n       break;\n   BUFFER_UNDERFLOW:\n       int netSize = engine.getSession().getPacketBufferSize();\n       // Resize buffer if needed.\n       if (netSize > dst.capacity()) {\n           ByteBuffer b = ByteBuffer.allocate(netSize);\n           src.flip();\n           b.put(src);\n           src = b;\n       }\n       // Obtain more inbound network data for src,\n       // then retry the operation.\n       break;\n   // other cases: CLOSED, OK.\n   }\n ",
        "Description": "getPacketBufferSize() \n Unlike SSLSocket, all methods of SSLEngine are\n non-blocking.  SSLEngine implementations may\n require the results of tasks that may take an extended period of\n time to complete, or may even block.  For example, a TrustManager\n may need to connect to a remote certificate validation service,\n or a KeyManager might need to prompt a user to determine which\n certificate to use as part of client authentication.  Additionally,\n creating cryptographic signatures and verifying them can be slow,\n seemingly blocking.\n \n For any operation which may potentially block, the\n SSLEngine will create a Runnable\n delegated task.  When SSLEngineResult indicates that a\n delegated task result is needed, the application must call getDelegatedTask() to obtain an outstanding delegated task and\n call its run() method (possibly using\n a different thread depending on the compute strategy).  The\n application should continue obtaining delegated tasks until no more\n exist, and try the original operation again.\n \n At the end of a communication session, applications should properly\n close the SSL/TLS link.  The SSL/TLS protocols have closure handshake\n messages, and these messages should be communicated to the peer\n before releasing the SSLEngine and closing the\n underlying transport mechanism.  A close can be initiated by one of:\n an SSLException, an inbound closure handshake message, or one of the\n close methods.  In all cases, closure handshake messages are\n generated by the engine, and wrap() should be repeatedly\n called until the resulting SSLEngineResult's status\n returns \"CLOSED\", or isOutboundDone() returns true.  All\n data obtained from the wrap() method should be sent to the\n peer.\n \ncloseOutbound() is used to signal the engine that the\n application will not be sending any more data.\n \n A peer will signal its intent to close by sending its own closure\n handshake message.  After this message has been received and\n processed by the local SSLEngine's unwrap()\n call, the application can detect the close by calling\n unwrap() and looking for a SSLEngineResult\n with status \"CLOSED\", or if isInboundDone() returns true.\n If for some reason the peer closes the communication link without\n sending the proper SSL/TLS closure message, the application can\n detect the end-of-stream and can signal the engine via closeInbound() that there will no more inbound messages to\n process.  Some applications might choose to require orderly shutdown\n messages from a peer, in which case they can check that the closure\n was generated by a handshake message and not by an end-of-stream\n condition.\n \n There are two groups of cipher suites which you will need to know\n about when managing cipher suites:\n\n \n Supported cipher suites:  all the suites which are\n      supported by the SSL implementation.  This list is reported\n      using getSupportedCipherSuites().\n\n       Enabled cipher suites, which may be fewer than\n      the full set of supported suites.  This group is set using the\n      setEnabledCipherSuites(String[]) method, and\n      queried using the getEnabledCipherSuites() method.\n      Initially, a default set of cipher suites will be enabled on a\n      new engine that represents the minimum suggested\n      configuration.\n \n\n Implementation defaults require that only cipher suites which\n authenticate servers and provide confidentiality be enabled by\n default.  Only if both sides explicitly agree to unauthenticated\n and/or non-private (unencrypted) communications will such a\n cipher suite be selected.\n \n Each SSL/TLS connection must have one client and one server, thus\n each endpoint must decide which role to assume.  This choice determines\n who begins the handshaking process as well as which type of messages\n should be sent by each party.  The method setUseClientMode(boolean) configures the mode.  Once the initial\n handshaking has started, an SSLEngine can not switch\n between client and server modes, even when performing renegotiations.\n \n Applications might choose to process delegated tasks in different\n threads.  When an SSLEngine\n is created, the current AccessControlContext\n is saved.  All future delegated tasks will be processed using this\n context:  that is, all access control decisions will be made using the\n context captured at engine creation.\n\n \nConcurrency Notes:\n There are two concurrency issues to be aware of:\n\n \nThe wrap() and unwrap() methods\n      may execute concurrently of each other.\n\n       The SSL/TLS protocols employ ordered packets.\n      Applications must take care to ensure that generated packets\n      are delivered in sequence.  If packets arrive\n      out-of-order, unexpected or fatal results may occur.\n \n      For example:\n\n      \n              synchronized (outboundLock) {\n                  sslEngine.wrap(src, dst);\n                  outboundQueue.put(dst);\n              }\n      \n\n      As a corollary, two threads must not attempt to call the same method\n      (either wrap() or unwrap()) concurrently,\n      because there is no way to guarantee the eventual packet ordering.\n \nDefault configuration for different Android versions\nSSLEngine instances obtained from default SSLContext are configured as\n follows:\n\n \n   tr.deprecated {\n     background-color: #ccc;\n     color: #999;\n     font-style: italic;\n   }\n \nProtocols\n\n\n\nProtocol\nSupported (API Levels)\nEnabled by default (API Levels)\n\n\n\n\nSSLv3\n1\u201325\n1\u201322\n\n\nTLSv1\n1+\n1+\n\n\nTLSv1.1\n20+\n20+\n\n\nTLSv1.2\n20+\n20+\n\n\n\nCipher suites\n\n\n\nCipher suite\nSupported (API Levels)\nEnabled by default (API Levels)\n\n\n\n\nSSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA\n9-22\n9-19\n\n\nSSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA\n9-22\n9-19\n\n\nSSL_DHE_DSS_WITH_DES_CBC_SHA\n9-22\n9-19\n\n\nSSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA\n9-22\n9-19\n\n\nSSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA\n9-22\n9-19\n\n\nSSL_DHE_RSA_WITH_DES_CBC_SHA\n9-22\n9-19\n\n\nSSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA\n9-22\n\n\n\nSSL_DH_anon_EXPORT_WITH_RC4_40_MD5\n9-22\n\n\n\nSSL_DH_anon_WITH_3DES_EDE_CBC_SHA\n9-22\n\n\n\nSSL_DH_anon_WITH_DES_CBC_SHA\n9-22\n\n\n\nSSL_DH_anon_WITH_RC4_128_MD5\n9-22\n\n\n\nSSL_RSA_EXPORT_WITH_DES40_CBC_SHA\n9-22\n9-19\n\n\nSSL_RSA_EXPORT_WITH_RC4_40_MD5\n9-22\n9-19\n\n\nSSL_RSA_WITH_3DES_EDE_CBC_SHA\n9+\n9-19\n\n\nSSL_RSA_WITH_DES_CBC_SHA\n9-22\n9-19\n\n\nSSL_RSA_WITH_NULL_MD5\n9-22\n\n\n\nSSL_RSA_WITH_NULL_SHA\n9-22\n\n\n\nSSL_RSA_WITH_RC4_128_MD5\n9-25\n9-19\n\n\nSSL_RSA_WITH_RC4_128_SHA\n9-25\n9-23\n\n\nTLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA\n1-8\n1-8\n\n\nTLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA\n1-8\n1-8\n\n\nTLS_DHE_DSS_WITH_AES_128_CBC_SHA\n9-22\n9-22\n\n\nTLS_DHE_DSS_WITH_AES_128_CBC_SHA256\n20-22\n\n\n\nTLS_DHE_DSS_WITH_AES_128_GCM_SHA256\n20-22\n\n\n\nTLS_DHE_DSS_WITH_AES_256_CBC_SHA\n9-22\n20-22\n\n\nTLS_DHE_DSS_WITH_AES_256_CBC_SHA256\n20-22\n\n\n\nTLS_DHE_DSS_WITH_AES_256_GCM_SHA384\n20-22\n\n\n\nTLS_DHE_DSS_WITH_DES_CBC_SHA\n1-8\n1-8\n\n\nTLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA\n1-8\n1-8\n\n\nTLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA\n1-8\n1-8\n\n\nTLS_DHE_RSA_WITH_AES_128_CBC_SHA\n9-25\n9-25\n\n\nTLS_DHE_RSA_WITH_AES_128_CBC_SHA256\n20-25\n\n\n\nTLS_DHE_RSA_WITH_AES_128_GCM_SHA256\n20-25\n20-25\n\n\nTLS_DHE_RSA_WITH_AES_256_CBC_SHA\n9-25\n20-25\n\n\nTLS_DHE_RSA_WITH_AES_256_CBC_SHA256\n20-25\n\n\n\nTLS_DHE_RSA_WITH_AES_256_GCM_SHA384\n20-25\n20-25\n\n\nTLS_DHE_RSA_WITH_DES_CBC_SHA\n1-8\n1-8\n\n\nTLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA\n1-8\n\n\n\nTLS_DH_DSS_WITH_3DES_EDE_CBC_SHA\n1-8\n\n\n\nTLS_DH_DSS_WITH_DES_CBC_SHA\n1-8\n\n\n\nTLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA\n1-8\n\n\n\nTLS_DH_RSA_WITH_3DES_EDE_CBC_SHA\n1-8\n\n\n\nTLS_DH_RSA_WITH_DES_CBC_SHA\n1-8\n\n\n\nTLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA\n1-8\n\n\n\nTLS_DH_anon_WITH_3DES_EDE_CBC_SHA\n1-8\n\n\n\nTLS_DH_anon_WITH_AES_128_CBC_SHA\n9-22\n\n\n\nTLS_DH_anon_WITH_AES_128_CBC_SHA256\n20-22\n\n\n\nTLS_DH_anon_WITH_AES_128_GCM_SHA256\n20-22\n\n\n\nTLS_DH_anon_WITH_AES_256_CBC_SHA\n9-22\n\n\n\nTLS_DH_anon_WITH_AES_256_CBC_SHA256\n20-22\n\n\n\nTLS_DH_anon_WITH_AES_256_GCM_SHA384\n20-22\n\n\n\nTLS_DH_anon_WITH_DES_CBC_SHA\n1-8\n\n\n\nTLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA\n20-22\n\n\n\nTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\n20+\n20+\n\n\nTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\n20+\n\n\n\nTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\n20+\n20+\n\n\nTLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\n20+\n20+\n\n\nTLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\n20+\n\n\n\nTLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\n20+\n20+\n\n\nTLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\n24+\n24+\n\n\nTLS_ECDHE_ECDSA_WITH_NULL_SHA\n20-22\n\n\n\nTLS_ECDHE_ECDSA_WITH_RC4_128_SHA\n20-25\n20-23\n\n\nTLS_ECDHE_PSK_WITH_AES_128_CBC_SHA\n21+\n21+\n\n\nTLS_ECDHE_PSK_WITH_AES_256_CBC_SHA\n21+\n21+\n\n\nTLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256\n24+\n24+\n\n\nTLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\n20-22\n\n\n\nTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\n20+\n20+\n\n\nTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\n20+\n\n\n\nTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n20+\n20+\n\n\nTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n20+\n20+\n\n\nTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384\n20+\n\n\n\nTLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\n20+\n20+\n\n\nTLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\n24+\n24+\n\n\nTLS_ECDHE_RSA_WITH_NULL_SHA\n20-22\n\n\n\nTLS_ECDHE_RSA_WITH_RC4_128_SHA\n20-25\n20-23\n\n\nTLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA\n20-22\n\n\n\nTLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA\n20-22\n\n\n\nTLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256\n20-22\n\n\n\nTLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256\n20-22\n\n\n\nTLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA\n20-22\n\n\n\nTLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384\n20-22\n\n\n\nTLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384\n20-22\n\n\n\nTLS_ECDH_ECDSA_WITH_NULL_SHA\n20-22\n\n\n\nTLS_ECDH_ECDSA_WITH_RC4_128_SHA\n20-22\n\n\n\nTLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA\n20-22\n\n\n\nTLS_ECDH_RSA_WITH_AES_128_CBC_SHA\n20-22\n\n\n\nTLS_ECDH_RSA_WITH_AES_128_CBC_SHA256\n20-22\n\n\n\nTLS_ECDH_RSA_WITH_AES_128_GCM_SHA256\n20-22\n\n\n\nTLS_ECDH_RSA_WITH_AES_256_CBC_SHA\n20-22\n\n\n\nTLS_ECDH_RSA_WITH_AES_256_CBC_SHA384\n20-22\n\n\n\nTLS_ECDH_RSA_WITH_AES_256_GCM_SHA384\n20-22\n\n\n\nTLS_ECDH_RSA_WITH_NULL_SHA\n20-22\n\n\n\nTLS_ECDH_RSA_WITH_RC4_128_SHA\n20-22\n\n\n\nTLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA\n20-22\n\n\n\nTLS_ECDH_anon_WITH_AES_128_CBC_SHA\n20-22\n\n\n\nTLS_ECDH_anon_WITH_AES_256_CBC_SHA\n20-22\n\n\n\nTLS_ECDH_anon_WITH_NULL_SHA\n20-22\n\n\n\nTLS_ECDH_anon_WITH_RC4_128_SHA\n20-22\n\n\n\nTLS_EMPTY_RENEGOTIATION_INFO_SCSV\n20+\n20+\n\n\nTLS_FALLBACK_SCSV\n21+\n\n\n\nTLS_NULL_WITH_NULL_NULL\n1-8\n\n\n\nTLS_PSK_WITH_3DES_EDE_CBC_SHA\n21-22\n\n\n\nTLS_PSK_WITH_AES_128_CBC_SHA\n21+\n21+\n\n\nTLS_PSK_WITH_AES_256_CBC_SHA\n21+\n21+\n\n\nTLS_PSK_WITH_RC4_128_SHA\n21-25\n\n\n\nTLS_RSA_EXPORT_WITH_DES40_CBC_SHA\n1-8\n1-8\n\n\nTLS_RSA_WITH_3DES_EDE_CBC_SHA\n1-8\n1-8\n\n\nTLS_RSA_WITH_AES_128_CBC_SHA\n9+\n9+\n\n\nTLS_RSA_WITH_AES_128_CBC_SHA256\n20+\n\n\n\nTLS_RSA_WITH_AES_128_GCM_SHA256\n20+\n20+\n\n\nTLS_RSA_WITH_AES_256_CBC_SHA\n9+\n20+\n\n\nTLS_RSA_WITH_AES_256_CBC_SHA256\n20+\n\n\n\nTLS_RSA_WITH_AES_256_GCM_SHA384\n20+\n20+\n\n\nTLS_RSA_WITH_DES_CBC_SHA\n1-8\n1-8\n\n\nTLS_RSA_WITH_NULL_MD5\n1-8\n\n\n\nTLS_RSA_WITH_NULL_SHA\n1-8\n\n\n\nTLS_RSA_WITH_NULL_SHA256\n20-22\n\n\n\n\nNOTE: PSK cipher suites are enabled by default only if the SSLContext through\n which the engine was created has been initialized with a PSKKeyManager.\n\nSee also:\nSSLContextSSLSocketSSLServerSocketSSLSessionSocket\n\n\n"
    },
    {
        "API": "javax.net.ssl.SSLEngine",
        "Code": "\n              synchronized (outboundLock) {\n                  sslEngine.wrap(src, dst);\n                  outboundQueue.put(dst);\n              }\n      ",
        "Description": " wrap()"
    },
    {
        "API": "java.beans.PropertyChangeSupport.getPropertyChangeListeners()",
        "Code": "PropertyChangeListener[] listeners = bean.getPropertyChangeListeners();\n for (int i = 0; i < listeners.length; i++) {\n   if (listeners[i] instanceof PropertyChangeListenerProxy) {\n     PropertyChangeListenerProxy proxy =\n                    (PropertyChangeListenerProxy)listeners[i];\n     if (proxy.getPropertyName().equals(\"foo\")) {\n       // proxy is a PropertyChangeListener which was associated\n       // with the property named \"foo\"\n     }\n   }\n }\n ",
        "Description": "PropertyChangeListenerProxy "
    },
    {
        "API": "java.io.DataInput.readChar()",
        "Code": "(char)((a << 8) | (b & 0xff))\n ",
        "Description": "b writeChar"
    },
    {
        "API": "java.io.DataInput.readInt()",
        "Code": "(((a & 0xff) << 24) | ((b & 0xff) << 16) |\n  ((c & 0xff) <<  8) | (d & 0xff))\n ",
        "Description": "a-d writeInt"
    },
    {
        "API": "java.io.DataInput.readLong()",
        "Code": "(((long)(a & 0xff) << 56) |\n  ((long)(b & 0xff) << 48) |\n  ((long)(c & 0xff) << 40) |\n  ((long)(d & 0xff) << 32) |\n  ((long)(e & 0xff) << 24) |\n  ((long)(f & 0xff) << 16) |\n  ((long)(g & 0xff) <<  8) |\n  ((long)(h & 0xff)))\n ",
        "Description": "a-h \n This method is suitable\n for reading bytes written by the writeLong\n method of interface DataOutput."
    },
    {
        "API": "java.io.DataInput.readShort()",
        "Code": "(short)((a << 8) | (b & 0xff))\n ",
        "Description": "b writeShort"
    },
    {
        "API": "java.io.DataInput.readUTF()",
        "Code": "(char)(((a & 0x1F) << 6) | (b & 0x3F))\n ",
        "Description": "UTFDataFormatException 1110xxxx"
    },
    {
        "API": "java.io.DataInput.readUTF()",
        "Code": "(char)(((a & 0x0F) << 12) | ((b & 0x3F) << 6) | (c & 0x3F))\n ",
        "Description": "UTFDataFormatException 1111xxxx"
    },
    {
        "API": "java.io.DataInput.readUnsignedShort()",
        "Code": "(((a & 0xff) << 8) | (b & 0xff))\n ",
        "Description": "b writeShort"
    },
    {
        "API": "java.io.DataOutput.writeChar(int)",
        "Code": "(byte)(0xff & (v >> 8))\n (byte)(0xff & v)\n ",
        "Description": "char \n The bytes written by this method may be\n read by the readChar method\n of interface DataInput , which\n will then return a char equal\n to (char)v."
    },
    {
        "API": "java.io.DataOutput.writeInt(int)",
        "Code": "(byte)(0xff & (v >> 24))\n (byte)(0xff & (v >> 16))\n (byte)(0xff & (v >>  8))\n (byte)(0xff & v)\n ",
        "Description": "int \n The bytes written by this method may be read\n by the readInt method of interface\n DataInput , which will then\n return an int equal to v."
    },
    {
        "API": "java.io.DataOutput.writeLong(long)",
        "Code": "(byte)(0xff & (v >> 56))\n (byte)(0xff & (v >> 48))\n (byte)(0xff & (v >> 40))\n (byte)(0xff & (v >> 32))\n (byte)(0xff & (v >> 24))\n (byte)(0xff & (v >> 16))\n (byte)(0xff & (v >>  8))\n (byte)(0xff & v)\n ",
        "Description": "long \n The bytes written by this method may be\n read by the readLong method\n of interface DataInput , which\n will then return a long equal\n to v."
    },
    {
        "API": "java.io.DataOutput.writeShort(int)",
        "Code": "(byte)(0xff & (v >> 8))\n (byte)(0xff & v)\n ",
        "Description": " \n The bytes written by this method may be\n read by the readShort method\n of interface DataInput , which\n will then return a short equal\n to (short)v."
    },
    {
        "API": "java.io.DataOutput.writeUTF(java.lang.String)",
        "Code": "(byte)c ",
        "Description": "\\u007f \n If a character c is \\u0000\n or is in the range \\u0080\n through \\u07ff, then it is\n represented by two bytes, to be written\n in the order shown: (byte)(0xc0 | (0x1f & (c >> 6)))\n (byte)(0x80 | (0x3f & c))\n   If a character\n c is in the range \\u0800\n through uffff, then it is\n represented by three bytes, to be written\n in the order shown: (byte)(0xe0 | (0x0f & (c >> 12)))\n (byte)(0x80 | (0x3f & (c >>  6)))\n (byte)(0x80 | (0x3f & c))\n   First,\n the total number of bytes needed to represent\n all the characters of s is\n calculated. If this number is larger than\n 65535, then a UTFDataFormatException\n is thrown. Otherwise, this length is written\n to the output stream in exactly the manner\n of the writeShort method;\n after this, the one-, two-, or three-byte\n representation of each character in the\n string s is written.  The\n bytes written by this method may be read\n by the readUTF method of interface\n DataInput , which will then\n return a String equal to s.\n\nParameters\n\ns\n\nString: the string value to be written."
    },
    {
        "API": "java.io.DataOutput.writeUTF(java.lang.String)",
        "Code": "(byte)(0xc0 | (0x1f & (c >> 6)))\n (byte)(0x80 | (0x3f & c))\n ",
        "Description": "\\u07ff  If a character\n c is in the range \\u0800\n through uffff, then it is\n represented by three bytes, to be written\n in the order shown: (byte)(0xe0 | (0x0f & (c >> 12)))\n (byte)(0x80 | (0x3f & (c >>  6)))\n (byte)(0x80 | (0x3f & c))\n   First,\n the total number of bytes needed to represent\n all the characters of s is\n calculated. If this number is larger than\n 65535, then a UTFDataFormatException\n is thrown. Otherwise, this length is written\n to the output stream in exactly the manner\n of the writeShort method;\n after this, the one-, two-, or three-byte\n representation of each character in the\n string s is written.  The\n bytes written by this method may be read\n by the readUTF method of interface\n DataInput , which will then\n return a String equal to s.\n\nParameters\n\ns\n\nString: the string value to be written."
    },
    {
        "API": "java.io.DataOutput.writeUTF(java.lang.String)",
        "Code": "(byte)(0xe0 | (0x0f & (c >> 12)))\n (byte)(0x80 | (0x3f & (c >>  6)))\n (byte)(0x80 | (0x3f & c))\n ",
        "Description": "uffff  First,\n the total number of bytes needed to represent\n all the characters of s is\n calculated. If this number is larger than\n 65535, then a UTFDataFormatException\n is thrown. Otherwise, this length is written\n to the output stream in exactly the manner\n of the writeShort method;\n after this, the one-, two-, or three-byte\n representation of each character in the\n string s is written.  The\n bytes written by this method may be read\n by the readUTF method of interface\n DataInput , which will then\n return a String equal to s."
    },
    {
        "API": "java.io.InputStream.read(byte[])",
        "Code": " read(b, 0, b.length) ",
        "Description": "InputStream "
    },
    {
        "API": "java.io.PipedInputStream.connect(java.io.PipedOutputStream)",
        "Code": "snk.connect(src) ",
        "Description": "snk \n or the call:\n\n src.connect(snk) \n\n The two calls have the same effect."
    },
    {
        "API": "java.io.PipedInputStream.connect(java.io.PipedOutputStream)",
        "Code": "src.connect(snk) ",
        "Description": " \n The two calls have the same effect."
    },
    {
        "API": "java.io.PipedReader.connect(java.io.PipedWriter)",
        "Code": "snk.connect(src) ",
        "Description": "snk \n or the call:\n\n src.connect(snk) \n\n The two calls have the same effect."
    },
    {
        "API": "java.io.PipedReader.connect(java.io.PipedWriter)",
        "Code": "src.connect(snk) ",
        "Description": " \n The two calls have the same effect."
    },
    {
        "API": "java.lang.Character.isSurrogatePair(char,char)",
        "Code": "isHighSurrogate(high) && isLowSurrogate(low)\n ",
        "Description": " "
    },
    {
        "API": "java.lang.Double.longBitsToDouble(long)",
        "Code": "int s = ((bits >> 63) == 0) ? 1 : -1;\n int e = (int)((bits >> 52) & 0x7ffL);\n long m = (e == 0) ?\n                 (bits & 0xfffffffffffffL) << 1 :\n                 (bits & 0xfffffffffffffL) | 0x10000000000000L;\n ",
        "Description": " "
    },
    {
        "API": "java.lang.Double.valueOf(java.lang.String)",
        "Code": "final String Digits     = \"(\\\\p{Digit}+)\";\n  final String HexDigits  = \"(\\\\p{XDigit}+)\";\n  // an exponent is 'e' or 'E' followed by an optionally\n  // signed decimal integer.\n  final String Exp        = \"[eE][+-]?\"+Digits;\n  final String fpRegex    =\n      (\"[\\\\x00-\\\\x20]*\"+  // Optional leading \"whitespace\"\n       \"[+-]?(\" + // Optional sign character\n       \"NaN|\" +           // \"NaN\" string\n       \"Infinity|\" +      // \"Infinity\" string\n\n       // A decimal floating-point string representing a finite positive\n       // number without a leading sign has at most five basic pieces:\n       // Digits . Digits ExponentPart FloatTypeSuffix\n       //\n       // Since this method allows integer-only strings as input\n       // in addition to strings of floating-point literals, the\n       // two sub-patterns below are simplifications of the grammar\n       // productions from section 3.10.2 of\n       // The Java Language Specification.\n\n       // Digits ._opt Digits_opt ExponentPart_opt FloatTypeSuffix_opt\n       \"(((\"+Digits+\"(\\\\.)?(\"+Digits+\"?)(\"+Exp+\")?)|\"+\n\n       // . Digits ExponentPart_opt FloatTypeSuffix_opt\n       \"(\\\\.(\"+Digits+\")(\"+Exp+\")?)|\"+\n\n       // Hexadecimal strings\n       \"((\" +\n        // 0[xX] HexDigits ._opt BinaryExponent FloatTypeSuffix_opt\n        \"(0[xX]\" + HexDigits + \"(\\\\.)?)|\" +\n\n        // 0[xX] HexDigits_opt . HexDigits BinaryExponent FloatTypeSuffix_opt\n        \"(0[xX]\" + HexDigits + \"?(\\\\.)\" + HexDigits + \")\" +\n\n        \")[pP][+-]?\" + Digits + \"))\" +\n       \"[fFdD]?))\" +\n       \"[\\\\x00-\\\\x20]*\");// Optional trailing \"whitespace\"\n\n  if (Pattern.matches(fpRegex, myString))\n      Double.valueOf(myString); // Will not throw NumberFormatException\n  else {\n      // Perform suitable alternative action\n  }\n ",
        "Description": "NumberFormatException "
    },
    {
        "API": "java.lang.Float.intBitsToFloat(int)",
        "Code": "int s = ((bits >> 31) == 0) ? 1 : -1;\n int e = ((bits >> 23) & 0xff);\n int m = (e == 0) ?\n                 (bits & 0x7fffff) << 1 :\n                 (bits & 0x7fffff) | 0x800000;\n ",
        "Description": " "
    },
    {
        "API": "java.lang.StackTraceElement.equals(java.lang.Object)",
        "Code": "equals(a.getFileName(), b.getFileName()) &&\n     a.getLineNumber() == b.getLineNumber()) &&\n     equals(a.getClassName(), b.getClassName()) &&\n     equals(a.getMethodName(), b.getMethodName())\n ",
        "Description": "b equals"
    },
    {
        "API": "java.lang.String.join(java.lang.CharSequence,java.lang.CharSequence)",
        "Code": "String message = String.join(\"-\", \"Java\", \"is\", \"cool\");\n     // message returned is: \"Java-is-cool\"\n ",
        "Description": " "
    },
    {
        "API": "java.lang.String.join(java.lang.CharSequence,java.lang.Iterable<? extends java.lang.CharSequence>)",
        "Code": "List<String> strings = new LinkedList<>();\n     strings.add(\"Java\");strings.add(\"is\");\n     strings.add(\"cool\");\n     String message = String.join(\" \", strings);\n     //message returned is: \"Java is cool\"\n\n     Set<String> strings = new LinkedHashSet<>();\n     strings.add(\"Java\"); strings.add(\"is\");\n     strings.add(\"very\"); strings.add(\"cool\");\n     String message = String.join(\"-\", strings);\n     //message returned is: \"Java-is-very-cool\"\n ",
        "Description": " "
    },
    {
        "API": "java.lang.StringBuffer.getChars(int,int,char[],int)",
        "Code": "dstbegin + (srcEnd-srcBegin) - 1\n ",
        "Description": "dstBegin "
    },
    {
        "API": "java.lang.StringBuffer.indexOf(java.lang.String)",
        "Code": "this.toString().startsWith(str, <i>k</i>)\n ",
        "Description": "k true"
    },
    {
        "API": "java.lang.StringBuffer.indexOf(java.lang.String,int)",
        "Code": "k >= Math.min(fromIndex, this.length()) &&\n                   this.toString().startsWith(str, k)\n ",
        "Description": "k k"
    },
    {
        "API": "java.lang.StringBuffer.lastIndexOf(java.lang.String,int)",
        "Code": "k <= Math.min(fromIndex, this.length()) &&\n                   this.toString().startsWith(str, k)\n ",
        "Description": "k k"
    },
    {
        "API": "java.lang.StringBuffer.lastIndexOf(java.lang.String)",
        "Code": "this.toString().startsWith(str, k)\n ",
        "Description": "k "
    },
    {
        "API": "java.lang.StringBuffer.subSequence(int,int)",
        "Code": "sb.subSequence(begin,&nbsp;end)",
        "Description": " sb.substring(begin,&nbsp;end)"
    },
    {
        "API": "java.lang.StringBuffer.subSequence(int,int)",
        "Code": "sb.substring(begin,&nbsp;end)",
        "Description": "sb.subSequence(begin,&nbsp;end) CharSequence"
    },
    {
        "API": "java.lang.StringBuilder.getChars(int,int,char[],int)",
        "Code": "dstbegin + (srcEnd-srcBegin) - 1\n ",
        "Description": "dstBegin "
    },
    {
        "API": "java.lang.StringBuilder.indexOf(java.lang.String)",
        "Code": "this.toString().startsWith(str, <i>k</i>)\n ",
        "Description": "k true"
    },
    {
        "API": "java.lang.StringBuilder.indexOf(java.lang.String,int)",
        "Code": "k >= Math.min(fromIndex, this.length()) &&\n                   this.toString().startsWith(str, k)\n ",
        "Description": "k k"
    },
    {
        "API": "java.lang.StringBuilder.lastIndexOf(java.lang.String,int)",
        "Code": "k <= Math.min(fromIndex, this.length()) &&\n                   this.toString().startsWith(str, k)\n ",
        "Description": "k k"
    },
    {
        "API": "java.lang.StringBuilder.lastIndexOf(java.lang.String)",
        "Code": "this.toString().startsWith(str, k)\n ",
        "Description": "k "
    },
    {
        "API": "java.lang.StringBuilder.subSequence(int,int)",
        "Code": "sb.subSequence(begin,&nbsp;end)",
        "Description": " sb.substring(begin,&nbsp;end)"
    },
    {
        "API": "java.lang.StringBuilder.subSequence(int,int)",
        "Code": "sb.substring(begin,&nbsp;end)",
        "Description": "sb.subSequence(begin,&nbsp;end) CharSequence"
    },
    {
        "API": "java.lang.invoke.CallSite.dynamicInvoker()",
        "Code": "MethodHandle getTarget, invoker, result;\n getTarget = MethodHandles.publicLookup().bind(this, \"getTarget\", MethodType.methodType(MethodHandle.class));\n invoker = MethodHandles.exactInvoker(this.type());\n result = MethodHandles.foldArguments(invoker, getTarget)\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandle.asCollector(java.lang.Class<?>,int)",
        "Code": "MethodHandle deepToString = publicLookup()\n  .findStatic(Arrays.class, \"deepToString\", methodType(String.class, Object[].class));\nassertEquals(\"[won]\",   (String) deepToString.invokeExact(new Object[]{\"won\"}));\nMethodHandle ts1 = deepToString.asCollector(Object[].class, 1);\nassertEquals(methodType(String.class, Object.class), ts1.type());\n//assertEquals(\"[won]\", (String) ts1.invokeExact(         new Object[]{\"won\"})); //FAIL\nassertEquals(\"[[won]]\", (String) ts1.invokeExact((Object) new Object[]{\"won\"}));\n// arrayType can be a subtype of Object[]\nMethodHandle ts2 = deepToString.asCollector(String[].class, 2);\nassertEquals(methodType(String.class, String.class, String.class), ts2.type());\nassertEquals(\"[two, too]\", (String) ts2.invokeExact(\"two\", \"too\"));\nMethodHandle ts0 = deepToString.asCollector(Object[].class, 0);\nassertEquals(\"[]\", (String) ts0.invokeExact());\n// collectors can be nested, Lisp-style\nMethodHandle ts22 = deepToString.asCollector(Object[].class, 3).asCollector(String[].class, 2);\nassertEquals(\"[A, B, [C, D]]\", ((String) ts22.invokeExact((Object)'A', (Object)\"B\", \"C\", \"D\")));\n// arrayType can be any primitive array type\nMethodHandle bytesToString = publicLookup()\n  .findStatic(Arrays.class, \"toString\", methodType(String.class, byte[].class))\n  .asCollector(byte[].class, 3);\nassertEquals(\"[1, 2, 3]\", (String) bytesToString.invokeExact((byte)1, (byte)2, (byte)3));\nMethodHandle longsToString = publicLookup()\n  .findStatic(Arrays.class, \"toString\", methodType(String.class, long[].class))\n  .asCollector(long[].class, 1);\nassertEquals(\"[123]\", (String) longsToString.invokeExact((long)123));\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandle.asFixedArity()",
        "Code": "MethodHandle asListVar = publicLookup()\n  .findStatic(Arrays.class, \"asList\", methodType(List.class, Object[].class))\n  .asVarargsCollector(Object[].class);\nMethodHandle asListFix = asListVar.asFixedArity();\nassertEquals(\"[1]\", asListVar.invoke(1).toString());\nException caught = null;\ntry { asListFix.invoke((Object)1); }\ncatch (Exception ex) { caught = ex; }\nassert(caught instanceof ClassCastException);\nassertEquals(\"[two, too]\", asListVar.invoke(\"two\", \"too\").toString());\ntry { asListFix.invoke(\"two\", \"too\"); }\ncatch (Exception ex) { caught = ex; }\nassert(caught instanceof WrongMethodTypeException);\nObject[] argv = { \"three\", \"thee\", \"tee\" };\nassertEquals(\"[three, thee, tee]\", asListVar.invoke(argv).toString());\nassertEquals(\"[three, thee, tee]\", asListFix.invoke(argv).toString());\nassertEquals(1, ((List) asListVar.invoke((Object)argv)).size());\nassertEquals(\"[three, thee, tee]\", asListFix.invoke((Object)argv).toString());\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandle.asSpreader(java.lang.Class<?>,int)",
        "Code": "MethodHandle equals = publicLookup()\n  .findVirtual(String.class, \"equals\", methodType(boolean.class, Object.class));\nassert( (boolean) equals.invokeExact(\"me\", (Object)\"me\"));\nassert(!(boolean) equals.invokeExact(\"me\", (Object)\"thee\"));\n// spread both arguments from a 2-array:\nMethodHandle eq2 = equals.asSpreader(Object[].class, 2);\nassert( (boolean) eq2.invokeExact(new Object[]{ \"me\", \"me\" }));\nassert(!(boolean) eq2.invokeExact(new Object[]{ \"me\", \"thee\" }));\n// try to spread from anything but a 2-array:\nfor (int n = 0; n <= 10; n++) {\n  Object[] badArityArgs = (n == 2 ? null : new Object[n]);\n  try { assert((boolean) eq2.invokeExact(badArityArgs) && false); }\n  catch (IllegalArgumentException ex) { } // OK\n}\n// spread both arguments from a String array:\nMethodHandle eq2s = equals.asSpreader(String[].class, 2);\nassert( (boolean) eq2s.invokeExact(new String[]{ \"me\", \"me\" }));\nassert(!(boolean) eq2s.invokeExact(new String[]{ \"me\", \"thee\" }));\n// spread second arguments from a 1-array:\nMethodHandle eq1 = equals.asSpreader(Object[].class, 1);\nassert( (boolean) eq1.invokeExact(\"me\", new Object[]{ \"me\" }));\nassert(!(boolean) eq1.invokeExact(\"me\", new Object[]{ \"thee\" }));\n// spread no arguments from a 0-array or null:\nMethodHandle eq0 = equals.asSpreader(Object[].class, 0);\nassert( (boolean) eq0.invokeExact(\"me\", (Object)\"me\", new Object[0]));\nassert(!(boolean) eq0.invokeExact(\"me\", (Object)\"thee\", (Object[])null));\n// asSpreader and asCollector are approximate inverses:\nfor (int n = 0; n <= 2; n++) {\n    for (Class<?> a : new Class<?>[]{Object[].class, String[].class, CharSequence[].class}) {\n        MethodHandle equals2 = equals.asSpreader(a, n).asCollector(a, n);\n        assert( (boolean) equals2.invokeWithArguments(\"me\", \"me\"));\n        assert(!(boolean) equals2.invokeWithArguments(\"me\", \"thee\"));\n    }\n}\nMethodHandle caToString = publicLookup()\n  .findStatic(Arrays.class, \"toString\", methodType(String.class, char[].class));\nassertEquals(\"[A, B, C]\", (String) caToString.invokeExact(\"ABC\".toCharArray()));\nMethodHandle caString3 = caToString.asCollector(char[].class, 3);\nassertEquals(\"[A, B, C]\", (String) caString3.invokeExact('A', 'B', 'C'));\nMethodHandle caToString2 = caString3.asSpreader(char[].class, 2);\nassertEquals(\"[A, B, C]\", (String) caToString2.invokeExact('A', \"BC\".toCharArray()));\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandle.asVarargsCollector(java.lang.Class<?>)",
        "Code": "MethodHandle deepToString = publicLookup()\n  .findStatic(Arrays.class, \"deepToString\", methodType(String.class, Object[].class));\nMethodHandle ts1 = deepToString.asVarargsCollector(Object[].class);\nassertEquals(\"[won]\",   (String) ts1.invokeExact(    new Object[]{\"won\"}));\nassertEquals(\"[won]\",   (String) ts1.invoke(         new Object[]{\"won\"}));\nassertEquals(\"[won]\",   (String) ts1.invoke(                      \"won\" ));\nassertEquals(\"[[won]]\", (String) ts1.invoke((Object) new Object[]{\"won\"}));\n// findStatic of Arrays.asList(...) produces a variable arity method handle:\nMethodHandle asList = publicLookup()\n  .findStatic(Arrays.class, \"asList\", methodType(List.class, Object[].class));\nassertEquals(methodType(List.class, Object[].class), asList.type());\nassert(asList.isVarargsCollector());\nassertEquals(\"[]\", asList.invoke().toString());\nassertEquals(\"[1]\", asList.invoke(1).toString());\nassertEquals(\"[two, too]\", asList.invoke(\"two\", \"too\").toString());\nString[] argv = { \"three\", \"thee\", \"tee\" };\nassertEquals(\"[three, thee, tee]\", asList.invoke(argv).toString());\nassertEquals(\"[three, thee, tee]\", asList.invoke((Object[])argv).toString());\nList ls = (List) asList.invoke((Object)argv);\nassertEquals(1, ls.size());\nassertEquals(\"[three, thee, tee]\", Arrays.toString((Object[])ls.get(0)));\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandle.invokeWithArguments(java.util.List<?>)",
        "Code": "invokeWithArguments(arguments.toArray()\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandle.invokeWithArguments(java.lang.Object)",
        "Code": "MethodHandle invoker = MethodHandles.spreadInvoker(this.type(), 0);\n Object result = invoker.invokeExact(this, arguments);\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandle.toString()",
        "Code": "\"MethodHandle\" + type().toString()\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.catchException(java.lang.invoke.MethodHandle,java.lang.Class<? extends java.lang.Throwable>,java.lang.invoke.MethodHandle)",
        "Code": "T target(A..., B...);\n T handler(ExType, A...);\n T adapter(A... a, B... b) {\n   try {\n     return target(a..., b...);\n   } catch (ExType ex) {\n     return handler(ex, a...);\n   }\n }\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.collectArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle)",
        "Code": "import static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle deepToString = publicLookup()\n  .findStatic(Arrays.class, \"deepToString\", methodType(String.class, Object[].class));\n\nMethodHandle ts1 = deepToString.asCollector(String[].class, 1);\nassertEquals(\"[strange]\", (String) ts1.invokeExact(\"strange\"));\n\nMethodHandle ts2 = deepToString.asCollector(String[].class, 2);\nassertEquals(\"[up, down]\", (String) ts2.invokeExact(\"up\", \"down\"));\n\nMethodHandle ts3 = deepToString.asCollector(String[].class, 3);\nMethodHandle ts3_ts2 = collectArguments(ts3, 1, ts2);\nassertEquals(\"[top, [up, down], strange]\",\n             (String) ts3_ts2.invokeExact(\"top\", \"up\", \"down\", \"strange\"));\n\nMethodHandle ts3_ts2_ts1 = collectArguments(ts3_ts2, 3, ts1);\nassertEquals(\"[top, [up, down], [strange]]\",\n             (String) ts3_ts2_ts1.invokeExact(\"top\", \"up\", \"down\", \"strange\"));\n\nMethodHandle ts3_ts2_ts3 = collectArguments(ts3_ts2, 1, ts3);\nassertEquals(\"[top, [[up, down, strange], charm], bottom]\",\n             (String) ts3_ts2_ts3.invokeExact(\"top\", \"up\", \"down\", \"strange\", \"charm\", \"bottom\"));\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.collectArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle)",
        "Code": "T target(A...,V,C...);\n V filter(B...);\n T adapter(A... a,B... b,C... c) {\n   V v = filter(b...);\n   return target(a...,v,c...);\n }\n // and if the filter has no arguments:\n T target2(A...,V,C...);\n V filter2();\n T adapter2(A... a,C... c) {\n   V v = filter2();\n   return target2(a...,v,c...);\n }\n // and if the filter has a void return:\n T target3(A...,C...);\n void filter3(B...);\n void adapter3(A... a,B... b,C... c) {\n   filter3(b...);\n   return target3(a...,c...);\n }\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.collectArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle)",
        "Code": "mh = MethodHandles.dropArguments(mh, 1, coll.type().parameterList()); //step 2\n mh = MethodHandles.foldArguments(mh, coll); //step 1\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.dropArguments(java.lang.invoke.MethodHandle,int,java.lang.Class<?>)",
        "Code": "import static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat = lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nassertEquals(\"xy\", (String) cat.invokeExact(\"x\", \"y\"));\nMethodHandle d0 = dropArguments(cat, 0, String.class);\nassertEquals(\"yz\", (String) d0.invokeExact(\"x\", \"y\", \"z\"));\nMethodHandle d1 = dropArguments(cat, 1, String.class);\nassertEquals(\"xz\", (String) d1.invokeExact(\"x\", \"y\", \"z\"));\nMethodHandle d2 = dropArguments(cat, 2, String.class);\nassertEquals(\"xy\", (String) d2.invokeExact(\"x\", \"y\", \"z\"));\nMethodHandle d12 = dropArguments(cat, 1, int.class, boolean.class);\nassertEquals(\"xz\", (String) d12.invokeExact(\"x\", 12, true, \"z\"));\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.dropArguments(java.lang.invoke.MethodHandle,int,java.lang.Class<?>)",
        "Code": "\n dropArguments(target, pos, Arrays.asList(valueTypes))\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.dropArguments(java.lang.invoke.MethodHandle,int,java.util.List<java.lang.Class<?>>)",
        "Code": "import static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat = lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nassertEquals(\"xy\", (String) cat.invokeExact(\"x\", \"y\"));\nMethodType bigType = cat.type().insertParameterTypes(0, int.class, String.class);\nMethodHandle d0 = dropArguments(cat, 0, bigType.parameterList().subList(0,2));\nassertEquals(bigType, d0.type());\nassertEquals(\"yz\", (String) d0.invokeExact(123, \"x\", \"y\", \"z\"));\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.dropArguments(java.lang.invoke.MethodHandle,int,java.util.List<java.lang.Class<?>>)",
        "Code": "\n dropArguments(target, pos, valueTypes.toArray(new Class[0]))\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.filterArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle)",
        "Code": "import static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat = lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nMethodHandle upcase = lookup().findVirtual(String.class,\n  \"toUpperCase\", methodType(String.class));\nassertEquals(\"xy\", (String) cat.invokeExact(\"x\", \"y\"));\nMethodHandle f0 = filterArguments(cat, 0, upcase);\nassertEquals(\"Xy\", (String) f0.invokeExact(\"x\", \"y\")); // Xy\nMethodHandle f1 = filterArguments(cat, 1, upcase);\nassertEquals(\"xY\", (String) f1.invokeExact(\"x\", \"y\")); // xY\nMethodHandle f2 = filterArguments(cat, 0, upcase, upcase);\nassertEquals(\"XY\", (String) f2.invokeExact(\"x\", \"y\")); // XY\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.filterArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle)",
        "Code": "V target(P... p, A[i]... a[i], B... b);\n A[i] filter[i](V[i]);\n T adapter(P... p, V[i]... v[i], B... b) {\n   return target(p..., f[i](v[i])..., b...);\n }\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.filterReturnValue(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)",
        "Code": "import static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle cat = lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nMethodHandle length = lookup().findVirtual(String.class,\n  \"length\", methodType(int.class));\nSystem.out.println((String) cat.invokeExact(\"x\", \"y\")); // xy\nMethodHandle f0 = filterReturnValue(cat, length);\nSystem.out.println((int) f0.invokeExact(\"x\", \"y\")); // 2\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.filterReturnValue(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)",
        "Code": "V target(A...);\n T filter(V);\n T adapter(A... a) {\n   V v = target(a...);\n   return filter(v);\n }\n // and if the target has a void return:\n void target2(A...);\n T filter2();\n T adapter2(A... a) {\n   target2(a...);\n   return filter2();\n }\n // and if the filter has a void return:\n V target3(A...);\n void filter3(V);\n void adapter3(A... a) {\n   V v = target3(a...);\n   filter3(v);\n }\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.foldArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)",
        "Code": "import static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,\n  \"println\", methodType(void.class, String.class))\n    .bindTo(System.out);\nMethodHandle cat = lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nassertEquals(\"boojum\", (String) cat.invokeExact(\"boo\", \"jum\"));\nMethodHandle catTrace = foldArguments(cat, trace);\n// also prints \"boo\":\nassertEquals(\"boojum\", (String) catTrace.invokeExact(\"boo\", \"jum\"));\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.foldArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)",
        "Code": "// there are N arguments in A...\n T target(V, A[N]..., B...);\n V combiner(A...);\n T adapter(A... a, B... b) {\n   V v = combiner(a...);\n   return target(v, a..., b...);\n }\n // and if the combiner has a void return:\n T target2(A[N]..., B...);\n void combiner2(A...);\n T adapter2(A... a, B... b) {\n   combiner2(a...);\n   return target2(a..., b...);\n }\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.guardWithTest(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)",
        "Code": "boolean test(A...);\n T target(A...,B...);\n T fallback(A...,B...);\n T adapter(A... a,B... b) {\n   if (test(a...))\n     return target(a..., b...);\n   else\n     return fallback(a..., b...);\n }\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.permuteArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodType,int...)",
        "Code": "import static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodType intfn1 = methodType(int.class, int.class);\nMethodType intfn2 = methodType(int.class, int.class, int.class);\nMethodHandle sub = ... (int x, int y) -> (x-y) ...;\nassert(sub.type().equals(intfn2));\nMethodHandle sub1 = permuteArguments(sub, intfn2, 0, 1);\nMethodHandle rsub = permuteArguments(sub, intfn2, 1, 0);\nassert((int)rsub.invokeExact(1, 100) == 99);\nMethodHandle add = ... (int x, int y) -> (x+y) ...;\nassert(add.type().equals(intfn2));\nMethodHandle twice = permuteArguments(add, intfn1, 0, 0);\nassert(twice.type().equals(intfn1));\nassert((int)twice.invokeExact(21) == 42);\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.spreadInvoker(java.lang.invoke.MethodType,int)",
        "Code": "MethodHandle invoker = MethodHandles.invoker(type);\nint spreadArgCount = type.parameterCount() - leadingArgCount;\ninvoker = invoker.asSpreader(Object[].class, spreadArgCount);\nreturn invoker;\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.Lookup.bind(java.lang.Object,java.lang.String,java.lang.invoke.MethodType)",
        "Code": "import static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle mh0 = lookup().findVirtual(defc, name, type);\nMethodHandle mh1 = mh0.bindTo(receiver);\nMethodType mt1 = mh1.type();\nif (mh0.isVarargsCollector())\n  mh1 = mh1.asVarargsCollector(mt1.parameterType(mt1.parameterCount()-1));\nreturn mh1;\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.Lookup.findConstructor(java.lang.Class<?>,java.lang.invoke.MethodType)",
        "Code": "import static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle MH_newArrayList = publicLookup().findConstructor(\n  ArrayList.class, methodType(void.class, Collection.class));\nCollection orig = Arrays.asList(\"x\", \"y\");\nCollection copy = (ArrayList) MH_newArrayList.invokeExact(orig);\nassert(orig != copy);\nassertEquals(orig, copy);\n// a variable-arity constructor:\nMethodHandle MH_newProcessBuilder = publicLookup().findConstructor(\n  ProcessBuilder.class, methodType(void.class, String[].class));\nProcessBuilder pb = (ProcessBuilder)\n  MH_newProcessBuilder.invoke(\"x\", \"y\", \"z\");\nassertEquals(\"[x, y, z]\", pb.command().toString());\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.Lookup.findSpecial(java.lang.Class<?>,java.lang.String,java.lang.invoke.MethodType,java.lang.Class<?>)",
        "Code": "import static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nstatic class Listie extends ArrayList {\n  public String toString() { return \"[wee Listie]\"; }\n  static Lookup lookup() { return MethodHandles.lookup(); }\n}\n...\n// no access to constructor via invokeSpecial:\nMethodHandle MH_newListie = Listie.lookup()\n  .findConstructor(Listie.class, methodType(void.class));\nListie l = (Listie) MH_newListie.invokeExact();\ntry { assertEquals(\"impossible\", Listie.lookup().findSpecial(\n        Listie.class, \"<init>\", methodType(void.class), Listie.class));\n } catch (NoSuchMethodException ex) { } // OK\n// access to super and self methods via invokeSpecial:\nMethodHandle MH_super = Listie.lookup().findSpecial(\n  ArrayList.class, \"toString\" , methodType(String.class), Listie.class);\nMethodHandle MH_this = Listie.lookup().findSpecial(\n  Listie.class, \"toString\" , methodType(String.class), Listie.class);\nMethodHandle MH_duper = Listie.lookup().findSpecial(\n  Object.class, \"toString\" , methodType(String.class), Listie.class);\nassertEquals(\"[]\", (String) MH_super.invokeExact(l));\nassertEquals(\"\"+l, (String) MH_this.invokeExact(l));\nassertEquals(\"[]\", (String) MH_duper.invokeExact(l)); // ArrayList method\ntry { assertEquals(\"inaccessible\", Listie.lookup().findSpecial(\n        String.class, \"toString\", methodType(String.class), Listie.class));\n } catch (IllegalAccessException ex) { } // OK\nListie subl = new Listie() { public String toString() { return \"[subclass]\"; } };\nassertEquals(\"\"+l, (String) MH_this.invokeExact(subl)); // Listie method\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.Lookup.findStatic(java.lang.Class<?>,java.lang.String,java.lang.invoke.MethodType)",
        "Code": "import static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle MH_asList = publicLookup().findStatic(Arrays.class,\n  \"asList\", methodType(List.class, Object[].class));\nassertEquals(\"[x, y]\", MH_asList.invoke(\"x\", \"y\").toString());\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MethodHandles.Lookup.findVirtual(java.lang.Class<?>,java.lang.String,java.lang.invoke.MethodType)",
        "Code": "import static java.lang.invoke.MethodHandles.*;\nimport static java.lang.invoke.MethodType.*;\n...\nMethodHandle MH_concat = publicLookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nMethodHandle MH_hashCode = publicLookup().findVirtual(Object.class,\n  \"hashCode\", methodType(int.class));\nMethodHandle MH_hashCode_String = publicLookup().findVirtual(String.class,\n  \"hashCode\", methodType(int.class));\nassertEquals(\"xy\", (String) MH_concat.invokeExact(\"x\", \"y\"));\nassertEquals(\"xy\".hashCode(), (int) MH_hashCode.invokeExact((Object)\"xy\"));\nassertEquals(\"xy\".hashCode(), (int) MH_hashCode_String.invokeExact(\"xy\"));\n// interface method:\nMethodHandle MH_subSequence = publicLookup().findVirtual(CharSequence.class,\n  \"subSequence\", methodType(CharSequence.class, int.class, int.class));\nassertEquals(\"def\", MH_subSequence.invoke(\"abcdefghi\", 3, 6).toString());\n// constructor \"internal method\" must be accessed differently:\nMethodType MT_newString = methodType(void.class); //()V for new String()\ntry { assertEquals(\"impossible\", lookup()\n        .findVirtual(String.class, \"<init>\", MT_newString));\n } catch (NoSuchMethodException ex) { } // OK\nMethodHandle MH_newString = publicLookup()\n  .findConstructor(String.class, MT_newString);\nassertEquals(\"\", (String) MH_newString.invokeExact());\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.MutableCallSite.dynamicInvoker()",
        "Code": "MethodHandle getTarget, invoker, result;\n getTarget = MethodHandles.publicLookup().bind(this, \"getTarget\", MethodType.methodType(MethodHandle.class));\n invoker = MethodHandles.exactInvoker(this.type());\n result = MethodHandles.foldArguments(invoker, getTarget)\n ",
        "Description": " "
    },
    {
        "API": "java.lang.invoke.VolatileCallSite.dynamicInvoker()",
        "Code": "MethodHandle getTarget, invoker, result;\n getTarget = MethodHandles.publicLookup().bind(this, \"getTarget\", MethodType.methodType(MethodHandle.class));\n invoker = MethodHandles.exactInvoker(this.type());\n result = MethodHandles.foldArguments(invoker, getTarget)\n ",
        "Description": " "
    },
    {
        "API": "java.nio.channels.SelectionKey.isAcceptable()",
        "Code": "k.readyOps() & OP_ACCEPT != 0\n ",
        "Description": " "
    },
    {
        "API": "java.nio.channels.SelectionKey.isConnectable()",
        "Code": "k.readyOps() & OP_CONNECT != 0\n ",
        "Description": " "
    },
    {
        "API": "java.nio.channels.SelectionKey.isReadable()",
        "Code": "k.readyOps() & OP_READ != 0\n ",
        "Description": " "
    },
    {
        "API": "java.nio.channels.SelectionKey.isWritable()",
        "Code": "k.readyOps() & OP_WRITE != 0\n ",
        "Description": " "
    },
    {
        "API": "java.nio.file.Files.lines(java.nio.file.Path)",
        "Code": "Files.lines(path, StandardCharsets.UTF_8)\n ",
        "Description": " "
    },
    {
        "API": "java.nio.file.Files.newBufferedReader(java.nio.file.Path)",
        "Code": "Files.newBufferedReader(path, StandardCharsets.UTF_8)\n ",
        "Description": " "
    },
    {
        "API": "java.nio.file.Files.newBufferedWriter(java.nio.file.Path,java.nio.file.OpenOption)",
        "Code": "Files.newBufferedWriter(path, StandardCharsets.UTF_8, options)\n ",
        "Description": " "
    },
    {
        "API": "java.nio.file.Files.readAllLines(java.nio.file.Path)",
        "Code": "Files.readAllLines(path, StandardCharsets.UTF_8)\n ",
        "Description": " "
    },
    {
        "API": "java.nio.file.Files.write(java.nio.file.Path,java.lang.Iterable<? extends java.lang.CharSequence>,java.nio.file.OpenOption)",
        "Code": "Files.write(path, lines, StandardCharsets.UTF_8, options);\n ",
        "Description": " "
    },
    {
        "API": "java.security.cert.X509Extension.getCriticalExtensionOIDs()",
        "Code": "X509Certificate cert = null;\n try (InputStream inStrm = new FileInputStream(\"DER-encoded-Cert\")) {\n     CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n     cert = (X509Certificate)cf.generateCertificate(inStrm);\n }\n\n Set<String> critSet = cert.getCriticalExtensionOIDs();\n if (critSet != null && !critSet.isEmpty()) {\n     System.out.println(\"Set of critical extensions:\");\n     for (String oid : critSet) {\n         System.out.println(oid);\n     }\n }\n ",
        "Description": " "
    },
    {
        "API": "java.security.cert.X509Extension.getNonCriticalExtensionOIDs()",
        "Code": "CertificateFactory cf = null;\n X509CRL crl = null;\n try (InputStream inStrm = new FileInputStream(\"DER-encoded-CRL\")) {\n     cf = CertificateFactory.getInstance(\"X.509\");\n     crl = (X509CRL)cf.generateCRL(inStrm);\n }\n\n byte[] certData = <DER-encoded certificate data>\n ByteArrayInputStream bais = new ByteArrayInputStream(certData);\n X509Certificate cert = (X509Certificate)cf.generateCertificate(bais);\n X509CRLEntry badCert =\n              crl.getRevokedCertificate(cert.getSerialNumber());\n\n if (badCert != null) {\n     Set<String> nonCritSet = badCert.getNonCriticalExtensionOIDs();\n     if (nonCritSet != null)\n         for (String oid : nonCritSet) {\n             System.out.println(oid);\n         }\n }\n ",
        "Description": " "
    },
    {
        "API": "java.security.cert.CertPath.hashCode()",
        "Code": "hashCode = path.getType().hashCode();\n  hashCode = 31*hashCode + path.getCertificates().hashCode();\n ",
        "Description": " path1.equals(path2)"
    },
    {
        "API": "java.security.cert.TrustAnchor.TrustAnchor(java.security.cert.X509Certificate,byte[])",
        "Code": "NameConstraints ::= SEQUENCE {\n       permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,\n       excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }\n\n  GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree\n\n  GeneralSubtree ::= SEQUENCE {\n       base                    GeneralName,\n       minimum         [0]     BaseDistance DEFAULT 0,\n       maximum         [1]     BaseDistance OPTIONAL }\n\n  BaseDistance ::= INTEGER (0..MAX)\n\n  GeneralName ::= CHOICE {\n       otherName                       [0]     OtherName,\n       rfc822Name                      [1]     IA5String,\n       dNSName                         [2]     IA5String,\n       x400Address                     [3]     ORAddress,\n       directoryName                   [4]     Name,\n       ediPartyName                    [5]     EDIPartyName,\n       uniformResourceIdentifier       [6]     IA5String,\n       iPAddress                       [7]     OCTET STRING,\n       registeredID                    [8]     OBJECT IDENTIFIER}\n ",
        "Description": "RFC 3280 \n Note that the name constraints byte array supplied is cloned to protect\n against subsequent modifications."
    },
    {
        "API": "java.security.cert.X509CertSelector.addSubjectAlternativeName(int,byte[])",
        "Code": "GeneralName ::= CHOICE {\n       otherName                       [0]     OtherName,\n       rfc822Name                      [1]     IA5String,\n       dNSName                         [2]     IA5String,\n       x400Address                     [3]     ORAddress,\n       directoryName                   [4]     Name,\n       ediPartyName                    [5]     EDIPartyName,\n       uniformResourceIdentifier       [6]     IA5String,\n       iPAddress                       [7]     OCTET STRING,\n       registeredID                    [8]     OBJECT IDENTIFIER}\n ",
        "Description": " \n Note that the byte array supplied here is cloned to protect against\n subsequent modifications."
    },
    {
        "API": "java.security.cert.X509CertSelector.setAuthorityKeyIdentifier(byte[])",
        "Code": "AuthorityKeyIdentifier ::= SEQUENCE {\n    keyIdentifier             [0] KeyIdentifier           OPTIONAL,\n    authorityCertIssuer       [1] GeneralNames            OPTIONAL,\n    authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }\n\n KeyIdentifier ::= OCTET STRING\n ",
        "Description": "null \n Authority key identifiers are not parsed by the\n X509CertSelector.  Instead, the values are\n compared using a byte-by-byte comparison.\n \n When the keyIdentifier field of\n AuthorityKeyIdentifier is populated, the value is\n usually taken from the SubjectKeyIdentifier extension\n in the issuer's certificate.  Note, however, that the result of\n X509Certificate.getExtensionValue(<SubjectKeyIdentifier Object\n Identifier>) on the issuer's certificate may NOT be used\n directly as the input to setAuthorityKeyIdentifier.\n This is because the SubjectKeyIdentifier contains\n only a KeyIdentifier OCTET STRING, and not a SEQUENCE of\n KeyIdentifier, GeneralNames, and CertificateSerialNumber.\n In order to use the extension value of the issuer certificate's\n SubjectKeyIdentifier\n extension, it will be necessary to extract the value of the embedded\n KeyIdentifier OCTET STRING, then DER encode this OCTET\n STRING inside a SEQUENCE.\n For more details on SubjectKeyIdentifier, see\n setSubjectKeyIdentifier(byte[]).\n \n Note also that the byte array supplied here is cloned to protect against\n subsequent modifications.\n\nParameters\n\nauthorityKeyID\n\nbyte: the authority key identifier\n        (or null)"
    },
    {
        "API": "java.security.cert.X509CertSelector.setIssuer(byte[])",
        "Code": "Name ::= CHOICE {\n   RDNSequence }\n\n RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\n\n RelativeDistinguishedName ::=\n   SET SIZE (1 .. MAX) OF AttributeTypeAndValue\n\n AttributeTypeAndValue ::= SEQUENCE {\n   type     AttributeType,\n   value    AttributeValue }\n\n AttributeType ::= OBJECT IDENTIFIER\n\n AttributeValue ::= ANY DEFINED BY AttributeType\n ....\n DirectoryString ::= CHOICE {\n       teletexString           TeletexString (SIZE (1..MAX)),\n       printableString         PrintableString (SIZE (1..MAX)),\n       universalString         UniversalString (SIZE (1..MAX)),\n       utf8String              UTF8String (SIZE (1.. MAX)),\n       bmpString               BMPString (SIZE (1..MAX)) }\n ",
        "Description": "null \n Note that the byte array specified here is cloned to protect against\n subsequent modifications."
    },
    {
        "API": "java.security.cert.X509CertSelector.setNameConstraints(byte[])",
        "Code": "NameConstraints ::= SEQUENCE {\n       permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,\n       excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }\n\n  GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree\n\n  GeneralSubtree ::= SEQUENCE {\n       base                    GeneralName,\n       minimum         [0]     BaseDistance DEFAULT 0,\n       maximum         [1]     BaseDistance OPTIONAL }\n\n  BaseDistance ::= INTEGER (0..MAX)\n\n  GeneralName ::= CHOICE {\n       otherName                       [0]     OtherName,\n       rfc822Name                      [1]     IA5String,\n       dNSName                         [2]     IA5String,\n       x400Address                     [3]     ORAddress,\n       directoryName                   [4]     Name,\n       ediPartyName                    [5]     EDIPartyName,\n       uniformResourceIdentifier       [6]     IA5String,\n       iPAddress                       [7]     OCTET STRING,\n       registeredID                    [8]     OBJECT IDENTIFIER}\n ",
        "Description": " \n Note that the byte array supplied here is cloned to protect against\n subsequent modifications."
    },
    {
        "API": "java.security.cert.X509CertSelector.setSubjectKeyIdentifier(byte[])",
        "Code": "SubjectKeyIdentifier ::= KeyIdentifier\n\n KeyIdentifier ::= OCTET STRING\n ",
        "Description": "null \n Since the format of subject key identifiers is not mandated by\n any standard, subject key identifiers are not parsed by the\n X509CertSelector. Instead, the values are compared using\n a byte-by-byte comparison.\n \n Note that the byte array supplied here is cloned to protect against\n subsequent modifications."
    },
    {
        "API": "java.security.cert.X509CertSelector.setSubjectPublicKey(byte[])",
        "Code": "SubjectPublicKeyInfo  ::=  SEQUENCE  {\n   algorithm            AlgorithmIdentifier,\n   subjectPublicKey     BIT STRING  }\n\n AlgorithmIdentifier  ::=  SEQUENCE  {\n   algorithm               OBJECT IDENTIFIER,\n   parameters              ANY DEFINED BY algorithm OPTIONAL  }\n                              -- contains a value of the type\n                              -- registered for use with the\n                              -- algorithm object identifier value\n ",
        "Description": "null \n Note that the byte array supplied here is cloned to protect against\n subsequent modifications."
    },
    {
        "API": "java.security.cert.X509CRLSelector.setIssuerNames(java.util.Collection<?>)",
        "Code": "Name ::= CHOICE {\n   RDNSequence }\n\n RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\n\n RelativeDistinguishedName ::=\n   SET SIZE (1 .. MAX) OF AttributeTypeAndValue\n\n AttributeTypeAndValue ::= SEQUENCE {\n   type     AttributeType,\n   value    AttributeValue }\n\n AttributeType ::= OBJECT IDENTIFIER\n\n AttributeValue ::= ANY DEFINED BY AttributeType\n ....\n DirectoryString ::= CHOICE {\n       teletexString           TeletexString (SIZE (1..MAX)),\n       printableString         PrintableString (SIZE (1..MAX)),\n       universalString         UniversalString (SIZE (1..MAX)),\n       utf8String              UTF8String (SIZE (1.. MAX)),\n       bmpString               BMPString (SIZE (1..MAX)) }\n ",
        "Description": " \n Note that a deep copy is performed on the Collection to\n protect against subsequent modifications."
    },
    {
        "API": "java.security.spec.EllipticCurve.hashCode()",
        "Code": "(field.hashCode() << 6) + (a.hashCode() << 4) + (b.hashCode() << 2)\n ",
        "Description": " "
    },
    {
        "API": "java.sql.Timestamp.hashCode()",
        "Code": "(int)(this.getTime()^(this.getTime() >>> 32))\n ",
        "Description": " "
    },
    {
        "API": "java.text.DateFormat.getTimeZone()",
        "Code": "getCalendar().getTimeZone()\n ",
        "Description": " "
    },
    {
        "API": "java.text.DateFormat.isLenient()",
        "Code": "getCalendar().isLenient()\n ",
        "Description": " "
    },
    {
        "API": "java.text.DateFormat.setLenient(boolean)",
        "Code": "getCalendar().setLenient(lenient)\n ",
        "Description": " "
    },
    {
        "API": "java.text.DateFormat.setTimeZone(java.util.TimeZone)",
        "Code": "getCalendar().setTimeZone(zone)\n ",
        "Description": " "
    },
    {
        "API": "java.time.temporal.TemporalAdjusters.ofDateAdjuster(java.util.function.UnaryOperator<java.time.LocalDate>)",
        "Code": "static TemporalAdjuster TWO_DAYS_LATER =\n       TemporalAdjusters.ofDateAdjuster(date -> date.plusDays(2));\n ",
        "Description": " "
    },
    {
        "API": "java.util.Collection.spliterator()",
        "Code": "Stream<E> s = StreamSupport.stream(() -> spliterator(), spliteratorCharacteristics)\n ",
        "Description": "Supplier These requirements ensure that streams produced by the\n stream() and parallelStream() methods will reflect the\n contents of the collection as of initiation of the terminal stream\n operation."
    },
    {
        "API": "java.util.List.hashCode()",
        "Code": "int hashCode = 1;\n     for (E e : list)\n         hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());\n ",
        "Description": " list1.equals(list2)"
    },
    {
        "API": "java.util.List.subList(int,int)",
        "Code": "list.subList(from, to).clear();\n ",
        "Description": " indexOf"
    },
    {
        "API": "java.util.AbstractList.subList(int,int)",
        "Code": "list.subList(from, to).clear();\n ",
        "Description": " indexOf"
    },
    {
        "API": "java.util.Calendar.after(java.lang.Object)",
        "Code": "compareTo(when) > 0\n ",
        "Description": "Object when"
    },
    {
        "API": "java.util.Calendar.before(java.lang.Object)",
        "Code": "compareTo(when) < 0\n ",
        "Description": "Object when"
    },
    {
        "API": "java.util.Date.hashCode()",
        "Code": "(int)(this.getTime()^(this.getTime() >>> 32))\n ",
        "Description": " "
    },
    {
        "API": "java.util.Random.setSeed(long)",
        "Code": "(seed ^ 0x5DEECE66DL) & ((1L << 48) - 1)",
        "Description": "Random haveNextNextGaussian"
    },
    {
        "API": "java.util.Random.next(int)",
        "Code": "(seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1)",
        "Description": "Random (int)(seed >>> (48 - bits))."
    },
    {
        "API": "java.util.Random.next(int)",
        "Code": "(int)(seed >>> (48 - bits)).",
        "Description": "(seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1) The Art of Computer Programming,"
    },
    {
        "API": "java.util.ResourceBundle.Control.getCandidateLocales(java.lang.String,java.util.Locale)",
        "Code": "\n     Locale(\"ja\", \"\", \"XX\")\n     Locale(\"ja\")\n     Locale.ROOT\n ",
        "Description": "Locale Locale"
    },
    {
        "API": "java.util.ResourceBundle.Control.getCandidateLocales(java.lang.String,java.util.Locale)",
        "Code": "Messages_ja -> Messages\n ",
        "Description": "Locale "
    },
    {
        "API": "java.util.Scanner.reset()",
        "Code": "scanner.useDelimiter(\"\\\\p{javaWhitespace}+\")\n          .useLocale(Locale.getDefault(Locale.Category.FORMAT))\n          .useRadix(10);\n ",
        "Description": " "
    },
    {
        "API": "java.util.SimpleTimeZone.setEndRule(int,int,int)",
        "Code": "setEndRule(endMonth, endDay, 0, endTime)",
        "Description": " "
    },
    {
        "API": "java.util.SimpleTimeZone.setStartRule(int,int,int,int)",
        "Code": "setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2*60*60*1000);",
        "Description": " "
    },
    {
        "API": "java.util.SimpleTimeZone.setStartRule(int,int,int)",
        "Code": "setStartRule(startMonth, startDay, 0, startTime)",
        "Description": " "
    },
    {
        "API": "java.util.SimpleTimeZone.SimpleTimeZone(int,java.lang.String,int,int,int,int,int,int,int,int)",
        "Code": "\n     SimpleTimeZone(rawOffset,\n                    ID,\n                    startMonth,\n                    startDay,\n                    startDayOfWeek,\n                    startTime,\n                    SimpleTimeZone.WALL_TIME,\n                    endMonth,\n                    endDay,\n                    endDayOfWeek,\n                    endTime,\n                    SimpleTimeZone.WALL_TIME,\n                    3600000)\n ",
        "Description": "endTime "
    },
    {
        "API": "java.util.SimpleTimeZone.SimpleTimeZone(int,java.lang.String,int,int,int,int,int,int,int,int,int)",
        "Code": "\n     SimpleTimeZone(rawOffset,\n                    ID,\n                    startMonth,\n                    startDay,\n                    startDayOfWeek,\n                    startTime,\n                    SimpleTimeZone.WALL_TIME,\n                    endMonth,\n                    endDay,\n                    endDayOfWeek,\n                    endTime,\n                    SimpleTimeZone.WALL_TIME,\n                    dstSavings)\n ",
        "Description": "endTime "
    },
    {
        "API": "java.util.TimerTask.scheduledExecutionTime()",
        "Code": "public void run() {\n       if (System.currentTimeMillis() - scheduledExecutionTime() >=\n           MAX_TARDINESS)\n               return;  // Too late; skip this execution.\n       // Perform the task\n   }\n ",
        "Description": " not"
    },
    {
        "API": "java.util.concurrent.ConcurrentHashMap.KeySetView.spliterator()",
        "Code": "Stream<E> s = StreamSupport.stream(() -> spliterator(), spliteratorCharacteristics)\n ",
        "Description": "Supplier These requirements ensure that streams produced by the\n stream() and parallelStream() methods will reflect the\n contents of the collection as of initiation of the terminal stream\n operation."
    },
    {
        "API": "java.util.concurrent.ThreadLocalRandom.next(int)",
        "Code": "(seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1)",
        "Description": "Random (int)(seed >>> (48 - bits))."
    },
    {
        "API": "java.util.concurrent.ThreadLocalRandom.next(int)",
        "Code": "(int)(seed >>> (48 - bits)).",
        "Description": "(seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1) The Art of Computer Programming,"
    },
    {
        "API": "java.util.prefs.Preferences.exportNode(java.io.OutputStream)",
        "Code": "<!DOCTYPE preferences SYSTEM \"http://java.sun.com/dtd/preferences.dtd\">\n ",
        "Description": " This method is an exception to the general rule that the results of\n concurrently executing multiple methods in this class yields\n results equivalent to some serial execution.  If the preferences\n at this node are modified concurrently with an invocation of this\n method, the exported preferences comprise a \"fuzzy snapshot\" of the\n preferences contained in the node; some of the concurrent modifications\n may be reflected in the exported data while others may not."
    },
    {
        "API": "java.util.prefs.Preferences.exportSubtree(java.io.OutputStream)",
        "Code": "<!DOCTYPE preferences SYSTEM \"http://java.sun.com/dtd/preferences.dtd\">\n ",
        "Description": " This method is an exception to the general rule that the results of\n concurrently executing multiple methods in this class yields\n results equivalent to some serial execution.  If the preferences\n or nodes in the subtree rooted at this node are modified concurrently\n with an invocation of this method, the exported preferences comprise a\n \"fuzzy snapshot\" of the subtree; some of the concurrent modifications\n may be reflected in the exported data while others may not."
    },
    {
        "API": "java.util.prefs.Preferences.importPreferences(java.io.InputStream)",
        "Code": "<!DOCTYPE preferences SYSTEM \"http://java.sun.com/dtd/preferences.dtd\">\n ",
        "Description": " exportNode(OutputStream)"
    },
    {
        "API": "java.util.stream.DoubleStream.collect(java.util.function.Supplier<R>,java.util.function.ObjDoubleConsumer<R>,,\u00c2 R>)",
        "Code": "R result = supplier.get();\n     for (double element : this stream)\n         accumulator.accept(result, element);\n     return result;\n ",
        "Description": "ArrayList Like reduce(double, DoubleBinaryOperator), collect\n operations can be parallelized without requiring additional\n synchronization.\n\n This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.DoubleStream.count()",
        "Code": "return mapToLong(e -> 1L).sum();\n ",
        "Description": "reduction This is a terminal operation."
    },
    {
        "API": "java.util.stream.DoubleStream.max()",
        "Code": "return reduce(Double::max);\n ",
        "Description": "reduction This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.DoubleStream.min()",
        "Code": "return reduce(Double::min);\n ",
        "Description": "reduction This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.DoubleStream.reduce(java.util.function.DoubleBinaryOperator)",
        "Code": "boolean foundAny = false;\n     double result = null;\n     for (double element : this stream) {\n         if (!foundAny) {\n             foundAny = true;\n             result = element;\n         }\n         else\n             result = accumulator.applyAsDouble(result, element);\n     }\n     return foundAny ? OptionalDouble.of(result) : OptionalDouble.empty();\n ",
        "Description": "OptionalDouble The accumulator function must be an\n associative function.\n\n This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.DoubleStream.reduce(double,java.util.function.DoubleBinaryOperator)",
        "Code": "double result = identity;\n     for (double element : this stream)\n         result = accumulator.applyAsDouble(result, element)\n     return result;\n ",
        "Description": "associative The identity value must be an identity for the accumulator\n function. This means that for all x,\n accumulator.apply(identity, x) is equal to x.\n The accumulator function must be an\n associative function.\n\n This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.DoubleStream.sum()",
        "Code": "return reduce(0, Double::sum);\n ",
        "Description": "reduction If any stream element is a NaN or the sum is at any point a NaN\n then the sum will be NaN.\n\n The value of a floating-point sum is a function both\n of the input values as well as the order of addition\n operations. The order of addition operations of this method is\n intentionally not defined to allow for implementation\n flexibility to improve the speed and accuracy of the computed\n result.\n\n In particular, this method may be implemented using compensated\n summation or other technique to reduce the error bound in the\n numerical sum compared to a simple summation of double\n values.\n\n This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.IntStream.collect(java.util.function.Supplier<R>,java.util.function.ObjIntConsumer<R>,,\u00c2 R>)",
        "Code": "R result = supplier.get();\n     for (int element : this stream)\n         accumulator.accept(result, element);\n     return result;\n ",
        "Description": "ArrayList Like reduce(int, IntBinaryOperator), collect operations\n can be parallelized without requiring additional synchronization.\n\n This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.IntStream.count()",
        "Code": "return mapToLong(e -> 1L).sum();\n ",
        "Description": "reduction This is a terminal operation."
    },
    {
        "API": "java.util.stream.IntStream.max()",
        "Code": "return reduce(Integer::max);\n ",
        "Description": "reduction This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.IntStream.min()",
        "Code": "return reduce(Integer::min);\n ",
        "Description": "reduction This is a terminal operation."
    },
    {
        "API": "java.util.stream.IntStream.reduce(java.util.function.IntBinaryOperator)",
        "Code": "boolean foundAny = false;\n     int result = null;\n     for (int element : this stream) {\n         if (!foundAny) {\n             foundAny = true;\n             result = element;\n         }\n         else\n             result = accumulator.applyAsInt(result, element);\n     }\n     return foundAny ? OptionalInt.of(result) : OptionalInt.empty();\n ",
        "Description": "OptionalInt The accumulator function must be an\n associative function.\n\n This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.IntStream.reduce(int,java.util.function.IntBinaryOperator)",
        "Code": "int result = identity;\n     for (int element : this stream)\n         result = accumulator.applyAsInt(result, element)\n     return result;\n ",
        "Description": "associative The identity value must be an identity for the accumulator\n function. This means that for all x,\n accumulator.apply(identity, x) is equal to x.\n The accumulator function must be an\n associative function.\n\n This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.IntStream.sum()",
        "Code": "return reduce(0, Integer::sum);\n ",
        "Description": "reduction This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.LongStream.collect(java.util.function.Supplier<R>,java.util.function.ObjLongConsumer<R>,,\u00c2 R>)",
        "Code": "R result = supplier.get();\n     for (long element : this stream)\n         accumulator.accept(result, element);\n     return result;\n ",
        "Description": "ArrayList Like reduce(long, LongBinaryOperator), collect operations\n can be parallelized without requiring additional synchronization.\n\n This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.LongStream.count()",
        "Code": "return map(e -> 1L).sum();\n ",
        "Description": "reduction This is a terminal operation."
    },
    {
        "API": "java.util.stream.LongStream.max()",
        "Code": "return reduce(Long::max);\n ",
        "Description": "reduction This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.LongStream.min()",
        "Code": "return reduce(Long::min);\n ",
        "Description": "reduction This is a terminal operation."
    },
    {
        "API": "java.util.stream.LongStream.reduce(java.util.function.LongBinaryOperator)",
        "Code": "boolean foundAny = false;\n     long result = null;\n     for (long element : this stream) {\n         if (!foundAny) {\n             foundAny = true;\n             result = element;\n         }\n         else\n             result = accumulator.applyAsLong(result, element);\n     }\n     return foundAny ? OptionalLong.of(result) : OptionalLong.empty();\n ",
        "Description": "OptionalLong The accumulator function must be an\n associative function.\n\n This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.LongStream.reduce(long,java.util.function.LongBinaryOperator)",
        "Code": "long result = identity;\n     for (long element : this stream)\n         result = accumulator.applyAsLong(result, element)\n     return result;\n ",
        "Description": "associative The identity value must be an identity for the accumulator\n function. This means that for all x,\n accumulator.apply(identity, x) is equal to x.\n The accumulator function must be an\n associative function.\n\n This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.LongStream.sum()",
        "Code": "return reduce(0, Long::sum);\n ",
        "Description": "reduction This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.Stream.count()",
        "Code": "return mapToLong(e -> 1L).sum();\n ",
        "Description": "reduction This is a terminal operation."
    },
    {
        "API": "java.util.stream.Stream.reduce(T,java.util.function.BinaryOperator<T>)",
        "Code": "T result = identity;\n     for (T element : this stream)\n         result = accumulator.apply(result, element)\n     return result;\n ",
        "Description": "associative The identity value must be an identity for the accumulator\n function. This means that for all t,\n accumulator.apply(identity, t) is equal to t.\n The accumulator function must be an\n associative function.\n\n This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.Stream.reduce(java.util.function.BinaryOperator<T>)",
        "Code": "boolean foundAny = false;\n     T result = null;\n     for (T element : this stream) {\n         if (!foundAny) {\n             foundAny = true;\n             result = element;\n         }\n         else\n             result = accumulator.apply(result, element);\n     }\n     return foundAny ? Optional.of(result) : Optional.empty();\n ",
        "Description": "Optional The accumulator function must be an\n associative function.\n\n This is a terminal\n operation."
    },
    {
        "API": "java.util.stream.Collectors.collectingAndThen(,,R>,,RR>)",
        "Code": "List<String> people\n         = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList));\n ",
        "Description": "toList() "
    },
    {
        "API": "java.util.stream.Collectors.groupingByConcurrent(java.util.function.Function<? super,? extends K>,java.util.stream.Collector<? super,,D>)",
        "Code": "ConcurrentMap<City, Set<String>> namesByCity\n         = people.stream().collect(groupingByConcurrent(Person::getCity,\n                                                        mapping(Person::getLastName, toSet())));\n ",
        "Description": " "
    },
    {
        "API": "javax.security.auth.callback.CallbackHandler.handle(javax.security.auth.callback.Callback)",
        "Code": "public void handle(Callback[] callbacks)\n throws IOException, UnsupportedCallbackException {\n\n   for (int i = 0; i < callbacks.length; i++) {\n      if (callbacks[i] instanceof TextOutputCallback) {\n\n          // display the message according to the specified type\n          TextOutputCallback toc = (TextOutputCallback)callbacks[i];\n          switch (toc.getMessageType()) {\n          case TextOutputCallback.INFORMATION:\n              System.out.println(toc.getMessage());\n              break;\n          case TextOutputCallback.ERROR:\n              System.out.println(\"ERROR: \" + toc.getMessage());\n              break;\n          case TextOutputCallback.WARNING:\n              System.out.println(\"WARNING: \" + toc.getMessage());\n              break;\n          default:\n              throw new IOException(\"Unsupported message type: \" +\n                                  toc.getMessageType());\n          }\n\n      } else if (callbacks[i] instanceof NameCallback) {\n\n          // prompt the user for a username\n          NameCallback nc = (NameCallback)callbacks[i];\n\n          // ignore the provided defaultName\n          System.err.print(nc.getPrompt());\n          System.err.flush();\n          nc.setName((new BufferedReader\n                  (new InputStreamReader(System.in))).readLine());\n\n      } else if (callbacks[i] instanceof PasswordCallback) {\n\n          // prompt the user for sensitive information\n          PasswordCallback pc = (PasswordCallback)callbacks[i];\n          System.err.print(pc.getPrompt());\n          System.err.flush();\n          pc.setPassword(readPassword(System.in));\n\n      } else {\n          throw new UnsupportedCallbackException\n                  (callbacks[i], \"Unrecognized Callback\");\n      }\n   }\n }\n\n // Reads user password from given input stream.\n private char[] readPassword(InputStream in) throws IOException {\n    // insert code to read a user password from the input stream\n }\n ",
        "Description": "handle "
    },
    {
        "API": "javax.security.auth.x500.X500Principal.X500Principal(byte[])",
        "Code": "Name ::= CHOICE {\n   RDNSequence }\n\n RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\n\n RelativeDistinguishedName ::=\n   SET SIZE (1 .. MAX) OF AttributeTypeAndValue\n\n AttributeTypeAndValue ::= SEQUENCE {\n   type     AttributeType,\n   value    AttributeValue }\n\n AttributeType ::= OBJECT IDENTIFIER\n\n AttributeValue ::= ANY DEFINED BY AttributeType\n ....\n DirectoryString ::= CHOICE {\n       teletexString           TeletexString (SIZE (1..MAX)),\n       printableString         PrintableString (SIZE (1..MAX)),\n       universalString         UniversalString (SIZE (1..MAX)),\n       utf8String              UTF8String (SIZE (1.. MAX)),\n       bmpString               BMPString (SIZE (1..MAX)) }\n ",
        "Description": "X500Principal "
    },
    {
        "API": "javax.security.cert.X509Certificate.getInstance(byte[])",
        "Code": "public <subClass>(InputStream inStream) ...\n ",
        "Description": " "
    },
    {
        "API": "javax.security.cert.X509Certificate.getInstance(java.io.InputStream)",
        "Code": "public <subClass>(InputStream inStream) ...\n ",
        "Description": " "
    }
]